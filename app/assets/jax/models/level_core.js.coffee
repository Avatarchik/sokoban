###
Class containing a level and every methods about it

Positions in grid start in the upper-left corner with (m=0,n=0).

Example : (2,4) means third rows and fifth cols starting in the upper-left
corner.

Grid is made like this in loaded files :  
###

#      #####                 # -> wall
#      #   #                 $ -> box
#      #$  #                 . -> goal
#    ###  $##                * -> box on a goal (not in this figure)
#    #  $ $ #                @ -> pusher
#  ### # ## #   ######       + -> pusher on a goal
#  #   # ## #####  ..#       s -> inside floor (generated by recursive
#  # $  $          ..#            algorithm in program memory)
#  ##### ### #@##  ..#
#      #     #########
#      #######

class window.LevelCore
  
  # Constructor
  constructor: ->
    @pack_name = ""            # Name of pack that contains this level
    @level_name = ""           # Name of this level
    @copyright = ""            # Copyright of this level
    @grid = []                 # Grid of the level
    @boxes_number = 0          # Number of boxes in this level
    @goals_number = 0          # Number of goals in this level
    @rows_number = 0           # Rows number
    @cols_number = 0           # Cols number
    @pusher_pos_m = 0          # M position of the pusher
    @pusher_pos_n = 0          # N position of the pusher
    
  create_from_file: (pack_file_name, level_name) ->
    @level_from_file(pack_name, level_name)
    
  create_from_database: (pack_name, level_name) ->
    @level_from_database(pack_name, level_name)
    
  create_from_grid: (grid, width, height, pack_name, level_name, copyright = "") ->
    @level_from_grid(grid, width, height, pack_name, level_name, copyright)
    
  create_from_line: (line, width, height, pack_name, level_name, copyright = "") ->
    @level_from_line(line, width, height, pack_name, level_name, copyright)
    
  ###
    Read the value of position (m,n).
    Position start in the upper-left corner of the grid with (0,0).
    @param m Row number.
    @param n Col number.
    @return Value of position (m,n) or 'E' if pos is out of grid.
  ###
  read_pos: (m, n) ->
    if m < @rows_number and n < @cols_number and m >= 0 and n >= 0
      return @grid[@cols_number*m + n]
    else
      return 'E'
  
  ###
    Write the value of letter in position (m,n).
    Position start in the upper-left corner of the grid with (0,0).
    @param m Row number.
    @param n Col number.
    @param letter value to assign at (m,n) in the grid
  ###
  write_pos: (m, n, letter) ->
    if m < @rows_number and n < @cols_number and m >= 0 and n >= 0
      @grid[@cols_number*m + n] = letter
  
  ###
    Look if pusher can move in a given direction
    @param direction 'u', 'd', 'l', 'r' in lowercase and uppercase
    @return true if pusher can move in this direction, false if not.
  ###
  pusher_can_move: (direction) ->
    mouv1 = ' '
    mouv2 = ' '
    m = @pusher_pos_m
    n = @pusher_pos_n
  
    # Following of the direction, test 2 cells
    if direction == 'u'
      mouv1 = @read_pos(m-1, n)
      mouv2 = @read_pos(m-2, n)
    else if direction == 'd'
      mouv1 = @read_pos(m+1, n)
      mouv2 = @read_pos(m+2, n)
    else if direction == 'l'
      mouv1 = @read_pos(m, n-1)
      mouv2 = @read_pos(m, n-2)
    else if direction == 'r'
      mouv1 = @read_pos(m, n+1)
      mouv2 = @read_pos(m, n+2)
  
    # If (there is a wall) OR (two boxes or one box and a wall)
    if mouv1 == '#' or ((mouv1 == '*' || mouv1 == '$') and (mouv2 == '*' || mouv2 == '$' || mouv2 == '#'))
      return false
    else
      return true
  
  ###
    Move the pusher in a given direction and save it in the actualPath
    @param direction Direction where to move the pusher (u,d,l,r,U,D,L,R)
    @return 0 if no move.
            1 if normal move.
            2 if box push.
  ###
  move: (direction) ->
    action = 1
    m = @pusher_pos_m
    n = @pusher_pos_n
  
    # accept upper and lower dir
    direction = direction.toLowerCase()
      
    # Following of the direction, test 2 cells
    if direction == 'u' && @pusher_can_move('u')
      m_1 = m-1
      m_2 = m-2
      n_1 = n_2 = n
      @pusher_pos_m--
    else if direction == 'd' && @pusher_can_move('d')
      m_1 = m+1
      m_2 = m+2
      n_1 = n_2 = n
      @pusher_pos_m++
    else if direction == 'l' && @pusher_can_move('l')
      n_1 = n-1
      n_2 = n-2
      m_1 = m_2 = m
      @pusher_pos_n--
    else if direction == 'r' && @pusher_can_move('r')
      n_1 = n+1
      n_2 = n+2
      m_1 = m_2 = m
      @pusher_pos_n++
    else
      action = 0
      state = 0
  
    # Move accepted
    if action == 1
      state = 1
      
      # Test on cell (m,n)
      if @read_pos(m, n) == '+'
        @write_pos(m, n, '.')
      else
        @write_pos(m, n, 's')
  
      # Test on cell (m_2,n_2)
      if @read_pos(m_1, n_1) == '$' or @read_pos(m_1, n_1) == '*'
        if @read_pos(m_2, n_2) == '.'
          @write_pos(m_2, n_2, '*')
        else
          @write_pos(m_2, n_2, '$')
  
        state = 2
  
      # Test on cell (m_1, n_1)
      if @read_pos(m_1, n_1) == '.' || @read_pos(m_1, n_1)=='*'
        @write_pos(m_1, n_1, '+')
      else
        @write_pos(m_1, n_1, '@')
  
    return state
  
  ###
    Move the pusher backward and erase last move in the path
    @return 0 if no move.
            1 if normal move.
            2 if box move.
  ###
  delete_last_move: (path) ->
    action = 1
    maj = 0
    m = @pusher_pos_m
    n = @pusher_pos_n
    direction = path.get_last_move()
    state = 1;
  
    if direction == 'U' || direction == 'D' || direction == 'L' || direction == 'R'
      maj = 1
      state = 2
  
    # Following of the direction, test 2 cells
    if direction == 'u' || direction == 'U'
      m_1 = m - 1
      m_2 = m + 1
      n_1 = n_2 = n
      @pusher_pos_m++
    else if direction == 'd'  || direction == 'D'
      m_1 = m + 1
      m_2 = m - 1
      n_1 = n_2 = n
      @pusher_pos_m--
    else if direction == 'l' || direction == 'L'
      n_1 = n - 1
      n_2 = n + 1
      m_1 = m_2 = m
      @pusher_pos_n++
    else if direction == 'r' || direction == 'R'
      n_1 = n + 1
      n_2 = n - 1
      m_1 = m_2 = m
      @pusher_pos_n--
    else
      action = 0
      state = 0
  
    if action == 1 
      # Test of cell (m_2,n_2)
      if @read_pos(m_2, n_2) == '.'
        @write_pos(m_2, n_2, '+')
      else
        @write_pos(m_2, n_2, '@')
  
      # Test of cell (m_1, n_1)
      if @read_pos(m_1, n_1) == '*' && maj == 1
        @write_pos(m_1, n_1, '.')
      else if @read_pos(m_1, n_1) == '$' && maj == 1
        @write_pos(m_1, n_1, 's')
  
      # Test of cell (m,n)
      if @read_pos(m, n) == '+' && maj == 0
        @write_pos(m, n, '.')
      else if @read_pos(m, n) == '@' && maj == 0
        @write_pos(m, n, 's')
      else if @read_pos(m, n) == '+' && maj == 1
        @write_pos(m, n, '*')
      else if @read_pos(m, n) == '@' && maj == 1
        @write_pos(m, n, '$')
  
    path.delete_last_move()
  
    return state
  
  
  ###
    Return true if all boxes are in their goals.
    @return true if all boxes are in their goals, false if not
  ###
  is_won: ->
    for i in [0..@rowsNumber*@colsNumber-1]
      if grid[i] == '$'
        return false;
    return true;
    
  ###
    Return true if the path is leading to a solution
    @return true if all boxes are in their goals, false if not
  ###
  is_solution_path: (path) ->
    for move in path.moves
      @move(move)
    return @is_won()
  
  ###
    Initialize (find) starting position of pusher to store it in this object
  ### 
  initialize_pusher_position: ->
    find = false
  
    for cell, i in @grid
      if not find and cell in ['@', '+']
        @pusher_pos_n = i % @cols_number
        @pusher_pos_m = Math.floor(i / @cols_number)
        find = true
  
  ###
    Transform empty spaces inside level in floor represented by 's' used
    to draw the level. Call to recursive function "makeFloorRec".
  ###
  make_floor: ->
    # Recursively set "inside floor" to 's' starting with pusher position
    @make_floor_rec(@pusher_pos_m, @pusher_pos_n)
  
    # Set back modified (by recusively method) symbols to regular symbols
    for cell, i in @grid
      if cell == 'p'
        @grid[i] = '.'
      else if cell == 'd' 
        @grid[i] = '$'
      else if cell == 'a'
        @grid[i] = '*'
  
  ###
    Recursive function used to transform inside spaces by floor ('s')
    started with initial position of sokoban.
    NEVER use this function directly. Use make_floor instead.
    @param m Rows number (start with sokoban position)
    @param n Cols number (start with sokoban position)
  ###
  make_floor_rec: (m, n) ->
    a = @read_pos(m, n)
  
    # Change of values to "floor" or "visited"
    if a == ' '
      @write_pos(m, n, 's')
    else if a == '.'
      @write_pos(m, n, 'p')
    else if a == '$'
      @write_pos(m, n, 'd')
    else if a == '*'
      @write_pos(m, n, 'a')
  
    # If non-visited cell, test neighbours cells
    if a != '#' && a != 's' && a != 'p' && a != 'd' && a != 'a'
      @make_floor_rec(m+1, n)
      @make_floor_rec(m-1, n)
      @make_floor_rec(m, n+1)
      @make_floor_rec(m, n-1)
  
  ###
    Print the level in the javascript console
  ###
  print: ->
    for m in [0..@rows_number-1]
      line = ""
      for n in [0..@cols_number-1]
        line = line + @read_pos(m, n)
      console.log(line + '\n')
  
  ###
    Load a specific level in a XML pack
  ###
  level_from_file: (pack_name, level_name) ->
    @pack_name = pack_name
    @level_name = level_name
    
    $.ajax({
      type:     "GET",
      url:      "./levels/" + @pack_name + ".slc",
      dataType: "xml",
      success:  @xml_parser
      async:    false
      context:  @
    })
  
  ### 
    take the xml buffer of a pack (callback of "xml_load") and load 
    the "id" level in it (where id is the string name of level)
    @param xml the buffer (callback of xml_load)
  ###
  xml_parser: (xml) ->
    xml_level = $(xml).find('Level[Id="' + @level_name + '"]')
  
    @rows_number = $(xml_level).attr("Height")
    @cols_number = $(xml_level).attr("Width")
    if copyright = $(xml_level).attr("Copyright")
      @copyright = copyright
  
    for i in [0..@rows_number*@cols_number-1]
      @grid[i] = ' '
  
    lines = $(xml_level).find("L")
  
    for line, i in lines
      text = $(line).text()
      for j in [0..text.length-1]
        @grid[@cols_number*i + j] = text.charAt(j)
  
    @initialize_level_properties()
    
  level_from_database: (pack_name, level_name) ->
    jqxhr = $.ajax({ 
              url: 'http://' + location.host + '/packs/' + pack_name + '/levels/' + level_name,
              async:false
            })
                    
    jqxhr.success((data, status, xhr) =>
      @pack_name = data.pack_name
      @level_name = data.level_name
      @copyright = data.copyright
      @rows_number = data.rows_number
      @cols_number = data.cols_number
      
      for i in [0..@rows_number*@cols_number-1]
        @grid[i] = data.grid.substr(i, 1)
        
      @initialize_level_properties()
    )
  
  level_from_grid: (grid, width, height, pack_name, level_name, copyright = "") ->
    @pack_name = pack_name
    @level_name = level_name
    @copyright = copyright
    @rows_number = height
    @cols_number = width

    for line, i in grid
      for j in [0..line.length-1]
        @grid.push(line.charAt(j))

    @initialize_level_properties()
    
  level_from_line: (line, width, height, pack_name, level_name, copyright = "") ->
    @pack_name = pack_name
    @level_name = level_name
    @copyright = copyright
    @rows_number = height
    @cols_number = width
  
    for i in [0..height*width-1]
      @grid.push(line.charAt(i))
  
    @initialize_level_properties()
        
  initialize_level_properties: ->
    # Find initial position of pusher
    @initialize_pusher_position()

    # Make floor inside the level
    @make_floor()

    # Initialize number of boxes and goals
    for cell in @grid
      if cell == '*' || cell == '$'
        @boxes_number = @boxes_number + 1
      if cell == '+' || cell == '*' || cell == '.'
        @goals_number = @goals_number + 1
