<div id="limited-content">

<h1 class="chapter"><span class="chapter_label">Chapitre 5</span> <a id='magicparlabel-2408' />
Prérequis</h1>
<div class="standard"><a id='magicparlabel-2409' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-2410' />
</div>

<div class="standard"><a id='magicparlabel-2415' />
Pour appréhender correctement les différentes constructions possibles d'un arbre de recherche, nous devons commencer par bien assimiler certains concepts de base. Nous avons choisi une approche qui va du plus général (l'algorithme principal) au plus particulier afin de bien comprendre l'intérêt de certaines structures élémentaires qui seront utilisées tout au long de ce document.</div>
<h2 class="section"><span class="section_label">5.1</span> <a id='magicparlabel-2416' />
Algorithme principal</h2>
<div class="standard"><a id='magicparlabel-2417' />
Le fonctionnement principal du solveur est détaillé dans l'Algorithme 1. L'implémentation proposée, bien que de haut niveau et très simplifiée, présente les mécanismes les plus importants d'un tel programme. Pour pouvoir créer l'arbre de recherche, on utilise une <em>liste d'attente</em>, dont le fonctionnement sera décrit dans la Section <a href="#sec_Liste_d_attente">5.4</a>.
<br />

</div>

<div class="standard"><a id='magicparlabel-2418' />
</div>

<div class="standard"><a id='magicparlabel-2448' />
Voici quelques explications sur les fonctions utilisées :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2453' />
<em>initialisation(niveau)</em> : avant de pouvoir créer l'arbre de recherche, nous avons besoin d'initialiser plusieurs éléments dont l'état initial : celui pour lequel la disposition des caisses correspond exactement à celle du niveau. Cet état sera inséré dans la liste d'attente en tout premier lieu afin d'être introduit comme racine de l'arbre de recherche. Les autres initialisations correspondent aux structures de données qui seront utiles par la suite telles que les tables de hachage, les zones de deadlocks ou les zones de goals.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2454' />
<em>premierNoeudDeListe()</em> : Récupère le premier <em>nœud</em> (et donc un état, <em>cf</em>. Section <a href="#sub_Noeud">5.3</a>) de la liste d'attente.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2455' />
<em>estSolution(noeud)</em> : Teste si l'état contenu dans le nœud est solution en vérifiant que toutes les caisses se trouvent sur des goals.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2456' />
<em>chercheEnfants(noeud)</em> : à partir d'un nœud, retourne la liste des nœuds considérés comme enfants, c'est-à-dire à une poussée de l'état contenu dans le nœud tel que représenté sur la Figure <a href="#fig_Arbre_repr__sentant_les">4.1</a>.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2457' />
<em>dejaExistant(noeud) </em>: indique si un nœud existe déjà dans l'arbre de recherche.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2458' />
<em>deadlock(noeud)</em> : indique si l'état contenu dans le nœud est un deadlock et donc provoque une impasse dans l'arbre de recherche.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2459' />
<em>ajouteDansArbre(noeud)</em> : ajoute un nœud à sa place dans l'arbre de recherche.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2460' />
<em>ajouteDansListe(noeud)</em> : ajoute un nœud dans la liste d'attente. De l'endroit où le nœud sera ajouté dépendra la méthode de création de l'arbre de recherche.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2461' />
<em>supprime(noeud)</em> : supprime un nœud. Il ne sera conservé ni dans l'arbre de recherche, ni dans la liste d'attente ou la table de hachage.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2462' />
<em>recupereChemin(noeud)</em> : à partir du nœud solution, permet de remonter vers la racine de l'arbre de recherche en évoluant de père en père. Cela permet de déduire, via un algorithme non-trivial, le chemin solution emprunté par le pousseur à partir de la racine.</li>
</ul>
<h2 class="section"><span class="section_label">5.2</span> <a id='magicparlabel-2463' />
<a id="sec___tat" />
État</h2>
<div class="standard"><a id='magicparlabel-2464' />
Un <em>état</em> est représenté par la position du pousseur et par celle des caisses. Grâce à la notion d'état généralisé, la position du pousseur est définie comme l'ensemble des positions que le pousseur peut atteindre dans l'état sans devoir pousser de caisses.
<br />

</div>

<div class="standard"><a id='magicparlabel-2465' />
Les différentes données contenues dans un état, qu'elles soient relatives aux caisses ou au pousseur, ne sont rien de plus que des ensembles contenant des positions. Les représentations peuvent donc être faites à l'aide d'un même outil. Cet outil, la zone, permet de gérer facilement différents ensembles de positions (<em>cf. </em>Section <a href="#sec_Zone">5.5</a>).
<br />

</div>

<div class="standard"><a id='magicparlabel-2466' />
Comme nous l'avons signalé dans la Section <a href="#sec_Arbre_de_recherche">4.1</a>, la structure d'un état ne doit pas contenir d'information relative aux positions des goals et des murs. Celles-ci sont stockées au début de la résolution d'un niveau et ne sont plus recalculées par la suite.
<br />

</div>

<div class="standard"><a id='magicparlabel-2467' />
La Figure <a href="#fig_Structure_d_un_etat">5.1</a> représente la structure d'un état tel qu'il est stocké en mémoire. Les croix représentent les positions qui sont utilisées respectivement par les caisses et par le pousseur. La zone du pousseur comprend également les caisses voisines de son champ d'action. Nous verrons dans la section <a href="#sec_Zone">5.5</a> pourquoi nous procédons de la sorte.</div>

<div class="standard"><a id='magicparlabel-2468' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2472' />
<img style='width:80%;' src='assets/master_thesis/22_Users_michael_Desktop_memoire_images_etat_etat2.png' alt='image: 22_Users_michael_Desktop_memoire_images_etat_etat2.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2473' />
<div class='float-caption float-caption-figure'>Figure 5.1:<div class="plain_layout"><a id='magicparlabel-2477' />
<a id="fig_Structure_d_un_etat" />
Structure d'un état</div>
</div></div>
</div>

<h2 class="section"><span class="section_label">5.3</span> <a id='magicparlabel-2478' />
<a id="sub_Noeud" />
Nœud</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-2479' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-2483' />
<strong>nœud</strong> : élément utilisé pour construire un arbre de recherche, il permet de situer un état par rapport à son père et à ses fils.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-2484' />
Un <em>nœud</em> est un élément qui englobe un état et qui lui permet de se greffer sur un arbre de recherche existant. Il donne à l'état la possibilité d'interagir avec les autres états présents dans l'arbre de recherche. Comme on peut le voir sur la Figure <a href="#fig_Structure_d_un_noeud">5.2</a>, le nœud contient un état ainsi que des références vers son nœud père et ses nœuds fils.
<br />

</div>

<div class="standard"><a id='magicparlabel-2485' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2489' />
<img style='width:30%;' src='assets/master_thesis/23_Users_michael_Desktop_memoire_images_noeud.png' alt='image: 23_Users_michael_Desktop_memoire_images_noeud.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2490' />
<div class='float-caption float-caption-figure'>Figure 5.2:<div class="plain_layout"><a id='magicparlabel-2494' />
<a id="fig_Structure_d_un_noeud" />
Structure d'un nœud</div>
</div></div>

<div class="plain_layout"><a id='magicparlabel-2495' />
</div>
</div>


<div class="standard"><a id='magicparlabel-2496' />
Dans la suite de ce document, le terme &ldquo;nœud&rdquo; sera utilisé pour parler d'un état lorsque la volonté sera d'insister sur sa position et ses relations au sein de l'arbre de recherche.</div>
<h2 class="section"><span class="section_label">5.4</span> <a id='magicparlabel-2497' />
<a id="sec_Liste_d_attente" />
Liste d'attente</h2>
<div class="standard"><a id='magicparlabel-2498' />
La <em>liste d'attente</em> permet de stocker les nœuds qui n'ont pas encore été traités. Un nœud traité est un nœud pour lequel nous avons trouvé et placé les enfants dans l'arbre de recherche et dans la liste d'attente si ceux-ci s'avèrent utiles. Le parcours de l'arbre de recherche dépend de la manière dont nous manipulons les nœuds en attente dans cette liste.
<br />

</div>

<div class="standard"><a id='magicparlabel-2499' />
La liste d'attente est une structure de données dans laquelle nous pouvons ajouter et retirer des éléments. La structure de données la plus simple dans le cadre de la construction d'un arbre de recherche est <em>la liste doublement chaînée</em>. Le concept d'une liste dont chaque élément est relié à son prédécesseur et à son successeur permet de gérer très facilement des structures de types <em>LIFO</em> (Last In, First Out) ou <em>FIFO</em> (First In, First Out).
<br />

</div>

<div class="standard"><a id='magicparlabel-2500' />
Dans d'autres cas de constructions plus complexes, une contrainte impose que la liste reste triée. Chaque nœud possède alors un certain coût et la liste doit conserver un ordre prédéfini. Pour cela, l'insertion doit veiller à positionner les nouveaux éléments aux endroits adéquats. Les listes doublement chaînées auraient pu fonctionner dans un tel cas mais avec une complexité qui aurait été désastreuse en cas d'insertion triée (<em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> </em>où<em> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math></em> est le nombre d'éléments dans la liste). Nous avons donc opté pour une structure plus efficace : le <em>tas </em>(<em>cf.</em> Section <a href="#sub_Tas">6.3.1</a>)<em>.</em></div>

<div class="standard"><a id='magicparlabel-2501' />
</div>
<h2 class="section"><span class="section_label">5.5</span> <a id='magicparlabel-2502' />
<a id="sec_Zone" />
Zone</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-2503' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-2507' />
<strong>zone</strong> : représentation d'un ensemble de positions dans un niveau.</div>
</div></strong></div>
<h3 class="subsection"><span class="subsection_label">5.5.1</span> <a id='magicparlabel-2508' />
Objectif</h3>
<div class="standard"><a id='magicparlabel-2509' />
Une <em>zone</em> a pour objectif de pouvoir représenter et manipuler rapidement n'importe quel ensemble de positions dans un niveau. Les ensembles suivants peuvent ainsi être représentés à l'aide de zones :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2510' />
Les positions des caisses.</li>
<li class="itemize_item"><a id='magicparlabel-2511' />
Les positions du pousseur dans l'état généralisé.</li>
<li class="itemize_item"><a id='magicparlabel-2512' />
Les positions des goals.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-2513' />
Dans la pratique, il existe d'autres ensembles que nous manipulerons, entre autres pour la gestion des deadlocks. Ceux-ci seront introduits en temps voulu.
<br />

</div>

<div class="standard"><a id='magicparlabel-2514' />
Les zones ne peuvent représenter que les positions qui se situent à l'intérieur d'un niveau par rapport aux murs. En d'autres mots, les positions sur lesquelles le pousseur et les caisses peuvent évoluer. La Figure <a href="#fig_Liste_des_cases">5.3</a> représente l'ensemble des positions <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>{
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo>,</mo>
   <mi>&hellip;
   </mi><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>23</mn>
    </mrow>
   </msub>}
  </mrow>
 </mrow></math>qui sont représentées par une zone sur ce niveau. Comme illustré, les positions sont numérotées ligne par ligne, en partant du coin supérieur gauche.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2518' />
<img style='width:40%;' src='assets/master_thesis/24_Users_michael_Desktop_memoire_images_zones.png' alt='image: 24_Users_michael_Desktop_memoire_images_zones.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2519' />
<div class='float-caption float-caption-figure'>Figure 5.3:<div class="plain_layout"><a id='magicparlabel-2523' />
<a id="fig_Liste_des_cases" />
Liste des positions représentées par une zone</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2524' />
Sur base de ce niveau, nous pouvons définir :</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2529' />
La zone des caisses : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>{
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>15</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>16</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>20</mn>
    </mrow>
   </msub>}
  </mrow>
 </mrow></math></li>
<li class="itemize_item"><a id='magicparlabel-2530' />
La zone du pousseur dans l'état généralisé (<em>cf.</em> Section <a href="#sec___tat">5.2</a>) :<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>{
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>12</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>13</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>16</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>17</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>20</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>21</mn>
    </mrow>
   </msub>}
  </mrow>
 </mrow></math></li>
<li class="itemize_item"><a id='magicparlabel-2531' />
La zone des goals :<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>{
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>10</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>13</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>22</mn>
    </mrow>
   </msub>}
  </mrow>
 </mrow></math></li>
</ul>
<div class="standard"><a id='magicparlabel-2532' />
Les zones permettent aux éléments du jeu de Sokoban d'être manipulées comme des ensembles à l'aide d'opérations qui comprennent l'intersection et l'inclusion.</div>
<h3 class="subsection"><span class="subsection_label">5.5.2</span> <a id='magicparlabel-2533' />
Implémentation</h3>
<div class="standard"><a id='magicparlabel-2534' />
Tout l'intérêt d'une zone est de pouvoir être représentée par un nombre binaire. Dans l'exemple de la Figure <a href="#fig_Liste_des_cases">5.3</a>, nous voyons qu'une zone est définie par 23 positions. Ces positions peuvent toutes être représentées par un bit. Le bit <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> vaudra 1 si la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>w</mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> est comprise dans l'ensemble et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mn>0</mn>
 </mrow></math> si elle ne l'est pas.
<br />

</div>

<div class="standard"><a id='magicparlabel-2535' />
En posant <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>w</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>, le nombre d'éléments dans une zone, et en admettant que la taille d'un entier soit de 32 bits, il est nécessaire d'utiliser <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>lceil</mo>
  <mrow>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow>
     <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
     </mrow>
    </mrow>
   </msub><mo>/</mo><mn>32</mn>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>rceil</mo>
 </mrow></math> entiers pour représenter chacune des zones d'un niveau. Les bits en excès pour la représentation des positions seront tous affectés à 0.
<br />

</div>

<div class="standard"><a id='magicparlabel-2536' />
Voici les représentations binaires des 3 zones décrites dans la section précédente ainsi que les valeurs entières correspondantes :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2537' />
La zone des caisses : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>00000000000000110001000</mn><mspace width="6px" /><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>000000000</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>200704</mn>
  </mrow>
 </mrow></math></li>
<li class="itemize_item"><a id='magicparlabel-2538' />
La zone du pousseur dans l'état généralisé (<em>cf.</em> Section <a href="#sec___tat">5.2</a>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>00000000000110011001100</mn><mspace width="6px" /><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>000000000</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>1677312</mn>
  </mrow>
 </mrow></math></li>
<li class="itemize_item"><a id='magicparlabel-2539' />
La zone des goals : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>00000000010010000000010</mn><mspace width="6px" /><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>000000000</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>4719616</mn>
  </mrow>
 </mrow></math></li>
</ul>
<div class="standard"><a id='magicparlabel-2540' />
Nous avons donc réduit la représentation d'un ensemble de positions à une simple valeur entière. Ceci s'avère très économique pour la consommation de mémoire car chaque état ne contiendra que deux zones (<em>cf. </em>Section <a href="#sec___tat">5.2</a>) et donc seulement 2 valeurs entières par tranche de 32 positions dans le niveau.</div>
<h3 class="subsection"><span class="subsection_label">5.5.3</span> <a id='magicparlabel-2541' />
Tables de traduction</h3>
<div class="standard"><a id='magicparlabel-2542' />
Selon notre définition des zones, il n'est pas possible d'y inclure de mur car ceux-ci ne sont pas compris dans les positions couvertes par la zone. Il va donc être nécessaire d'utiliser deux méthodes pour décrire les positions des éléments du jeu :
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-2543' />
Le <em>positionnement absolu</em> : il permet de couvrir toutes les positions d'un niveau sans exception. Chaque position est référencée par l'intersection entre une ligne (lettre) et une colonne (nombre). Cette méthode permet de situer les éléments fixes d'un niveau comme le murs ou les positions extérieures.
<br />

</li>
<li class="enumerate_item"><a id='magicparlabel-2544' />
Le<em> positionnement relatif à la zone</em> : il permet de couvrir les positions comprises dans la zone. Il sera utilisé pour situer les éléments dans une zone tels que les caisses ou les positions du pousseur. Cette méthode est essentiellement utilisée dans les interactions avec un état.
<br />

</li>
</ol>
<div class="standard"><a id='magicparlabel-2545' />
Nous avons deux méthodes différentes pour faire référence à une même position. Ceci peut poser problème lorsque l'on veut, par exemple, vérifier qu'une caisse d'un état (positionnement relatif à la zone) est située à côté d'un mur (positionnement absolu).
<br />

</div>

<div class="standard"><a id='magicparlabel-2546' />
Pour éviter ce problème, deux tables de traduction <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi><mi>r</mi><mi>a</mi>
   <msub>
    <mrow><mi>d</mi>
    </mrow>
    <mrow>
     <mrow><mi>a</mi><mo> &rarr; </mo><mi>r</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi><mi>r</mi><mi>a</mi>
   <msub>
    <mrow><mi>d</mi>
    </mrow>
    <mrow>
     <mrow><mi>r</mi><mo> &rarr; </mo><mi>a</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> sont créées. Celles-ci ont la propriété d'associer une position relative à chaque position absolue et vice versa tel qu'illustré sur la Figure <a href="#fig_traduction">5.4</a>. Dans le cas où aucune position relative ne correspond à une position absolue, la table de traduction retournera <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo>-</mo><mn>1</mn>
  </mrow>
 </mrow></math> pour bien indiquer l'impossibilité. C'est le cas de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi><mi>r</mi><mi>a</mi>
   <msub>
    <mrow><mi>d</mi>
    </mrow>
    <mrow>
     <mrow><mi>a</mi><mo> &rarr; </mo><mi>r</mi>
     </mrow>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo>
   <mrow><mi>A</mi><mn>1</mn>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo>
  </mrow>
 </mrow></math> qui retournera <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo>-</mo><mn>1</mn>
  </mrow>
 </mrow></math> pour bien montrer l'impossibilité de représenter cette position par la méthode relative.
<br />

</div>

<div class="standard"><a id='magicparlabel-2547' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2551' />
<img style='width:65%;' src='assets/master_thesis/25_Users_michael_Desktop_memoire_images_zones2.png' alt='image: 25_Users_michael_Desktop_memoire_images_zones2.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2552' />
<div class='float-caption float-caption-figure'>Figure 5.4:<div class="plain_layout"><a id='magicparlabel-2556' />
<a id="fig_traduction" />
Utilisation des tables de traduction pour convertir les positions absolues et relatives</div>
</div></div>
</div>

<h3 class="subsection"><span class="subsection_label">5.5.4</span> <a id='magicparlabel-2557' />
<a id="sub_Op__rations" />
Opérations</h3>
<div class="standard"><a id='magicparlabel-2558' />
En plus d'être peu consommatrices de mémoire, les zones permettent de réduire le nombre de calculs lors de la résolution d'un niveau. Les opérations les plus fréquentes sont détaillées dans les paragraphes suivants.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2559' />
Tester si un état est solution
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2560' />
Tester si un état est solution consiste à comparer la <em>zone des caisses</em> de l'état avec la<em> zone des goals</em> calculée une fois pour toutes à l'initialisation de la résolution. C'est-à-dire une unique comparaison entre les entiers qui représentent les deux zones ce qui, sur la Figure <a href="#fig_Liste_des_cases">5.3</a>, donne simplement <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>200704</mn><mover accent='false'><mo>=</mo><mo>?</mo></mover><mn>4719616</mn><mo> &rArr; </mo><mi>f</mi><mi>a</mi><mi>u</mi><mi>x</mi>
  </mrow>
 </mrow></math>. Dans le cas où il y a plus de goals que de caisses, il faudra utiliser l'inclusion telle que décrite plus loin dans cette section.
<br />

</div>

<div class="standard"><a id='magicparlabel-2561' />
Si nous avions enregistré individuellement les positions de chacune des caisses, nous aurions dû vérifier, pour chaque état rencontré, si elles se situent toutes sur des goals ou non.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2562' />
Trouver les poussées potentielles
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2563' />
Dans notre implémentation, la décision a été prise d'ajouter à la zone du pousseur toutes les caisses qui sont voisines aux positions que le pousseur peut atteindre. Cela ne change en rien la quantité d'informations contenues dans un état mais augmente les possibilités d'utilisation de celui-ci. En effet, cette représentation de la zone du pousseur permet de trouver, en une seule opération, toutes les caisses que le pousseur peut atteindre et donc potentiellement déplacer.
<br />

</div>

<div class="standard"><a id='magicparlabel-2564' />
Il suffit, comme la Figure <a href="#fig_ET">5.5</a> le montre, de rechercher l'intersection entre les deux zones. Concrètement, cela consiste à appliquer une opération binaire <em>ET</em> entre les représentations de la zone du pousseur et de la zone des caisses. On obtient ainsi une nouvelle zone contenant la position des caisses que le pousseur peut atteindre. On pourra ainsi travailler directement sur un sous-ensemble de caisses, ce qui diminuera la quantité de calculs nécessaires lors de la création des états fils d'un nœud de l'arbre de recherche.</div>

<div class="standard"><a id='magicparlabel-2565' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2569' />
<img style='width:85%;' src='assets/master_thesis/26_Users_michael_Desktop_memoire_images_EtatET2.png' alt='image: 26_Users_michael_Desktop_memoire_images_EtatET2.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2570' />
<div class='float-caption float-caption-figure'>Figure 5.5:<div class="plain_layout"><a id='magicparlabel-2574' />
<a id="fig_ET" />
L'intersection appliquée visuellement et en représentation binaire</div>
</div></div>
</div>

<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2575' />
Tester l'inclusion
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2576' />
Il est souvent nécessaire de tester si un état est inclus dans un autre état. Pour que <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &sube; </mo>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>A</mi>
   </mrow>
  </msub>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>B</mi>
   </mrow>
  </msub>
 </mrow></math> des états relatifs au même niveau, il faut que les deux conditions suivantes soient respectées :
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-2577' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>A</mi>
      </mrow>
      <mrow>
       <mrow><mi>z</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>C</mi><mi>a</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>s</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub><mo> &sube; </mo>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>B</mi>
      </mrow>
      <mrow>
       <mrow><mi>z</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>C</mi><mi>a</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>s</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> : toutes les positions de la zone des caisses de l'état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>A</mi>
   </mrow>
  </msub>
 </mrow></math> doivent appartenir à la zone des caisses de l'état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>B</mi>
   </mrow>
  </msub>
 </mrow></math>.
<br />

</li>
<li class="enumerate_item"><a id='magicparlabel-2578' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>A</mi>
      </mrow>
      <mrow>
       <mrow><mi>z</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>P</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>u</mi><mi>r</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub><mo> &supe; </mo>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>B</mi>
      </mrow>
      <mrow>
       <mrow><mi>z</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>P</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>u</mi><mi>r</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> : toutes les positions de la zone du pousseur de l'état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>B</mi>
   </mrow>
  </msub>
 </mrow></math> doivent appartenir à la zone du pousseur de l'état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>A</mi>
   </mrow>
  </msub>
 </mrow></math>.
<br />

</li>
</ol>
<div class="standard"><a id='magicparlabel-2579' />
Le fait que ce soit la zone du pousseur de l'état B qui doit être contenue dans celle de l'état A va à l'encontre d'une première intuition. Il faut cependant prendre en compte, comme représenté sur la Figure <a href="#fig_inclusion">5.6</a>, que moins un état possède de caisses, plus la zone du pousseur sera grande. Dans un état sans caisses, la zone du pousseur représenterait toutes les positions de celui-ci.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2583' />
<img style='width:90%;' src='assets/master_thesis/27_Users_michael_Desktop_memoire_images_inclusion_final.png' alt='image: 27_Users_michael_Desktop_memoire_images_inclusion_final.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2584' />
<div class='float-caption float-caption-figure'>Figure 5.6:<div class="plain_layout"><a id='magicparlabel-2588' />
<a id="fig_inclusion" />
Conditions à respecter pour qu'un état soit inclus dans un autre</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2589' />
À l'aide des zones, tester si <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &sube; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>A</mi>
   </mrow>
  </msub>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>B</mi>
   </mrow>
  </msub>
 </mrow></math> sont des zones d'un même niveau, est assez simple. Il suffit d'appliquer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>C</mi>
    </mrow>
   </msub><mo>=</mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &cap; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> à la manière de la Figure <a href="#fig_ET">5.5</a> et ensuite de tester la condition <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>C</mi>
    </mrow>
   </msub><mover accent='false'><mo>=</mo><mo>?</mo></mover>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>. Si la condition est vérifiée, alors <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &sube; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, sinon <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &nsube; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>. Un tel test est donc très rapide car il ne concerne que des opérations élémentaires portant sur des entiers. À chaque opération sur un entier, ce sont 32 positions qui sont testées à la fois.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2590' />
Tester l'intersection
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2591' />
Il est parfois nécessaire, entre autres pour la détection des deadlocks à une caisse (<em>cf. </em>Section <a href="#sec_Deadlocks_1caisse">8.1</a>), de tester si l'intersection entre deux zones est vide ou non.
<br />

</div>

<div class="standard"><a id='magicparlabel-2592' />
La technique est fort semblable à celle utilisée pour trouver les poussées potentielles. Il faut commencer par rechercher <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>C</mi>
    </mrow>
   </msub><mo>=</mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &cap; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>A</mi>
   </mrow>
  </msub>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>B</mi>
   </mrow>
  </msub>
 </mrow></math> sont deux zones d'un même niveau. La valeur obtenue en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>C</mi>
   </mrow>
  </msub>
 </mrow></math> est ensuite testée. Si celle-ci vaut <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mn>0</mn>
 </mrow></math> (tous les bits qui composent la zone valent <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mn>0</mn>
 </mrow></math>), alors l'intersection entre les deux zones est vide, sinon elle ne l'est pas.</div>
<h2 class="section"><span class="section_label">5.6</span> <a id='magicparlabel-2593' />
<a id="sec_Doublons" />
Doublons</h2>
<div class="standard"><a id='magicparlabel-2594' />
Lors de la création d'un arbre de recherche, il est courant de retrouver plusieurs fois le même état à des endroits différents. En effet, un même état peut être atteint via plusieurs chemins au départ de l'état racine. Étant donné qu'un état possède la même descendance, peu importe l'endroit où il se trouve dans l'arbre de recherche, ce phénomène nous conduira à des sous-arbres qui seront identiques. Si deux sous-arbres identiques apparaissent dans l'arbre de recherche de manière à ce que l'un d'eux soit compris dans la descendance de l'autre, on parlera alors de situation redondante.
<br />

</div>

<div class="standard"><a id='magicparlabel-2595' />
Ces problèmes de <em>duplications de sous-arbres</em> et de <em>situations redondantes</em> (<em>cf. </em>Figure <a href="#fig_Cas_de_duplications">5.7</a>) sont très préoccupants dans un contexte où nous essayons justement de limiter les calculs nécessaires, et donc la taille de l'arbre de recherche, pour trouver une solution.
<br />

</div>

<div class="standard"><a id='magicparlabel-2596' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2600' />
<img style='width:43%;' src='assets/master_thesis/28_Users_michael_Desktop_memoire_images_duplication.png' alt='image: 28_Users_michael_Desktop_memoire_images_duplication.png' />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img style='width:37%;' src='assets/master_thesis/29_Users_michael_Desktop_memoire_images_boucle.png' alt='image: 29_Users_michael_Desktop_memoire_images_boucle.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2601' />
<div class='float-caption float-caption-figure'>Figure 5.7:<div class="plain_layout"><a id='magicparlabel-2605' />
<a id="fig_Cas_de_duplications" />
Cas de duplication de sous-arbres (gauche) et de situation redondante (droite)</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2606' />
La technique la plus évidente pour éviter de placer deux fois un même état dans l'arbre de recherche consiste à garder en mémoire une copie de chaque état utilisé. La difficulté réside dans le fait qu'il faut utiliser une structure dans laquelle nous pouvons vérifier, à moindre coût, la présence d'un état. Les <em>tables de hachage</em> sont tout à fait appropriées pour ces fonctionnalités. De fait, avec une taille bien pensée et une fonction de hachage performante, une table de hachage permet d'insérer et de récupérer des éléments avec une complexité moyenne en <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>1</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></em>.
<br />

</div>

<div class="standard"><a id='magicparlabel-2607' />
La complexité dans le pire des cas est en <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></em>,<em> </em>où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> est le nombre d'éléments à stocker . Celle-ci est peu représentative car elle correspond à une fonction de hachage qui renverrait toujours vers la même position de la table, ce qui est le signe d'une fonction de hachage mal adaptée.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2612' />
Implémentation
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2613' />
Il peut sembler, à première vue, que garder une version de chaque état soit très consommateur de mémoire vive. De fait, garder chaque état utilisé, quand on en utilise plusieurs millions, alourdit considérablement l'espace requis. Cependant, il ne faut pas oublier que les états sont <em>déjà</em> disponibles dans l'arbre de recherche qui est en mémoire. Il est donc inutile de les dupliquer pour les insérer dans la table de hachage alors qu'une simple référence vers le nœud contenant l'état déjà en mémoire est suffisante. En procédant de la sorte, nous évitons une utilisation excessive de la mémoire ram.
<br />

</div>

<div class="standard"><a id='magicparlabel-2614' />
Le fonctionnement d'une table de hachage est très simple. Il consiste en l'utilisation d'un tableau <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>T</mi>
 </mrow></math></em> de taille <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> </em>dont toutes les cellules correspondent à des listes chaînées. Posons <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>e</mi>
 </mrow></math></em> un nouvel état et <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>x</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></em> une fonction de hachage permettant d'obtenir un nombre naturel à partir d'un état. Un nouvel état <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>e</mi>
 </mrow></math> </em>sera ajouté au début de la liste chaînée correspondant à la cellule <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo>
   <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>e</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="6px" /><mi>n</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo>
  </mrow>
 </mrow></math>. </em>Si la <em>fonction de hachage</em> et la<em> taille de la table</em> sont définies afin de répartir uniformément les états, chaque liste chaînée ne contiendra en moyenne que quelques éléments. Ceci permettra de conserver une complexité moyenne en<em> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>1</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> </em>pour l'ajout, la suppression ou la recherche d'un état<em>. </em>La Figure <a href="#fig_hashage_resume">5.8</a> schématise la manière dont les nœuds de l'arbre de recherche sont ajoutés à la table de hachage.
<em><br />

</em></div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2618' />
<img style='width:80%;' src='assets/master_thesis/30_Users_michael_Desktop_memoire_images_parcours_hashtable.png' alt='image: 30_Users_michael_Desktop_memoire_images_parcours_hashtable.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2619' />
<div class='float-caption float-caption-figure'>Figure 5.8:<div class="plain_layout"><a id='magicparlabel-2623' />
<a id="fig_hashage_resume" />
Répartition des nœuds de l'arbre de recherche dans une table de hachage</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2624' />
La <strong>fonction de hachage</strong> doit avant tout veiller à répartir uniformément les états dans la table. Elle a été implémentée de manière intuitive et son efficacité a ensuite été testée. Notre méthode consiste à additionner tous les entiers utilisés pour représenter un état (<em>cf. </em>Section <a href="#sec_Zone">5.5</a>) sur lesquels un <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>l</mi><mi>o</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></em>, où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> correspond à la taille de la table, est à chaque fois appliqué. Un dernier<em> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>l</mi><mi>o</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></em> est ensuite appliqué au total obtenu.
<br />

</div>

<div class="standard"><a id='magicparlabel-2625' />
La <strong>taille de la table</strong> de hachage doit être allouée au début de son utilisation et répondre à certaines conditions pour une utilisation performante. La première est que sa taille corresponde plus ou moins au nombre d'états que nous voulons y stocker. Nous pensons qu'un nombre proche du million représente assez bien notre intention. La deuxième condition est de &ldquo;<em>choisir un nombre premier n pas trop proche d'une puissance de 2</em>&rdquo; afin d'éviter des problèmes de diviseurs communs étant donné que nous utilisons une fonction de hachage basée sur une méthode par division. En respectant ces conditions, nous avons choisi une taille de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>n</mi><mo>=</mo><mn>870967</mn>
  </mrow>
 </mrow></math> cellules.
<br />

</div>

<div class="standard"><a id='magicparlabel-2634' />
La table de hachage a été testée de manière intensive (<em>cf.</em> Tableau <a href="#tab_hashage">5.1</a> et Figure <a href="#fig_hashage">5.9</a>) avec la création d'un arbre de recherche contenant environ 4250000 nœuds. Les résultats attendus correspondent à une moyenne de 5 éléments par liste chaînée. Les résultats obtenus sont assez concluants car 65% des listes contiennent jusqu'à 5 éléments, 90% des listes contiennent jusqu'à 10 éléments et 99% des listes possèdent 20 éléments ou moins. Sans être exceptionnels, ces résultats ne justifient pas la recherche d'une meilleure fonction de hachage.</div>

<div class="standard"><a id='magicparlabel-2635' />
</div>
<div class='float float-table'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2639' />



<table><tbody><tr><td align='center' valign='middle'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2796' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>m</mi>
 </mrow></math></div>
</td>

<td align='center' valign='middle'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2799' />
Nombre de cellules contenant <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>m</mi>
 </mrow></math> états</div>
</td>

<td align='center' valign='middle'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2802' />
Pourcentage</div>
</td>

<td align='center' valign='middle'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2805' />
Pourcentage cumulé</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2808' />
0</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2811' />
107440</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2814' />
12,34%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2817' />
12,34%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2820' />
1</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2823' />
86301</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2826' />
9,91%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2829' />
22,24%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2832' />
2</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2835' />
113746</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2838' />
13,06%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2841' />
35,30%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2844' />
3</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2847' />
87288</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2850' />
10,02%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2853' />
45,33%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2856' />
4</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2859' />
95698</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2862' />
10,99%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2865' />
56,31%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2868' />
5</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2871' />
71286</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2874' />
8,18%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2877' />
64,50%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2880' />
6</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2883' />
66372</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2886' />
7,62%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2889' />
72,12%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2892' />
7</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2895' />
48497</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2898' />
5,57%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2901' />
77,69%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2904' />
8</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2907' />
44660</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2910' />
5,13%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2913' />
82,81%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2916' />
9</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2919' />
32291</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2922' />
3,71%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2925' />
86,52%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2928' />
10</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2931' />
27286</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2934' />
3,13%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2937' />
89,65%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2940' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2943' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2946' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2949' />
..</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2952' />
15</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2955' />
6975</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2958' />
0,80%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2961' />
97,11%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2964' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2967' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2970' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2973' />
..</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2976' />
20</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2979' />
2083</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2982' />
0,24%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2985' />
99,21%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2988' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2991' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2994' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2997' />
..</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-3000' />
45</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-3003' />
8</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-3006' />
0,00%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-3009' />
100,00%</div>
</td>
</tr></tbody>
</table>
</div>

<div class="plain_layout"><a id='magicparlabel-3010' />
<div class='float-caption float-caption-table'>Tableau 5.1:<div class="plain_layout"><a id='magicparlabel-3014' />
<a id="tab_hashage" />
Pourcentage de cellules occupées par un certain nombre d'états stockés</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3015' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3019' />
<img style='width:70%;' src='assets/master_thesis/31_Users_michael_Desktop_memoire_images_hashage.png' alt='image: 31_Users_michael_Desktop_memoire_images_hashage.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3020' />
<div class='float-caption float-caption-figure'>Figure 5.9:<div class="plain_layout"><a id='magicparlabel-3024' />
<a id="fig_hashage" />
Pourcentage des cellules occupées par un nombre maximum d'états stockés</div>
</div></div>
</div>

</div>
