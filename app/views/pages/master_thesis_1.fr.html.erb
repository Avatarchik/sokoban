<% content_for :master_chapter, _("Sokoban : Recherche de solutions optimales - Préambule") %>

<div id="limited-content" class="master-thesis">

<h1 class="chapter" style="margin-top:2ex">
  <span class="chapter_label"></span> <a id='magicparlabel-2137' />
Préambule</h1>
<div class="standard"><a id='magicparlabel-2142' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-2143' />
</div>

<div class="standard"><a id='magicparlabel-2163' />
Sokoban est devenu une passion pour moi car il touche deux de mes personnalités : le joueur et le programmeur.

<br/><br/>

Jouer à Sokoban est fun et défier ses amis ajoute une couche de challenge. Mais là où ce jeu devient réellement addictif,
c'est lorsqu'il s'agit d'implémenter des stratégies de détection de deadlocks et d'élaborer des algorithmes de prédiction
de chemin le plus court. Là, le jeu prend une toute autre dimension et les règles se complexifient !

<br/><br/>

Le document retranscrit sur ce site est la version web du mémoire que j'ai rendu en 2003 pour l'obtention d'un
Master en Informatique à <a href="http://www.umons.ac.be">l'Université de Mons (UMONS)</a> en Belgique. Afin
d'éviter qu'il ne soit perdu au fond d'une bibliothèque universitaire, j'ai trouvé plus utile de le placer en
marge du jeu <a href="https://sokoban-game.com">Sokoban-Game.com</a>.

<br/><br/>

Ce document est à destination du grand public, et j'ai fait mon possible pour qu'il soit compréhensible au plus grand
nombre. J'espère que des joueurs passionnés prendront un certain plaisir à comprendre par quels moyens, plus subtils qu'il n'y parait,
un ordinateur peur réussir à détecter les solutions "optimales" de niveaux de Sokoban.

<br/><br/>

<ul>
  <li>* La version pdf du mémoire (français) : <a href="/master_thesis/sokoban_thesis_fr.pdf">sokoban_fr.pdf</a></li>
  <li>* Le code du solveur (anglais) : <a href="/master_thesis/sokoban_solver.zip">sokoban_solver.zip</a></li>
  <li>* La documentation du code (anglais) : <a href="/master_thesis/doc/html/index.html">documentation</a></li>
</ul>

<br/>

N'hésitez pas à me contacter sur mon mail : <a href="mailto:contact@sokoban-game.com">contact@sokoban-game.com</a>

<br/><br/>

Bonne lecture !

<br/><br/>

<div style="text-align:right">
Michaël Hoste
</div>

<br />




<div class='toc'><div class='tochead chapter'>Table des matières</div>

<div class='lyxtoc-1'><a href='#magicparlabel-2137' class='tocentry'>Chapitre 1 Remerciements</a> <a href='#magicparlabel-2137' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-1'><a href='#magicparlabel-2193' class='tocentry'>Chapitre 2 Introduction</a> <a href='#magicparlabel-2193' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-1'><a href='#magicparlabel-2207' class='tocentry'>Chapitre 3 Le Sokoban</a> <a href='#magicparlabel-2207' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-2214' class='tocentry'>3.1 Historique</a> <a href='#magicparlabel-2214' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-2229' class='tocentry'>3.2 Règles</a> <a href='#magicparlabel-2229' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-2308' class='tocentry'>3.3 Complexité</a> <a href='#magicparlabel-2308' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-2311' class='tocentry'>Chapitre 4 Résolution</a> <a href='#magicparlabel-2311' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-2321' class='tocentry'>4.1 Arbre de recherche</a> <a href='#magicparlabel-2321' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-2349' class='tocentry'>4.2 État de l'art</a> <a href='#magicparlabel-2349' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-2372' class='tocentry'>4.3 Contributions</a> <a href='#magicparlabel-2372' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-2408' class='tocentry'>Chapitre 5 Prérequis</a> <a href='#magicparlabel-2408' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-2416' class='tocentry'>5.1 Algorithme principal</a> <a href='#magicparlabel-2416' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-2463' class='tocentry'>5.2 État</a> <a href='#magicparlabel-2463' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-2478' class='tocentry'>5.3 Nœud</a> <a href='#magicparlabel-2478' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-2497' class='tocentry'>5.4 Liste d'attente</a> <a href='#magicparlabel-2497' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-2502' class='tocentry'>5.5 Zone</a> <a href='#magicparlabel-2502' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-2508' class='tocentry'>5.5.1 Objectif</a> <a href='#magicparlabel-2508' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-2533' class='tocentry'>5.5.2 Implémentation</a> <a href='#magicparlabel-2533' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-2541' class='tocentry'>5.5.3 Tables de traduction</a> <a href='#magicparlabel-2541' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-2557' class='tocentry'>5.5.4 Opérations</a> <a href='#magicparlabel-2557' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-2593' class='tocentry'>5.6 Doublons</a> <a href='#magicparlabel-2593' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-3034' class='tocentry'>Chapitre 6 Parcours</a> <a href='#magicparlabel-3034' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-3054' class='tocentry'>6.1 Parcours en largeur</a> <a href='#magicparlabel-3054' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-3071' class='tocentry'>6.2 Parcours en profondeur</a> <a href='#magicparlabel-3071' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-3089' class='tocentry'>6.3 Parcours informé</a> <a href='#magicparlabel-3089' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-3097' class='tocentry'>6.3.1 Tas</a> <a href='#magicparlabel-3097' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-3189' class='tocentry'>6.4 Parcours A*</a> <a href='#magicparlabel-3189' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-3197' class='tocentry'>6.4.1 Fonctionnement</a> <a href='#magicparlabel-3197' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3222' class='tocentry'>6.4.2 Implémentation</a> <a href='#magicparlabel-3222' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3304' class='tocentry'>6.4.3 Priorité de la liste d'attente</a> <a href='#magicparlabel-3304' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3311' class='tocentry'>6.4.4 Exemple </a> <a href='#magicparlabel-3311' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-3323' class='tocentry'>6.5 Parcours IDA*</a> <a href='#magicparlabel-3323' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-3329' class='tocentry'>6.5.1 Fonctionnement</a> <a href='#magicparlabel-3329' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3343' class='tocentry'>6.5.2 Avantages</a> <a href='#magicparlabel-3343' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3353' class='tocentry'>6.5.3 Inconvénients</a> <a href='#magicparlabel-3353' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3356' class='tocentry'>6.5.4 Optimisations</a> <a href='#magicparlabel-3356' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3372' class='tocentry'>6.5.5 Priorité de la liste d'attente</a> <a href='#magicparlabel-3372' class='tocarrow'>&gt;</a></div>
</div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-3375' class='tocentry'>Chapitre 7 Estimation</a> <a href='#magicparlabel-3375' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-3387' class='tocentry'>7.1 Estimation d'une caisse</a> <a href='#magicparlabel-3387' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-3392' class='tocentry'>7.1.1 Taxi-distance</a> <a href='#magicparlabel-3392' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3422' class='tocentry'>7.1.2 Distance réelle</a> <a href='#magicparlabel-3422' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3449' class='tocentry'>7.1.3 Distance réelle avec gestion du pousseur</a> <a href='#magicparlabel-3449' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-3512' class='tocentry'>7.2 Estimation totale</a> <a href='#magicparlabel-3512' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-3529' class='tocentry'>7.2.1 Goal le plus proche</a> <a href='#magicparlabel-3529' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3532' class='tocentry'>7.2.2 Goal le plus proche avec réservation</a> <a href='#magicparlabel-3532' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3554' class='tocentry'>7.2.3 Association caisses-goals minimisant l'estimation totale</a> <a href='#magicparlabel-3554' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-3568' class='tocentry'>7.3 Méthodes utilisées</a> <a href='#magicparlabel-3568' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-3592' class='tocentry'>Chapitre 8 Deadlock</a> <a href='#magicparlabel-3592' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-3607' class='tocentry'>8.1 Deadlock à une caisse</a> <a href='#magicparlabel-3607' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-3609' class='tocentry'>8.1.1 Deadlock en coin</a> <a href='#magicparlabel-3609' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3637' class='tocentry'>8.1.2 Deadlock en ligne</a> <a href='#magicparlabel-3637' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3666' class='tocentry'>8.1.3 Implémentation</a> <a href='#magicparlabel-3666' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-3678' class='tocentry'>8.2 Deadlock à plusieurs caisses</a> <a href='#magicparlabel-3678' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-3680' class='tocentry'>8.2.1 Dernière poussée</a> <a href='#magicparlabel-3680' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3717' class='tocentry'>8.2.2 Deadlock Zone</a> <a href='#magicparlabel-3717' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3768' class='tocentry'>8.2.3 Deadlock méthodique</a> <a href='#magicparlabel-3768' class='tocarrow'>&gt;</a></div>
</div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-3802' class='tocentry'>Chapitre 9 Pénalité</a> <a href='#magicparlabel-3802' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-3822' class='tocentry'>9.1 Définition</a> <a href='#magicparlabel-3822' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-3839' class='tocentry'>9.2 Recherche</a> <a href='#magicparlabel-3839' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-3844' class='tocentry'>9.2.1 Recherche passive</a> <a href='#magicparlabel-3844' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-3863' class='tocentry'>9.2.2 Recherche active</a> <a href='#magicparlabel-3863' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-3911' class='tocentry'>9.3 Validation</a> <a href='#magicparlabel-3911' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-3925' class='tocentry'>9.3.1 Sous-état pénalisé minimum</a> <a href='#magicparlabel-3925' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-3927' class='tocentry'>9.4 Application</a> <a href='#magicparlabel-3927' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-3952' class='tocentry'>Chapitre 10 Pré-traitement</a> <a href='#magicparlabel-3952' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-3968' class='tocentry'>10.1 Table des estimations</a> <a href='#magicparlabel-3968' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-3971' class='tocentry'>10.2 Pénalités</a> <a href='#magicparlabel-3971' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-3981' class='tocentry'>Chapitre 11 Post-traitement</a> <a href='#magicparlabel-3981' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-3996' class='tocentry'>11.1 Itération du parcours IDA*</a> <a href='#magicparlabel-3996' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-3999' class='tocentry'>11.2 Pénalités probables</a> <a href='#magicparlabel-3999' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-4003' class='tocentry'>11.2.1 Positions fréquentes</a> <a href='#magicparlabel-4003' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-4014' class='tocentry'>11.2.2 Sous-états probablement pénalisés</a> <a href='#magicparlabel-4014' class='tocarrow'>&gt;</a></div>
</div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-4017' class='tocentry'>Chapitre 12 Optimisations</a> <a href='#magicparlabel-4017' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-4025' class='tocentry'>12.1 Macro-poussées</a> <a href='#magicparlabel-4025' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-4048' class='tocentry'>12.2 Élagage</a> <a href='#magicparlabel-4048' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-4054' class='tocentry'>Chapitre 13 Résultats</a> <a href='#magicparlabel-4054' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-4062' class='tocentry'>13.1 Généralités</a> <a href='#magicparlabel-4062' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-4086' class='tocentry'>13.2 Tableau des résultats</a> <a href='#magicparlabel-4086' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-4122' class='tocentry'>Chapitre 14 Perspectives</a> <a href='#magicparlabel-4122' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-4130' class='tocentry'>14.1 Pénalités probables : améliorations</a> <a href='#magicparlabel-4130' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-4132' class='tocentry'>14.1.1 Détection d'ensembles de positions occupées simultanément</a> <a href='#magicparlabel-4132' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-4136' class='tocentry'>14.1.2 Détection dynamique des pénalités probables</a> <a href='#magicparlabel-4136' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-4141' class='tocentry'>14.2 Pénalités restrictives</a> <a href='#magicparlabel-4141' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-4173' class='tocentry'>14.3 Macro-Tunnels</a> <a href='#magicparlabel-4173' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-4186' class='tocentry'>Chapitre 15 Conclusion</a> <a href='#magicparlabel-4186' class='tocarrow'>&gt;</a></div>
</div>


<div class="standard"><a id='magicparlabel-2170' />
</div>

<!---


<h1 class="chapter"><span class="chapter_label">Chapitre 1</span> <a id='magicparlabel-2137' />
Remerciements</h1>
<div class="standard"><a id='magicparlabel-2142' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-2143' />
</div>

<div class="standard"><a id='magicparlabel-2163' />
Je tiens avant tout à remercier Madame Véronique Bruyère d'avoir accepté le sujet de mémoire qui me tenait à cœur et de l'avoir suivi avec enthousiasme tout au long de l'année. Merci pour les nombreux conseils et suggestions qu'elle m'a apportés, entre autres lors de la rédaction.
<br />

</div>

<div class="standard"><a id='magicparlabel-2164' />
J'exprime aussi ma reconnaissance à Monsieur Tom Mens pour m'avoir autorisé à utiliser l'un de ses ordinateurs personnels et à Sylvain Degransart pour m'avoir créé un compte sur celui-ci. Les nombreux calculs que j'ai pu y effectuer m'ont permis de progresser plus vite et de détecter mes erreurs plus rapidement.
<br />

</div>

<div class="standard"><a id='magicparlabel-2165' />
Je montre également ma gratitude à Monsieur Delgrange et à Monsieur Pirlot pour avoir accepté d'être les rapporteurs de ce mémoire.
<br />

</div>

<div class="standard"><a id='magicparlabel-2166' />
Je remercie mes parents pour les nombreuses relectures, souvent difficiles, que je leur ai infligées tout au long de la rédaction de ce mémoire.
<br />

</div>

<div class="standard"><a id='magicparlabel-2167' />
Pour finir, je tiens à apporter une reconnaissance toute particulière à mon grand-père maternel, Làszlo Fodor qui, dès ma petite enfance, a su susciter mon intérêt pour de nombreux casse-têtes. Il a été le premier à mettre un Rubik's Cube entre mes mains. Le sujet de ce mémoire ne serait peut-être pas le même sans son influence.</div>

<div class="standard"><a id='magicparlabel-2168' />
<br />
</div>

<div class="standard"><a id='magicparlabel-2169' />
</div>



<h1 class="chapter"><span class="chapter_label">Chapitre 2</span> <a id='magicparlabel-2193' />
Introduction</h1>
<div class="standard"><a id='magicparlabel-2194' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-2195' />
</div>

<div class="standard"><a id='magicparlabel-2200' />
Un problème de planification est défini par un environnement composé d'objets mouvants et d'obstacles. Dans ce type de problème, nous partons d'une configuration initiale des objets et l'objectif est d'aboutir à une configuration finale en respectant les contraintes du système.
<br />

</div>

<div class="standard"><a id='magicparlabel-2201' />
Le jeu de Sokoban, qui représente un cas typique de problème de planification, est un jeu vidéo vieux de près de 30 ans qui est réputé pour ses règles simples et sa relative difficulté. Il possède encore un certain prestige chez les joueurs et dans le milieu scientifique. Dans ce problème, un agent a pour objectif de pousser, à partir d'une configuration initiale, toutes les caisses présentes sur des goals en respectant les règles du jeu. La configuration finale sera donc celle pour laquelle toutes les caisses sont positionnées sur des goals. Le jeu possède plusieurs milliers de niveaux très variés et donc autant de configurations initiales différentes.
<br />

</div>

<div class="standard"><a id='magicparlabel-2202' />
Le but de ce mémoire est de réussir à créer un programme permettant de trouver le chemin emprunté par l'agent pour positionner, à partir d'une certaine configuration, toutes les caisses sur les goals.
<br />

</div>

<div class="standard"><a id='magicparlabel-2203' />
Le sujet du Sokoban a déjà été abordé dans de nombreuses recherches très poussées. Celles-ci n'avaient pas toutes les mêmes ambitions car certaines essayaient de trouver le plus de solutions possibles alors que d'autres privilégiaient l'obtention de solutions optimales, plus difficiles à trouver et donc moins nombreuses. Les mécanismes intrinsèques qui interviennent diffèrent selon les choix effectués.
<br />

</div>

<div class="standard"><a id='magicparlabel-2204' />
Actuellement, le meilleur programme s'appliquant sur des niveaux de Sokoban s'appelle <em>Sokoban Automatic Solver</em> et permet de résoudre 86 niveaux sur un total de 90 proposés. Les solutions trouvées ne sont cependant pas optimales et les techniques utilisées par le programme ne sont pas du tout documentées. <em>Rolling Stone</em>, un autre programme beaucoup mieux documenté, permet de résoudre 57 niveaux sur 90. Contrairement à Sokoban Automatic Solver, celui-ci trouve des solutions optimales. Ce mémoire va principalement s'inspirer des mécanismes utilisés dans ce programme.
<br />

</div>

<div class="standard"><a id='magicparlabel-2205' />
L'objectif de ce mémoire est d'utiliser les techniques existantes pour trouver les solutions optimales des niveaux de Sokoban. Celles-ci seront améliorées quand l'occasion se présentera et certaines nouvelles méthodes, plus ou moins utiles, seront également intégrées.
<br />

</div>

<div class="standard"><a id='magicparlabel-2206' />
Le développement de ce sujet se fait en plusieurs grandes parties. La première introduit certaines notions nécessaires pour bien comprendre le fonctionnement du jeu ainsi que les méthodes utilisées pour résoudre les niveaux. Le concept très important d'<em>arbre de recherche</em> y est présenté. Une deuxième grande partie concerne les différents parcours applicables sur l'arbre de recherche. Le parcours IDA*, qui se montre très performant dans notre cas, est détaillé. Les chapitres suivants traitent des estimations, deadlocks et pénalités qui sont trois méthodes permettant de réduire efficacement la taille de l'arbre de recherche. Nous terminons par le pré-traitement et le post-traitement qui permettent de rechercher des résultats intermédiaires qui s'appliqueront sur la prochaine construction de l'arbre de recherche.</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 3</span> <a id='magicparlabel-2207' />
Le Sokoban</h1>
<div class="standard"><a id='magicparlabel-2208' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-2209' />
</div>
<h2 class="section"><span class="section_label">3.1</span> <a id='magicparlabel-2214' />
Historique</h2>
<div class="standard"><a id='magicparlabel-2215' />
Sokoban, <em>gardien d'entrepôt</em> en français, est un jeu vidéo de réflexion originaire du Japon et datant du début des années 80. Selon des sources diversesSoHistory (<a href='#LyXCite-SoHistory'>Pas d'année</a>); WikiSokoban (<a href='#LyXCite-WikiSokoban'>Pas d'année</a>), il a été créé par <em>Hiroyuki Imabayashi</em> et édité par <em>Thinking Rabbit</em> qui en détient aujourd'hui tous les droits. Le jeu doit sa popularité à des règles très simples mais qui permettent néanmoins une très grande complexité. De fait, certains niveaux sont très difficiles à résoudre par l'homme et même par la machine.
<br />

</div>

<div class="standard"><a id='magicparlabel-2216' />
Il possèdait initialement une cinquantaine de niveaux mais une véritable communauté s'est créée et des milliers d'autres sont maintenant disponibles sur Internet. De même, des dizaines d'adaptations ou d'évolutions du jeu existent sur presque tous les supports et avec des graphismes plus ou moins évolués.
<br />

</div>

<div class="standard"><a id='magicparlabel-2217' />
Sokoban est un sujet particulièrement intéressant dans les domaines de la <em>complexité</em> et de l'<em>intelligence artificielle</em>. Son <em>facteur de branchement</em>, le nombre de choix possibles pour le joueur à un moment du jeu, est comparable à celui des échecs. Le nombre de décisions à prendre pour réussir à trouver une solution est relativement élevé. Un humain arrive cependant à trouver des heuristiques performantes pour un problème donné, ce qui lui permet d'arriver plus vite à une solution.</div>

<div class="standard"><a id='magicparlabel-2218' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2222' />
<img style='width:40%;' src='assets/master_thesis/0_Users_michael_Desktop_memoire_images_sokobanOriginal.jpg' alt='image: 0_Users_michael_Desktop_memoire_images_sokobanOriginal.jpg' />
 &nbsp;&nbsp;&nbsp;&nbsp;<img style='width:40%;' src='assets/master_thesis/1_Users_michael_Desktop_memoire_images_sokobanOriginal.gif' alt='image: 1_Users_michael_Desktop_memoire_images_sokobanOriginal.gif' />
</div>

<div class="plain_layout"><a id='magicparlabel-2223' />
<div class='float-caption float-caption-figure'>Figure 3.1:<div class="plain_layout"><a id='magicparlabel-2227' />
Première version de Sokoban compatible avec les PC d'IBM (1984)</div>
</div></div>

<div class="plain_layout"><a id='magicparlabel-2228' />
</div>
</div>

<h2 class="section"><span class="section_label">3.2</span> <a id='magicparlabel-2229' />
Règles</h2>
<div class="standard"><a id='magicparlabel-2230' />
La Figure <a href="#fig_Premier_niveau_du">3.2</a> correspond à la représentation d'un <em>niveau</em> de Sokoban.</div>

<div class="standard" style='text-align: center;'><a id='magicparlabel-2231' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-2235' />
<strong>niveau</strong> : position de départ de tous les éléments constituant un problème.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-2236' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2240' />
<img style='width:75%;' src='assets/master_thesis/2_Users_michael_Desktop_memoire_images_premier.png' alt='image: 2_Users_michael_Desktop_memoire_images_premier.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2241' />
<div class='float-caption float-caption-figure'>Figure 3.2:<div class="plain_layout"><a id='magicparlabel-2245' />
<a id="fig_Premier_niveau_du" />
Premier niveau de Sokoban</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2246' />
Chaque niveau est représenté sous forme d'une grille contenant les éléments suivants :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2251' />
<img style='width:3mm; height:3mm;' src='assets/master_thesis/3_Users_michael_Desktop_memoire_images_pusher.png' alt='image: 3_Users_michael_Desktop_memoire_images_pusher.png' />
 Un <em>pousseur</em>. Le gardien d'entrepôt.</li>
<li class="itemize_item"><a id='magicparlabel-2252' />
<img style='width:3mm; height:3mm;' src='assets/master_thesis/4_Users_michael_Desktop_memoire_images_wall.png' alt='image: 4_Users_michael_Desktop_memoire_images_wall.png' />
 Des <em>murs</em>.</li>
<li class="itemize_item"><a id='magicparlabel-2253' />
<img style='width:3mm; height:3mm;' src='assets/master_thesis/5_Users_michael_Desktop_memoire_images_box.png' alt='image: 5_Users_michael_Desktop_memoire_images_box.png' />
 Une ou des <em>caisses</em>.</li>
<li class="itemize_item"><a id='magicparlabel-2254' />
<img style='width:3mm; height:3mm;' src='assets/master_thesis/6_Users_michael_Desktop_memoire_images_goal.png' alt='image: 6_Users_michael_Desktop_memoire_images_goal.png' />
 Un ou des <em>goals</em> (au moins autant que de caisses).</li>
<li class="itemize_item"><a id='magicparlabel-2255' />
<img style='width:3mm; height:3mm;' src='assets/master_thesis/7_Users_michael_Desktop_memoire_images_ground.png' alt='image: 7_Users_michael_Desktop_memoire_images_ground.png' />
 Le <em>sol</em>.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-2256' />
Le joueur dirige le pousseur. Celui-ci peut se déplacer sur les quatre positions qui lui sont directement voisines : haut, bas, gauche et droite. Il peut <em>pousser</em> des caisses mais uniquement une à la fois. </div>

<div class="standard" style='text-align: center;'><a id='magicparlabel-2257' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-2261' />
<strong>poussée</strong> : déplacement d'une caisse par le pousseur.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-2262' />
Une poussée se produit si le pousseur se trouve à côté d'une caisse, s'il se dirige dans sa direction et si la position derrière la caisse n'est pas occupée par un mur ni par une autre caisse. Lorsqu'une poussée est effectuée, le pousseur et la caisse se déplacent, en même temps, d'une position.
<br />

</div>

<div class="standard"><a id='magicparlabel-2263' />
Si deux caisses voisines sont alignées sur un même axe, le pousseur ne pourra pas les pousser sur cet axe. Les murs délimitent l'aire de jeu. Ni le pousseur ni les caisses ne peuvent les franchir. Le but du jeu est de réussir à positionner toutes les caisses sur des goals. La difficulté réside dans le fait qu'il est impossible pour le pousseur de <em>tirer</em> une caisse.
<br />

</div>

<div class="standard"><a id='magicparlabel-2264' />
Si toutes les caisses se situent sur des goals, alors le niveau est réussi et le chemin utilisé par le pousseur est <em>solution</em> du niveau. Il est important de signaler que tous les niveaux doivent posséder au moins une solution.</div>

<div class="standard" style='text-align: center;'><a id='magicparlabel-2265' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-2269' />
<strong>solution</strong> : succession des déplacements du pousseur permettant de positionner toutes les caisses sur des goals. La solution d'un niveau est rarement unique.</div>

<div class="plain_layout"><a id='magicparlabel-2270' />
<strong>solution optimale en terme de mouvements</strong> : solution minimisant le nombre de déplacements du pousseur.</div>

<div class="plain_layout"><a id='magicparlabel-2271' />
<strong>solution optimale en terme de poussées</strong> : solution minimisant le nombre de<em> </em>poussées</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-2272' />
La solution optimale en terme de mouvements est souvent différente de la solution optimale en terme de poussées. Certains sites Internet comme <em>sokobano.de </em>regroupent les meilleures solutions connues (mouvements et poussées) pour pratiquement tous les niveaux existants.
<br />

</div>

<div class="standard"><a id='magicparlabel-2273' />
Dans ce document, la référence à l'une des positions de l'aire de jeu se fera toujours à l'aide du croisement entre la ligne et la colonne de la position concernée (<em>i.e.</em> la position du pousseur est <em>I12</em> sur la Figure <a href="#fig_Premier_niveau_du">3.2</a>).</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2274' />
Exemple de solution optimale
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2275' />
Etant donné le niveau représenté sur la Figure <a href="#fig_Niveau_simpliste">3.3</a>, la liste des <em>états</em> intermédiaires qui mènent à la solution optimale, en terme de mouvements et de poussées, est visible sur la Figure <a href="#fig_Niveau_simpliste_etats">3.4</a>. Il y a plusieurs façons de représenter une solution. Celle adoptée dans ce document consiste à se placer du point de vue du pousseur et d'indiquer ses directions<div class="foot"><span class="foot_label">1</span><div class="foot_inner"><div class="plain_layout"><a id='magicparlabel-2279' />
en anglais : <strong>L</strong>eft,<strong> R</strong>ight, <strong>U</strong>p, <strong>D</strong>own</div>
</div></div> successives par des lettres minuscules s'il ne pousse pas de caisse ou majuscules s'il en pousse une. Si plusieurs mouvements ont lieu dans la même direction. La lettre est préfixée par son nombre d'occurences. Dans notre exemple, la solution est <em>Ld2l2urDldR</em> et s'établit en <em>11</em> mouvements et <em>3</em> poussées.</div>

<div class="standard"><a id='magicparlabel-2280' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2284' />
<img style='width:25%;' src='assets/master_thesis/8_Users_michael_Desktop_memoire_images_solution_screenshot0023.png' alt='image: 8_Users_michael_Desktop_memoire_images_solution_screenshot0023.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2285' />
<div class='float-caption float-caption-figure'>Figure 3.3:<div class="plain_layout"><a id='magicparlabel-2289' />
<a id="fig_Niveau_simpliste" />
Niveau simpliste</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2290' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2294' />
<img style='width:13%;' src='assets/master_thesis/8_Users_michael_Desktop_memoire_images_solution_screenshot0023.png' alt='image: 8_Users_michael_Desktop_memoire_images_solution_screenshot0023.png' />
 <img style='width:13%;' src='assets/master_thesis/9_Users_michael_Desktop_memoire_images_solution_screenshot0024.png' alt='image: 9_Users_michael_Desktop_memoire_images_solution_screenshot0024.png' />
 <img style='width:13%;' src='assets/master_thesis/10_Users_michael_Desktop_memoire_images_solution_screenshot0025.png' alt='image: 10_Users_michael_Desktop_memoire_images_solution_screenshot0025.png' />
 <img style='width:13%;' src='assets/master_thesis/11_Users_michael_Desktop_memoire_images_solution_screenshot0026.png' alt='image: 11_Users_michael_Desktop_memoire_images_solution_screenshot0026.png' />
 <img style='width:13%;' src='assets/master_thesis/12_Users_michael_Desktop_memoire_images_solution_screenshot0027.png' alt='image: 12_Users_michael_Desktop_memoire_images_solution_screenshot0027.png' />
 <img style='width:13%;' src='assets/master_thesis/13_Users_michael_Desktop_memoire_images_solution_screenshot0028.png' alt='image: 13_Users_michael_Desktop_memoire_images_solution_screenshot0028.png' />
 </div>

<div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2295' />
<img style='width:13%;' src='assets/master_thesis/14_Users_michael_Desktop_memoire_images_solution_screenshot0029.png' alt='image: 14_Users_michael_Desktop_memoire_images_solution_screenshot0029.png' />
 <img style='width:13%;' src='assets/master_thesis/15_Users_michael_Desktop_memoire_images_solution_screenshot0030.png' alt='image: 15_Users_michael_Desktop_memoire_images_solution_screenshot0030.png' />
 <img style='width:13%;' src='assets/master_thesis/16_Users_michael_Desktop_memoire_images_solution_screenshot0031.png' alt='image: 16_Users_michael_Desktop_memoire_images_solution_screenshot0031.png' />
 <img style='width:13%;' src='assets/master_thesis/17_Users_michael_Desktop_memoire_images_solution_screenshot0032.png' alt='image: 17_Users_michael_Desktop_memoire_images_solution_screenshot0032.png' />
 <img style='width:13%;' src='assets/master_thesis/18_Users_michael_Desktop_memoire_images_solution_screenshot0033.png' alt='image: 18_Users_michael_Desktop_memoire_images_solution_screenshot0033.png' />
 <img style='width:13%;' src='assets/master_thesis/19_Users_michael_Desktop_memoire_images_solution_screenshot0034.png' alt='image: 19_Users_michael_Desktop_memoire_images_solution_screenshot0034.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2296' />
<div class='float-caption float-caption-figure'>Figure 3.4:<div class="plain_layout"><a id='magicparlabel-2300' />
<a id="fig_Niveau_simpliste_etats" />
Liste des états intermédiaires</div>
</div></div>
</div>


<div class="standard" style='text-align: center;'><a id='magicparlabel-2301' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-2305' />
<strong>état</strong> : position du pousseur et des caisses atteinte à partir d'un certain nombre de mouvements du pousseur dans un niveau. Contrairement à un niveau, un état n'a pas toujours de solution. On dit alors que l'état est un <em>deadlock</em>.</div>

<div class="plain_layout"><a id='magicparlabel-2306' />
<strong>état solution </strong>: état dans lequel toutes les caisses sont sur des goals.</div>

<div class="plain_layout"><a id='magicparlabel-2307' />
<strong>deadlock</strong> (impasse) : état à partir duquel il est impossible de trouver un <em>état solution</em>.</div>
</div></strong></div>
<h2 class="section"><span class="section_label">3.3</span> <a id='magicparlabel-2308' />
Complexité</h2>
<div class="standard"><a id='magicparlabel-2309' />
Il a été démontré en 1995 par <em>Dorit Dor et Uri Zwick</em>Dor et Zwick (<a href='#LyXCite-dor_sokoban'>Pas d'année</a>) que le problème de décision correspondant au Sokoban était <em>NP-difficile</em>. C'est-à-dire que Sokoban fait partie de la classe des problèmes décidables par une machine de Turing non déterministe en temps polynomial.
<br />

</div>

<div class="standard"><a id='magicparlabel-2310' />
Deux ans plus tard, en 1997, des travaux réalisés par <em>Joseph Culberson</em>Culberson (<a href='#LyXCite-culbersonculbersonsokoban'>Pas d'année</a>) ont démontré que le problème de décision était <em>PSPACE-complet</em>. Il appartient donc à la classe <em>PSPACE</em> et est <em>PSPACE-difficile</em>. C'est-à-dire qu'il est au moins aussi difficile que tous les problèmes de la classe <em>PSPACE</em> qui représente les problèmes décidables par une machine de Turing déterministe en espace polynomial par rapport à la taille de sa donnée.</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 4</span> <a id='magicparlabel-2311' />
Résolution</h1>
<div class="standard"><a id='magicparlabel-2312' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-2313' />
</div>

<div class="standard"><a id='magicparlabel-2318' />
Sokoban est un problème de type <em>Single-Agent</em>. C'est-à-dire qu'un seul <em>agent</em> peut faire évoluer le jeu en permettant le passage d'un état à un autre. Dans le Sokoban, celui-ci est le pousseur. Ce type de problème n'est pas nouveau et des méthodes existent déjà pour transiter d'un état à un autre afin d'atteindre un état solution. Ces méthodes impliquent un <em>arbre de recherche</em> comme nous le verrons dans la Section <a href="#sec_Arbre_de_recherche">4.1</a>.
<br />

</div>

<div class="standard"><a id='magicparlabel-2319' />
Les méthodes existantes sont cependant très générales et peu efficaces dans le cas du Sokoban. En effet, elles devront être adaptées aux particularités de ce problème précis sans quoi nous n'obtiendrons que peu de résultats. La Section <a href="#sec___tat_de_l_art">4.2</a> détaille comment des études menées par différentes Universités ont déjà grandement amélioré les méthodes existantes.
<br />

</div>

<div class="standard"><a id='magicparlabel-2320' />
Les méthodes Single-Agent et certaines des améliorations propres au Sokoban seront intégrées dans ce mémoire. Devant la quantité de techniques qui existent, un choix a dû être effectué pour sélectionner celles qui semblaient les plus prometteuses. De plus, certaines évolutions et alternatives seront proposées. Les décisions prises quant à ces techniques sont détaillées dans la Section <a href="#sec_Objectifs">4.3</a>.</div>
<h2 class="section"><span class="section_label">4.1</span> <a id='magicparlabel-2321' />
<a id="sec_Arbre_de_recherche" />
Arbre de recherche</h2>
<div class="standard"><a id='magicparlabel-2322' />
Comme expliqué précédemment, la méthode de base pour résoudre un problème de Sokoban est la même que pour la plupart des problèmes de type Single-Agent. Il convient de commencer par définir un état initial. Cet <em>état initial</em> reprend la position du pousseur et celles des caisses dans le niveau. À partir de cet état et en respectant les règles du jeu, nous regardons toutes les transitions possibles vers de nouveaux états. Cette procédure est répétée récursivement pour tous les états et un <em>arbre de recherche</em> est ainsi construit. Lorsqu'un état est solution, il suffit de remonter dans l'arbre pour trouver le chemin menant de la racine à la solution.
<br />

</div>

<div class="standard"><a id='magicparlabel-2323' />
Afin de limiter la taille de l'arbre de recherche, ce ne sont pas les mouvements du pousseur qui sont pris en compte mais les poussées des caisses. Les transitions entre un état et ses fils correspondent donc chaque fois à une succession de mouvements suivie d'une poussée comme indiqué sur la Figure <a href="#fig_Arbre_repr__sentant_les">4.1</a>. Cette couche d'abstraction nous permet d'arriver plus vite à un état solution mais ne nous garantit pas l'obtention de la solution optimale en terme de <em>mouvements</em>, seulement celle en terme de <em>poussées</em>.
<br />

</div>

<div class="standard"><a id='magicparlabel-2324' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2328' />
<img style='width:70%;' src='assets/master_thesis/20_Users_michael_Desktop_memoire_images_arbre_arbre.png' alt='image: 20_Users_michael_Desktop_memoire_images_arbre_arbre.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2329' />
<div class='float-caption float-caption-figure'>Figure 4.1:<div class="plain_layout"><a id='magicparlabel-2333' />
<a id="fig_Arbre_repr__sentant_les" />
Arbre représentant les poussées possibles d'un état</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2334' />
Nous avons vu qu'un état est représenté par la position du pousseur et des caisses. Les positions des murs et des goals ne sont pas stockées avec l'état car elles ne varient pas. Étant donné l'abstraction du nombre de mouvements du pousseur, nous pouvons généraliser la définition d'un état par :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2335' />
La position des caisses.</li>
<li class="itemize_item"><a id='magicparlabel-2336' />
Les positions qui peuvent être atteintes par le pousseur sans devoir pousser de caisses.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-2337' />
On parle alors d'<em>état généralisé</em>.
<br />

</div>

<div class="standard"><a id='magicparlabel-2338' />
La position exacte du pousseur importe peu. Tant qu'il reste dans un ensemble de positions atteignables sans la moindre poussée, les futures poussées possibles à partir de cet état seront les mêmes. En généralisant la position du pousseur de la sorte, nous évitons de multiplier dans notre arbre les états qui ont des descendances identiques. Nous réduisons ainsi les branches potentielles à explorer. La Figure <a href="#fig_pusherzone">4.2</a> montre bien qu'un seul état généralisé correspond simultanément à plusieurs états sans perdre d'information et donc l'optimalité de la solution.</div>

<div class="standard"><a id='magicparlabel-2339' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2343' />
<img style='width:70%;' src='assets/master_thesis/21_Users_michael_Desktop_memoire_images_arbre_pusherzone.png' alt='image: 21_Users_michael_Desktop_memoire_images_arbre_pusherzone.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2344' />
<div class='float-caption float-caption-figure'>Figure 4.2:<div class="plain_layout"><a id='magicparlabel-2348' />
<a id="fig_pusherzone" />
L'état généralisé (en haut) correspond à un ensemble de 4 états (en bas). Peu importe l'état utilisé, les descendants seront identiques.</div>
</div></div>
</div>

<h2 class="section"><span class="section_label">4.2</span> <a id='magicparlabel-2349' />
<a id="sec___tat_de_l_art" />
État de l'art</h2>
<div class="standard"><a id='magicparlabel-2350' />
Depuis l'apparition de Sokoban, celui-ci a été le sujet de nombreuses recherches qui ont conduit à la conception de <em>solveurs</em>. L'efficacité de ces solveurs est à chaque fois mise à l'épreuve sur le même ensemble de 90 niveaux. Cet ensemble regroupe les 50 niveaux de la première version de SokobanOriginalHighScore (<a href='#LyXCite-OriginalHighScore'>Pas d'année</a>) ainsi que 40 niveaux postérieursExtraHighScore (<a href='#LyXCite-ExtraHighScore'>Pas d'année</a>) dont la paternité semble appartenir à <em>Joseph L Traub</em>.
<br />

</div>

<div class="standard"><a id='magicparlabel-2351' />
Si un solveur réussit à résoudre plus de niveaux qu'un autre, cela ne signifie pas qu'il est <em>globalement</em> meilleur. En effet, notre ensemble de tests ne représente qu'une infime partie de l'ensemble des niveaux existants ou potentiels. Il constitue néanmoins une bonne base pour estimer l'efficacité d'un nouveau solveur.
<br />

</div>

<div class="standard"><a id='magicparlabel-2352' />
La suite de ce chapitre détaille les avancées des solveurs les plus prometteurs de ces dernières années. Certaines notions abordées pourront paraître obscures pour un lecteur non averti. Qu'il se rassure, elles seront détaillées dans la suite de ce document.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2353' />
Rolling Stone
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2354' />
Le solveur <em>Rolling Stone</em> est certainement celui qui est le plus documenté à ce jour. Il provient de l'Université d'Alberta, Canada. Des recherches y ont été faites entre 1997 et 2001 et il en résulte une Thèse écrite par <em>Andreas Junghanns</em>Junghanns (<a href='#LyXCite-931399'>1999</a>) et de nombreuses publications d'articles sur des méthodes testées et plus ou moins efficaces. L'utilisation d'une méthode intelligente de parcours de l'arbre de recherche (IDA*) permet d'assurer l'optimalité de la solution en terme de poussées d'un niveau. De plus, de nombreuses méthodes de détection de deadlocks et de pénalités sont utilisées et réduisent considérablement la taille de l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-2359' />
Ces techniques, associées à une quantité d'optimisations, permettent à Rolling Stone, programmé en C, d'obtenir les solutions optimales de 57 niveaux sur les 90 testés.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2360' />
Talking Stone
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2361' />
Le solveur <em>Talking Stone</em> est plus récent et date de 2006. Il a été créé par <em>François Van Lishout</em> à l'Université de Liège, Belgique, dans le cadre d'un DEA en Sciences AppliquéesVan Lishout (<a href='#LyXCite-VL06'>2006</a>). Une nouvelle approche <em>Multi-Agent</em> est utilisée dans le but de faire interagir les éléments principaux du jeu – les caisses – entre-eux avec un objectif commun. <em>F. Van Lishout</em> est parvenu à trouver un algorithme permettant de résoudre les niveaux lorsque ceux-ci appartiennent à une certaine sous-classe prédéfinie. L'idée principale est qu'un niveau appartient à cette sous-classe si on peut trouver une association caisses-goals permettant de mettre, tour à tour, chaque caisse sur son goal. Cette méthode a cependant très vite montré ses limites car un seul niveau a ainsi pu être résolu.
<br />

</div>

<div class="standard"><a id='magicparlabel-2362' />
L'évolution proposée est d'appliquer un parcours IDA* de l'arbre de recherche à la manière de Rolling Stone afin de trouver un état qui pourrait répondre aux conditions de la sous-classe. Grâce à cette amélioration, le solveur permet de résoudre 9 des 90 niveaux de base mais en utilisant très peu d'optimisations proposées par Rolling Stone. Un autre avantage est qu'il permet d'utiliser moins d'espace mémoire pour trouver une solution. Talking Stone est programmé en Scheme.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2363' />
Talking Stone (2)
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2364' />
Un autre solveur est apparu l'année suivante à Liège, toujours en Scheme et reprenant les principes de base de Talking Stone. Il a été créé par <em>Jean-Noël Demaret</em> dans le cadre de sa Deuxième LicenceDemaret (<a href='#LyXCite-DEM07'>2007</a>) et reprend l'approche Multi-Agent en l'améliorant et en insérant des optimisations propres au Sokoban. Il concrétise l'intérêt de l'approche de Talking Stone en résolvant 54 niveaux tout en laissant une légère marge de progression.
<br />

</div>

<div class="standard"><a id='magicparlabel-2365' />
Son fonctionnement consiste en l'utilisation de 3 agents :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2366' />
Le premier détermine l'ordonnancement des goals en analysant la situation de jeu initiale.</li>
<li class="itemize_item"><a id='magicparlabel-2367' />
Le deuxième a pour objectif de placer les caisses sur les goals dans l'ordre défini par l'ordonnancement.</li>
<li class="itemize_item"><a id='magicparlabel-2368' />
Le troisième est responsable de la résolution d'un sous-problème consistant à placer une caisse sur son goal.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-2369' />
Etant donné que cette façon de procéder repose sur un ordonnancement des goals qui dépend d'une certaine heuristique, les solutions trouvées seront souvent non-optimales. De quelques poussées à plusieurs dizaines de poussées supplémentaires pour résoudre certains niveaux, tel est le prix à payer pour trouver une solution. La rapidité du solveur pour en trouver une est néanmoins un atout indéniable.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2370' />
Sokoban Automatic Solver
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2371' />
Le solveur <em>Sokoban Automatic Solver</em> est certainement celui qui est le plus puissant à ce jour. Il est toujours en développement et sa première version semble dater de 2003. Malheureusement, il est non documenté et son code n'est pas disponible. Il est créé par le Japonais <em>Ken'ichiro Takahashi </em>et la version 7.2.2 de janvier 2008Takahashi (<a href='#LyXCite-AutomaticSolver'>Pas d'année</a>) permet de résoudre 86 des 90 problèmes proposés, ce qui est réellement impressionnant<em>.</em> Les solutions trouvées ne sont pas optimales ce qui laisse supposer qu'il utilise des heuristiques très précises pour réduire la taille de l'arbre de recherche.</div>
<h2 class="section"><span class="section_label">4.3</span> <a id='magicparlabel-2372' />
<a id="sec_Objectifs" />
Contributions</h2>
<div class="standard"><a id='magicparlabel-2373' />
Aborder la conception d'un solveur n'est pas une chose aisée. Le domaine est vaste et a déjà été le sujet de nombreuses recherches. Pour éviter de se contenter de ce qui a déjà été trouvé, il est important de se poser régulièrement la question &ldquo;<em>quelle fonctionnalité puis-je ajouter pour essayer d'obtenir de meilleurs résultats ? </em>&rdquo; ou &ldquo;<em>comment puis-je améliorer un aspect déjà existant</em> ?&rdquo;. De plus, un tri doit être fait parmi les méthodes existantes car toutes les implémenter laisserait peu de temps pour des innovations personnelles.
<br />

</div>

<div class="standard"><a id='magicparlabel-2374' />
Cette section présente les choix qui ont été faits dans le cadre de notre solveur ainsi que les nouvelles fonctionnalités et améliorations proposées.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2375' />
Optimalité des solutions
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2376' />
Avant même de commencer à concevoir un solveur, il convient de faire certains choix qui conditionneront les méthodes utilisées durant tout le développement. Un aspect mis en évidence par la précédente section concerne l'optimalité des solutions.
<br />

</div>

<div class="standard"><a id='magicparlabel-2377' />
Les recherches menées à l'Université d'Alberta ont toujours respecté l'optimalité des solutions en évitant de supprimer des branches de l'arbre de recherche qui pourraient éventuellement contenir la solution optimale. À l'inverse, à l'Université de Liège, l'optimalité n'était pas une contrainte et de puissantes heuristiques ont pu être utilisées pour accélérer la découverte d'une bonne solution mais qui ne sera pas nécessairement optimale.
<br />

</div>

<div class="standard"><a id='magicparlabel-2378' />
Nous avons fait le choix de respecter l'optimalité des solutions. Les techniques les plus avancées que nous utiliserons proviendront donc, principalement, de ce qui a été fait dans le cadre de Rolling Stone. Cependant, certaines techniques générales qui interviennent lors de la construction de l'arbre de recherche sont communes à toutes les recherches. C'est le cas des doublons et des deadlocks. Nous en parlerons de manière approfondie dans les chapitres suivants.
<br />

</div>

<div class="standard"><a id='magicparlabel-2379' />
Si l'optimalité des solutions a autant d'importance à nos yeux, c'est avant tout parce qu'il est plus facile de passer d'un solveur optimal à un solveur non-optimal, en ajoutant certaines heuristiques, que l'inverse. De plus, parmi les solveurs dont les recherches ont été publiées, c'est malgré tout celui qui conserve l'optimalité qui obtient le plus de solutions.
<br />

</div>

<div class="standard"><a id='magicparlabel-2380' />
Une autre raison à ne pas perdre de vue est que la mémoire vive était, il y a quelques années, une limitation qui poussait les programmeurs à réduire la taille de l'arbre de recherche. De nos jours, avec seulement 700mo de ram allouées, il est possible de travailler avec un arbre de recherche de plus de 5 millions de nœuds<div class="foot"><span class="foot_label">1</span><div class="foot_inner"><div class="plain_layout"><a id='magicparlabel-2384' />
Selon notre implémentation du solveur et avec des niveaux de tailles moyennes</div>
</div></div>. Un tel arbre devrait nous permettre de trouver les solutions optimales d'une bonne partie des niveaux de tailles et difficultés raisonnables. Bien entendu, travailler dans le cadre de solutions optimales ne signifie pas que nous ne devons pas tenter de réduire la taille de l'arbre de recherche. Les méthodes utilisées, cependant, ne supprimeront que les branches dont on peut affirmer qu'elles n'aboutiront pas à une solution optimale.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2385' />
Zone
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2386' />
Une <em>zone</em> est une technique qui consiste à représenter un ensemble de positions dans le niveau. Le concept de zone est apparu très tôt dans l'élaboration de notre solveur. Initialement prévu pour alléger l'espace de stockage de l'arbre de recherche, en utilisant des bits pour stocker les positions des caisses, il a très vite montré son efficacité dans bon nombre de situations. Il permet, entre autres, de trouver toutes les caisses que le pousseur peut déplacer dans un état en seulement quelques opérations sur des entiers. Étant donné que ces optimisations concernent les aspects les plus élémentaires d'un solveur, et donc les plus courants, elles s'avèrent très efficaces dans la pratique. Le concept de zone sera développé dans la Section <a href="#sec_Zone">5.5</a>.
<br />

</div>

<div class="standard"><a id='magicparlabel-2387' />
De plus, les zones permettent de représenter tous les ensembles de positions de la même manière et avec les mêmes outils. Ces ensembles de positions peuvent concerner les caisses, les goals, les positions du pousseur et bien d'autres situations que nous verrons plus tard. Cette façon uniforme de procéder permet une certaine abstraction qui permet de mieux cerner certains problèmes rencontrés.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2388' />
Deadlock
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2389' />
Concrètement, un deadlock est un état dont on peut affirmer, par l'une ou l'autre méthode (<em>cf.</em> Chapitre <a href="#cha_Deadlocks">8</a>), qu'il ne mènera pas à une solution. En d'autres mots, cet état est la racine d'un sous-arbre de l'arbre de recherche qu'il faut éviter de créer, au risque de faire croître inutilement la taille de l'arbre et augmenter le temps de résolution du problème.
<br />

</div>

<div class="standard"><a id='magicparlabel-2390' />
Un certain nombre de techniques efficaces ont été implémentées à partir de méthodes décrites dans la Section <a href="#sec___tat_de_l_art">4.2</a>. Nous avons ajouté à celles-ci une nouvelle méthode permettant d'étendre la notion de deadlock à celle de <em>deadlock zone</em>. Cette méthode découle d'observations effectuées lors de l'utilisation du solveur sur certains niveaux et est décrite dans la Section <a href="#sub_Deadlock_Zone">8.2.2</a>.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2391' />
Tables de coût et pénalités
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2392' />
Une des méthodes les plus efficaces pour accélérer la recherche de solutions optimales consiste à estimer le nombre de poussées restantes pour qu'un état aboutisse à un état solution. Plus l'estimation est précise et plus les chances d'arriver rapidement à une solution augmentent. Afin d'estimer au mieux cette valeur, deux outils s'offrent à nous :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2393' />
les <em>tables des coûts</em> qui définissent, pour chaque position d'un niveau, le nombre de poussées nécessaires pour pousser une caisse se trouvant sur cette position vers chacune des autres positions.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2394' />
Les <em>pénalités</em> que l'on peut assigner à certains sous-ensembles de caisses qui se gênent mutuellement pour arriver à une solution. Il faut donc infliger un coût supplémentaire, et donc une pénalité, à tous les états qui comprennent ce sous-ensemble.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-2395' />
Bien que ces outils ont déjà été utilisés dans de précédents travaux, un soin tout particulier a été apporté quant à leur implémentation. Plus les coûts et pénalités seront précis et plus le solveur sera performant. Nous avons laissé peu de place à l'approximation et nombre de cas particuliers ont été envisagés.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2396' />
Pré-traitement / Post-traitement
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2397' />
Nous définissons le <em>pré-traitement</em> par le travail effectué par le solveur sur un niveau <strong>avant</strong> de commencer à construire l'arbre de recherche. Le <em>post-traitement</em>, à l'opposé, est le travail effectué par le solveur sur un niveau <strong>après </strong>la construction de l'arbre de recherche. Ces techniques, idéalement, recherchent des résultats intermédiaires et les enregistrent dans un fichier. Ce fichier sera ensuite chargé lors de la prochaine utilisation du solveur et utilisé pour accélérer l'obtention de résultats.
<br />

</div>

<div class="standard"><a id='magicparlabel-2398' />
Dans les précédentes recherches de la Section <a href="#sec___tat_de_l_art">4.2</a>, il semble n'y avoir eu que quelques cas de pré-traitement, notamment dans le cadre de l'utilisation de <em>Deadlock Tables</em> dans Junghanns (<a href='#LyXCite-931399'>1999</a>). Peut-être étaient-ils passés sous silence mais utilisés dans la pratique. Peut-être également que l'une des contraintes était de pouvoir recalculer les informations utiles <em>à la volée</em>. Quoi qu'il en soit, nous pensons que ces techniques sont intéressantes car <em>facultatives</em> et <em>persistantes</em>. Facultatives car il est possible d'utiliser le solveur sans utiliser de pré-traitement ni de post-traitement. Persistantes car une fois un traitement effectué, il peut être chargé instantanément lors d'une prochaine utilisation du solveur et être utilisé tel quel ou complété. </div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2399' />
Langage de programmation
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2400' />
Par le passé, les principaux solveurs ont été programmés en <em>C</em> (Université d'Alberta) et en <em>Scheme</em> (Université de Liège). Le langage C possède la particularité d'être de bas niveau, proche de la machine et très rapide. Le langage Scheme, au contraire, se situe à un plus haut niveau et met l'emphase sur les avantages de la programmation fonctionnelle. Ce dernier choix est judicieux pour la construction d'arbres car très porté sur l'utilisation de listes, et celles-ci sont fréquentes dans ce domaine.
<br />

</div>

<div class="standard"><a id='magicparlabel-2401' />
Nous avons fait le choix de travailler en <em>C++</em>. Ce choix est avant tout motivé par la vitesse d'exécution de celui-ci. En effet, c'est d'un solveur dont il s'agit et la vitesse d'exécution joue donc un rôle crucial. Le C++, par rapport au C, est un rien plus lent mais comprend le paradigme objet qui est une avancée certaine en terme de facilité de programmation et de réutilisation. Le Java, qui est également orienté objet, a très vite été rejeté à cause de sa lenteur provoquée par la machine virtuelle ainsi que sa gestion aléatoire et peu flexible de la mémoire.
<br />

</div>

<div class="standard"><a id='magicparlabel-2402' />
Le seul avantage apporté par Java aurait été sa portabilité. Ce n'est pas un problème car notre implémentation en C++ a été prévue pour être compilée<div class="foot"><span class="foot_label">2</span><div class="foot_inner"><div class="plain_layout"><a id='magicparlabel-2406' />
avec le compilateur <em>G++</em> provenant de la <em>GNU Compiler Collection (GCC)</em></div>
</div></div> et fonctionner correctement sur les différentes plates-formes que sont Linux, MacOS et Windows.
<br />

</div>

<div class="standard"><a id='magicparlabel-2407' />
Un autre avantage de C++ est qu'il permet d'effectuer des opérations binaires sur les entiers. Ceci va nous aider à stocker efficacement l'arbre de recherche en utilisant le principe des zones.</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 5</span> <a id='magicparlabel-2408' />
Prérequis</h1>
<div class="standard"><a id='magicparlabel-2409' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-2410' />
</div>

<div class="standard"><a id='magicparlabel-2415' />
Pour appréhender correctement les différentes constructions possibles d'un arbre de recherche, nous devons commencer par bien assimiler certains concepts de base. Nous avons choisi une approche qui va du plus général (l'algorithme principal) au plus particulier afin de bien comprendre l'intérêt de certaines structures élémentaires qui seront utilisées tout au long de ce document.</div>
<h2 class="section"><span class="section_label">5.1</span> <a id='magicparlabel-2416' />
Algorithme principal</h2>
<div class="standard"><a id='magicparlabel-2417' />
Le fonctionnement principal du solveur est détaillé dans l'Algorithme 1. L'implémentation proposée, bien que de haut niveau et très simplifiée, présente les mécanismes les plus importants d'un tel programme. Pour pouvoir créer l'arbre de recherche, on utilise une <em>liste d'attente</em>, dont le fonctionnement sera décrit dans la Section <a href="#sec_Liste_d_attente">5.4</a>.
<br />

</div>

<div class="standard"><a id='magicparlabel-2418' />
</div>

<div class="standard"><a id='magicparlabel-2448' />
Voici quelques explications sur les fonctions utilisées :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2453' />
<em>initialisation(niveau)</em> : avant de pouvoir créer l'arbre de recherche, nous avons besoin d'initialiser plusieurs éléments dont l'état initial : celui pour lequel la disposition des caisses correspond exactement à celle du niveau. Cet état sera inséré dans la liste d'attente en tout premier lieu afin d'être introduit comme racine de l'arbre de recherche. Les autres initialisations correspondent aux structures de données qui seront utiles par la suite telles que les tables de hachage, les zones de deadlocks ou les zones de goals.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2454' />
<em>premierNoeudDeListe()</em> : Récupère le premier <em>nœud</em> (et donc un état, <em>cf</em>. Section <a href="#sub_Noeud">5.3</a>) de la liste d'attente.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2455' />
<em>estSolution(noeud)</em> : Teste si l'état contenu dans le nœud est solution en vérifiant que toutes les caisses se trouvent sur des goals.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2456' />
<em>chercheEnfants(noeud)</em> : à partir d'un nœud, retourne la liste des nœuds considérés comme enfants, c'est-à-dire à une poussée de l'état contenu dans le nœud tel que représenté sur la Figure <a href="#fig_Arbre_repr__sentant_les">4.1</a>.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2457' />
<em>dejaExistant(noeud) </em>: indique si un nœud existe déjà dans l'arbre de recherche.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2458' />
<em>deadlock(noeud)</em> : indique si l'état contenu dans le nœud est un deadlock et donc provoque une impasse dans l'arbre de recherche.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2459' />
<em>ajouteDansArbre(noeud)</em> : ajoute un nœud à sa place dans l'arbre de recherche.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2460' />
<em>ajouteDansListe(noeud)</em> : ajoute un nœud dans la liste d'attente. De l'endroit où le nœud sera ajouté dépendra la méthode de création de l'arbre de recherche.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2461' />
<em>supprime(noeud)</em> : supprime un nœud. Il ne sera conservé ni dans l'arbre de recherche, ni dans la liste d'attente ou la table de hachage.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-2462' />
<em>recupereChemin(noeud)</em> : à partir du nœud solution, permet de remonter vers la racine de l'arbre de recherche en évoluant de père en père. Cela permet de déduire, via un algorithme non-trivial, le chemin solution emprunté par le pousseur à partir de la racine.</li>
</ul>
<h2 class="section"><span class="section_label">5.2</span> <a id='magicparlabel-2463' />
<a id="sec___tat" />
État</h2>
<div class="standard"><a id='magicparlabel-2464' />
Un <em>état</em> est représenté par la position du pousseur et par celle des caisses. Grâce à la notion d'état généralisé, la position du pousseur est définie comme l'ensemble des positions que le pousseur peut atteindre dans l'état sans devoir pousser de caisses.
<br />

</div>

<div class="standard"><a id='magicparlabel-2465' />
Les différentes données contenues dans un état, qu'elles soient relatives aux caisses ou au pousseur, ne sont rien de plus que des ensembles contenant des positions. Les représentations peuvent donc être faites à l'aide d'un même outil. Cet outil, la zone, permet de gérer facilement différents ensembles de positions (<em>cf. </em>Section <a href="#sec_Zone">5.5</a>).
<br />

</div>

<div class="standard"><a id='magicparlabel-2466' />
Comme nous l'avons signalé dans la Section <a href="#sec_Arbre_de_recherche">4.1</a>, la structure d'un état ne doit pas contenir d'information relative aux positions des goals et des murs. Celles-ci sont stockées au début de la résolution d'un niveau et ne sont plus recalculées par la suite.
<br />

</div>

<div class="standard"><a id='magicparlabel-2467' />
La Figure <a href="#fig_Structure_d_un_etat">5.1</a> représente la structure d'un état tel qu'il est stocké en mémoire. Les croix représentent les positions qui sont utilisées respectivement par les caisses et par le pousseur. La zone du pousseur comprend également les caisses voisines de son champ d'action. Nous verrons dans la section <a href="#sec_Zone">5.5</a> pourquoi nous procédons de la sorte.</div>

<div class="standard"><a id='magicparlabel-2468' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2472' />
<img style='width:80%;' src='assets/master_thesis/22_Users_michael_Desktop_memoire_images_etat_etat2.png' alt='image: 22_Users_michael_Desktop_memoire_images_etat_etat2.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2473' />
<div class='float-caption float-caption-figure'>Figure 5.1:<div class="plain_layout"><a id='magicparlabel-2477' />
<a id="fig_Structure_d_un_etat" />
Structure d'un état</div>
</div></div>
</div>

<h2 class="section"><span class="section_label">5.3</span> <a id='magicparlabel-2478' />
<a id="sub_Noeud" />
Nœud</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-2479' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-2483' />
<strong>nœud</strong> : élément utilisé pour construire un arbre de recherche, il permet de situer un état par rapport à son père et à ses fils.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-2484' />
Un <em>nœud</em> est un élément qui englobe un état et qui lui permet de se greffer sur un arbre de recherche existant. Il donne à l'état la possibilité d'interagir avec les autres états présents dans l'arbre de recherche. Comme on peut le voir sur la Figure <a href="#fig_Structure_d_un_noeud">5.2</a>, le nœud contient un état ainsi que des références vers son nœud père et ses nœuds fils.
<br />

</div>

<div class="standard"><a id='magicparlabel-2485' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2489' />
<img style='width:30%;' src='assets/master_thesis/23_Users_michael_Desktop_memoire_images_noeud.png' alt='image: 23_Users_michael_Desktop_memoire_images_noeud.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2490' />
<div class='float-caption float-caption-figure'>Figure 5.2:<div class="plain_layout"><a id='magicparlabel-2494' />
<a id="fig_Structure_d_un_noeud" />
Structure d'un nœud</div>
</div></div>

<div class="plain_layout"><a id='magicparlabel-2495' />
</div>
</div>


<div class="standard"><a id='magicparlabel-2496' />
Dans la suite de ce document, le terme &ldquo;nœud&rdquo; sera utilisé pour parler d'un état lorsque la volonté sera d'insister sur sa position et ses relations au sein de l'arbre de recherche.</div>
<h2 class="section"><span class="section_label">5.4</span> <a id='magicparlabel-2497' />
<a id="sec_Liste_d_attente" />
Liste d'attente</h2>
<div class="standard"><a id='magicparlabel-2498' />
La <em>liste d'attente</em> permet de stocker les nœuds qui n'ont pas encore été traités. Un nœud traité est un nœud pour lequel nous avons trouvé et placé les enfants dans l'arbre de recherche et dans la liste d'attente si ceux-ci s'avèrent utiles. Le parcours de l'arbre de recherche dépend de la manière dont nous manipulons les nœuds en attente dans cette liste.
<br />

</div>

<div class="standard"><a id='magicparlabel-2499' />
La liste d'attente est une structure de données dans laquelle nous pouvons ajouter et retirer des éléments. La structure de données la plus simple dans le cadre de la construction d'un arbre de recherche est <em>la liste doublement chaînée</em>. Le concept d'une liste dont chaque élément est relié à son prédécesseur et à son successeur permet de gérer très facilement des structures de types <em>LIFO</em> (Last In, First Out) ou <em>FIFO</em> (First In, First Out).
<br />

</div>

<div class="standard"><a id='magicparlabel-2500' />
Dans d'autres cas de constructions plus complexes, une contrainte impose que la liste reste triée. Chaque nœud possède alors un certain coût et la liste doit conserver un ordre prédéfini. Pour cela, l'insertion doit veiller à positionner les nouveaux éléments aux endroits adéquats. Les listes doublement chaînées auraient pu fonctionner dans un tel cas mais avec une complexité qui aurait été désastreuse en cas d'insertion triée (<em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> </em>où<em> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math></em> est le nombre d'éléments dans la liste). Nous avons donc opté pour une structure plus efficace : le <em>tas </em>(<em>cf.</em> Section <a href="#sub_Tas">6.3.1</a>)<em>.</em></div>

<div class="standard"><a id='magicparlabel-2501' />
</div>
<h2 class="section"><span class="section_label">5.5</span> <a id='magicparlabel-2502' />
<a id="sec_Zone" />
Zone</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-2503' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-2507' />
<strong>zone</strong> : représentation d'un ensemble de positions dans un niveau.</div>
</div></strong></div>
<h3 class="subsection"><span class="subsection_label">5.5.1</span> <a id='magicparlabel-2508' />
Objectif</h3>
<div class="standard"><a id='magicparlabel-2509' />
Une <em>zone</em> a pour objectif de pouvoir représenter et manipuler rapidement n'importe quel ensemble de positions dans un niveau. Les ensembles suivants peuvent ainsi être représentés à l'aide de zones :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2510' />
Les positions des caisses.</li>
<li class="itemize_item"><a id='magicparlabel-2511' />
Les positions du pousseur dans l'état généralisé.</li>
<li class="itemize_item"><a id='magicparlabel-2512' />
Les positions des goals.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-2513' />
Dans la pratique, il existe d'autres ensembles que nous manipulerons, entre autres pour la gestion des deadlocks. Ceux-ci seront introduits en temps voulu.
<br />

</div>

<div class="standard"><a id='magicparlabel-2514' />
Les zones ne peuvent représenter que les positions qui se situent à l'intérieur d'un niveau par rapport aux murs. En d'autres mots, les positions sur lesquelles le pousseur et les caisses peuvent évoluer. La Figure <a href="#fig_Liste_des_cases">5.3</a> représente l'ensemble des positions <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>{
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo>,</mo>
   <mi>&hellip;
   </mi><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>23</mn>
    </mrow>
   </msub>}
  </mrow>
 </mrow></math>qui sont représentées par une zone sur ce niveau. Comme illustré, les positions sont numérotées ligne par ligne, en partant du coin supérieur gauche.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2518' />
<img style='width:40%;' src='assets/master_thesis/24_Users_michael_Desktop_memoire_images_zones.png' alt='image: 24_Users_michael_Desktop_memoire_images_zones.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2519' />
<div class='float-caption float-caption-figure'>Figure 5.3:<div class="plain_layout"><a id='magicparlabel-2523' />
<a id="fig_Liste_des_cases" />
Liste des positions représentées par une zone</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2524' />
Sur base de ce niveau, nous pouvons définir :</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2529' />
La zone des caisses : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>{
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>15</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>16</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>20</mn>
    </mrow>
   </msub>}
  </mrow>
 </mrow></math></li>
<li class="itemize_item"><a id='magicparlabel-2530' />
La zone du pousseur dans l'état généralisé (<em>cf.</em> Section <a href="#sec___tat">5.2</a>) :<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>{
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>12</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>13</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>16</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>17</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>20</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>21</mn>
    </mrow>
   </msub>}
  </mrow>
 </mrow></math></li>
<li class="itemize_item"><a id='magicparlabel-2531' />
La zone des goals :<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>{
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>10</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>13</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow><mn>22</mn>
    </mrow>
   </msub>}
  </mrow>
 </mrow></math></li>
</ul>
<div class="standard"><a id='magicparlabel-2532' />
Les zones permettent aux éléments du jeu de Sokoban d'être manipulées comme des ensembles à l'aide d'opérations qui comprennent l'intersection et l'inclusion.</div>
<h3 class="subsection"><span class="subsection_label">5.5.2</span> <a id='magicparlabel-2533' />
Implémentation</h3>
<div class="standard"><a id='magicparlabel-2534' />
Tout l'intérêt d'une zone est de pouvoir être représentée par un nombre binaire. Dans l'exemple de la Figure <a href="#fig_Liste_des_cases">5.3</a>, nous voyons qu'une zone est définie par 23 positions. Ces positions peuvent toutes être représentées par un bit. Le bit <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> vaudra 1 si la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>w</mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> est comprise dans l'ensemble et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mn>0</mn>
 </mrow></math> si elle ne l'est pas.
<br />

</div>

<div class="standard"><a id='magicparlabel-2535' />
En posant <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>w</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>, le nombre d'éléments dans une zone, et en admettant que la taille d'un entier soit de 32 bits, il est nécessaire d'utiliser <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>lceil</mo>
  <mrow>
   <msub>
    <mrow><mi>w</mi>
    </mrow>
    <mrow>
     <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
     </mrow>
    </mrow>
   </msub><mo>/</mo><mn>32</mn>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>rceil</mo>
 </mrow></math> entiers pour représenter chacune des zones d'un niveau. Les bits en excès pour la représentation des positions seront tous affectés à 0.
<br />

</div>

<div class="standard"><a id='magicparlabel-2536' />
Voici les représentations binaires des 3 zones décrites dans la section précédente ainsi que les valeurs entières correspondantes :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-2537' />
La zone des caisses : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>00000000000000110001000</mn><mspace width="6px" /><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>000000000</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>200704</mn>
  </mrow>
 </mrow></math></li>
<li class="itemize_item"><a id='magicparlabel-2538' />
La zone du pousseur dans l'état généralisé (<em>cf.</em> Section <a href="#sec___tat">5.2</a>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>00000000000110011001100</mn><mspace width="6px" /><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>000000000</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>1677312</mn>
  </mrow>
 </mrow></math></li>
<li class="itemize_item"><a id='magicparlabel-2539' />
La zone des goals : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>00000000010010000000010</mn><mspace width="6px" /><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>000000000</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>4719616</mn>
  </mrow>
 </mrow></math></li>
</ul>
<div class="standard"><a id='magicparlabel-2540' />
Nous avons donc réduit la représentation d'un ensemble de positions à une simple valeur entière. Ceci s'avère très économique pour la consommation de mémoire car chaque état ne contiendra que deux zones (<em>cf. </em>Section <a href="#sec___tat">5.2</a>) et donc seulement 2 valeurs entières par tranche de 32 positions dans le niveau.</div>
<h3 class="subsection"><span class="subsection_label">5.5.3</span> <a id='magicparlabel-2541' />
Tables de traduction</h3>
<div class="standard"><a id='magicparlabel-2542' />
Selon notre définition des zones, il n'est pas possible d'y inclure de mur car ceux-ci ne sont pas compris dans les positions couvertes par la zone. Il va donc être nécessaire d'utiliser deux méthodes pour décrire les positions des éléments du jeu :
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-2543' />
Le <em>positionnement absolu</em> : il permet de couvrir toutes les positions d'un niveau sans exception. Chaque position est référencée par l'intersection entre une ligne (lettre) et une colonne (nombre). Cette méthode permet de situer les éléments fixes d'un niveau comme le murs ou les positions extérieures.
<br />

</li>
<li class="enumerate_item"><a id='magicparlabel-2544' />
Le<em> positionnement relatif à la zone</em> : il permet de couvrir les positions comprises dans la zone. Il sera utilisé pour situer les éléments dans une zone tels que les caisses ou les positions du pousseur. Cette méthode est essentiellement utilisée dans les interactions avec un état.
<br />

</li>
</ol>
<div class="standard"><a id='magicparlabel-2545' />
Nous avons deux méthodes différentes pour faire référence à une même position. Ceci peut poser problème lorsque l'on veut, par exemple, vérifier qu'une caisse d'un état (positionnement relatif à la zone) est située à côté d'un mur (positionnement absolu).
<br />

</div>

<div class="standard"><a id='magicparlabel-2546' />
Pour éviter ce problème, deux tables de traduction <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi><mi>r</mi><mi>a</mi>
   <msub>
    <mrow><mi>d</mi>
    </mrow>
    <mrow>
     <mrow><mi>a</mi><mo> &rarr; </mo><mi>r</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi><mi>r</mi><mi>a</mi>
   <msub>
    <mrow><mi>d</mi>
    </mrow>
    <mrow>
     <mrow><mi>r</mi><mo> &rarr; </mo><mi>a</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> sont créées. Celles-ci ont la propriété d'associer une position relative à chaque position absolue et vice versa tel qu'illustré sur la Figure <a href="#fig_traduction">5.4</a>. Dans le cas où aucune position relative ne correspond à une position absolue, la table de traduction retournera <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo>-</mo><mn>1</mn>
  </mrow>
 </mrow></math> pour bien indiquer l'impossibilité. C'est le cas de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi><mi>r</mi><mi>a</mi>
   <msub>
    <mrow><mi>d</mi>
    </mrow>
    <mrow>
     <mrow><mi>a</mi><mo> &rarr; </mo><mi>r</mi>
     </mrow>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo>
   <mrow><mi>A</mi><mn>1</mn>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo>
  </mrow>
 </mrow></math> qui retournera <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo>-</mo><mn>1</mn>
  </mrow>
 </mrow></math> pour bien montrer l'impossibilité de représenter cette position par la méthode relative.
<br />

</div>

<div class="standard"><a id='magicparlabel-2547' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2551' />
<img style='width:65%;' src='assets/master_thesis/25_Users_michael_Desktop_memoire_images_zones2.png' alt='image: 25_Users_michael_Desktop_memoire_images_zones2.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2552' />
<div class='float-caption float-caption-figure'>Figure 5.4:<div class="plain_layout"><a id='magicparlabel-2556' />
<a id="fig_traduction" />
Utilisation des tables de traduction pour convertir les positions absolues et relatives</div>
</div></div>
</div>

<h3 class="subsection"><span class="subsection_label">5.5.4</span> <a id='magicparlabel-2557' />
<a id="sub_Op__rations" />
Opérations</h3>
<div class="standard"><a id='magicparlabel-2558' />
En plus d'être peu consommatrices de mémoire, les zones permettent de réduire le nombre de calculs lors de la résolution d'un niveau. Les opérations les plus fréquentes sont détaillées dans les paragraphes suivants.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2559' />
Tester si un état est solution
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2560' />
Tester si un état est solution consiste à comparer la <em>zone des caisses</em> de l'état avec la<em> zone des goals</em> calculée une fois pour toutes à l'initialisation de la résolution. C'est-à-dire une unique comparaison entre les entiers qui représentent les deux zones ce qui, sur la Figure <a href="#fig_Liste_des_cases">5.3</a>, donne simplement <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>200704</mn><mover accent='false'><mo>=</mo><mo>?</mo></mover><mn>4719616</mn><mo> &rArr; </mo><mi>f</mi><mi>a</mi><mi>u</mi><mi>x</mi>
  </mrow>
 </mrow></math>. Dans le cas où il y a plus de goals que de caisses, il faudra utiliser l'inclusion telle que décrite plus loin dans cette section.
<br />

</div>

<div class="standard"><a id='magicparlabel-2561' />
Si nous avions enregistré individuellement les positions de chacune des caisses, nous aurions dû vérifier, pour chaque état rencontré, si elles se situent toutes sur des goals ou non.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2562' />
Trouver les poussées potentielles
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2563' />
Dans notre implémentation, la décision a été prise d'ajouter à la zone du pousseur toutes les caisses qui sont voisines aux positions que le pousseur peut atteindre. Cela ne change en rien la quantité d'informations contenues dans un état mais augmente les possibilités d'utilisation de celui-ci. En effet, cette représentation de la zone du pousseur permet de trouver, en une seule opération, toutes les caisses que le pousseur peut atteindre et donc potentiellement déplacer.
<br />

</div>

<div class="standard"><a id='magicparlabel-2564' />
Il suffit, comme la Figure <a href="#fig_ET">5.5</a> le montre, de rechercher l'intersection entre les deux zones. Concrètement, cela consiste à appliquer une opération binaire <em>ET</em> entre les représentations de la zone du pousseur et de la zone des caisses. On obtient ainsi une nouvelle zone contenant la position des caisses que le pousseur peut atteindre. On pourra ainsi travailler directement sur un sous-ensemble de caisses, ce qui diminuera la quantité de calculs nécessaires lors de la création des états fils d'un nœud de l'arbre de recherche.</div>

<div class="standard"><a id='magicparlabel-2565' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2569' />
<img style='width:85%;' src='assets/master_thesis/26_Users_michael_Desktop_memoire_images_EtatET2.png' alt='image: 26_Users_michael_Desktop_memoire_images_EtatET2.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2570' />
<div class='float-caption float-caption-figure'>Figure 5.5:<div class="plain_layout"><a id='magicparlabel-2574' />
<a id="fig_ET" />
L'intersection appliquée visuellement et en représentation binaire</div>
</div></div>
</div>

<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2575' />
Tester l'inclusion
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2576' />
Il est souvent nécessaire de tester si un état est inclus dans un autre état. Pour que <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &sube; </mo>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>A</mi>
   </mrow>
  </msub>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>B</mi>
   </mrow>
  </msub>
 </mrow></math> des états relatifs au même niveau, il faut que les deux conditions suivantes soient respectées :
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-2577' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>A</mi>
      </mrow>
      <mrow>
       <mrow><mi>z</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>C</mi><mi>a</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>s</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub><mo> &sube; </mo>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>B</mi>
      </mrow>
      <mrow>
       <mrow><mi>z</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>C</mi><mi>a</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>s</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> : toutes les positions de la zone des caisses de l'état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>A</mi>
   </mrow>
  </msub>
 </mrow></math> doivent appartenir à la zone des caisses de l'état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>B</mi>
   </mrow>
  </msub>
 </mrow></math>.
<br />

</li>
<li class="enumerate_item"><a id='magicparlabel-2578' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>A</mi>
      </mrow>
      <mrow>
       <mrow><mi>z</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>P</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>u</mi><mi>r</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub><mo> &supe; </mo>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>B</mi>
      </mrow>
      <mrow>
       <mrow><mi>z</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>P</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>u</mi><mi>r</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> : toutes les positions de la zone du pousseur de l'état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>B</mi>
   </mrow>
  </msub>
 </mrow></math> doivent appartenir à la zone du pousseur de l'état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow><mi>A</mi>
   </mrow>
  </msub>
 </mrow></math>.
<br />

</li>
</ol>
<div class="standard"><a id='magicparlabel-2579' />
Le fait que ce soit la zone du pousseur de l'état B qui doit être contenue dans celle de l'état A va à l'encontre d'une première intuition. Il faut cependant prendre en compte, comme représenté sur la Figure <a href="#fig_inclusion">5.6</a>, que moins un état possède de caisses, plus la zone du pousseur sera grande. Dans un état sans caisses, la zone du pousseur représenterait toutes les positions de celui-ci.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2583' />
<img style='width:90%;' src='assets/master_thesis/27_Users_michael_Desktop_memoire_images_inclusion_final.png' alt='image: 27_Users_michael_Desktop_memoire_images_inclusion_final.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2584' />
<div class='float-caption float-caption-figure'>Figure 5.6:<div class="plain_layout"><a id='magicparlabel-2588' />
<a id="fig_inclusion" />
Conditions à respecter pour qu'un état soit inclus dans un autre</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2589' />
À l'aide des zones, tester si <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &sube; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>A</mi>
   </mrow>
  </msub>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>B</mi>
   </mrow>
  </msub>
 </mrow></math> sont des zones d'un même niveau, est assez simple. Il suffit d'appliquer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>C</mi>
    </mrow>
   </msub><mo>=</mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &cap; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> à la manière de la Figure <a href="#fig_ET">5.5</a> et ensuite de tester la condition <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>C</mi>
    </mrow>
   </msub><mover accent='false'><mo>=</mo><mo>?</mo></mover>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>. Si la condition est vérifiée, alors <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &sube; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, sinon <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &nsube; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>. Un tel test est donc très rapide car il ne concerne que des opérations élémentaires portant sur des entiers. À chaque opération sur un entier, ce sont 32 positions qui sont testées à la fois.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2590' />
Tester l'intersection
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2591' />
Il est parfois nécessaire, entre autres pour la détection des deadlocks à une caisse (<em>cf. </em>Section <a href="#sec_Deadlocks_1caisse">8.1</a>), de tester si l'intersection entre deux zones est vide ou non.
<br />

</div>

<div class="standard"><a id='magicparlabel-2592' />
La technique est fort semblable à celle utilisée pour trouver les poussées potentielles. Il faut commencer par rechercher <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>C</mi>
    </mrow>
   </msub><mo>=</mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>A</mi>
    </mrow>
   </msub><mo> &cap; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow><mi>B</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>A</mi>
   </mrow>
  </msub>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>B</mi>
   </mrow>
  </msub>
 </mrow></math> sont deux zones d'un même niveau. La valeur obtenue en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow><mi>C</mi>
   </mrow>
  </msub>
 </mrow></math> est ensuite testée. Si celle-ci vaut <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mn>0</mn>
 </mrow></math> (tous les bits qui composent la zone valent <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mn>0</mn>
 </mrow></math>), alors l'intersection entre les deux zones est vide, sinon elle ne l'est pas.</div>
<h2 class="section"><span class="section_label">5.6</span> <a id='magicparlabel-2593' />
<a id="sec_Doublons" />
Doublons</h2>
<div class="standard"><a id='magicparlabel-2594' />
Lors de la création d'un arbre de recherche, il est courant de retrouver plusieurs fois le même état à des endroits différents. En effet, un même état peut être atteint via plusieurs chemins au départ de l'état racine. Étant donné qu'un état possède la même descendance, peu importe l'endroit où il se trouve dans l'arbre de recherche, ce phénomène nous conduira à des sous-arbres qui seront identiques. Si deux sous-arbres identiques apparaissent dans l'arbre de recherche de manière à ce que l'un d'eux soit compris dans la descendance de l'autre, on parlera alors de situation redondante.
<br />

</div>

<div class="standard"><a id='magicparlabel-2595' />
Ces problèmes de <em>duplications de sous-arbres</em> et de <em>situations redondantes</em> (<em>cf. </em>Figure <a href="#fig_Cas_de_duplications">5.7</a>) sont très préoccupants dans un contexte où nous essayons justement de limiter les calculs nécessaires, et donc la taille de l'arbre de recherche, pour trouver une solution.
<br />

</div>

<div class="standard"><a id='magicparlabel-2596' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2600' />
<img style='width:43%;' src='assets/master_thesis/28_Users_michael_Desktop_memoire_images_duplication.png' alt='image: 28_Users_michael_Desktop_memoire_images_duplication.png' />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img style='width:37%;' src='assets/master_thesis/29_Users_michael_Desktop_memoire_images_boucle.png' alt='image: 29_Users_michael_Desktop_memoire_images_boucle.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2601' />
<div class='float-caption float-caption-figure'>Figure 5.7:<div class="plain_layout"><a id='magicparlabel-2605' />
<a id="fig_Cas_de_duplications" />
Cas de duplication de sous-arbres (gauche) et de situation redondante (droite)</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2606' />
La technique la plus évidente pour éviter de placer deux fois un même état dans l'arbre de recherche consiste à garder en mémoire une copie de chaque état utilisé. La difficulté réside dans le fait qu'il faut utiliser une structure dans laquelle nous pouvons vérifier, à moindre coût, la présence d'un état. Les <em>tables de hachage</em> sont tout à fait appropriées pour ces fonctionnalités. De fait, avec une taille bien pensée et une fonction de hachage performante, une table de hachage permet d'insérer et de récupérer des éléments avec une complexité moyenne en <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>1</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></em>.
<br />

</div>

<div class="standard"><a id='magicparlabel-2607' />
La complexité dans le pire des cas est en <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></em>,<em> </em>où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> est le nombre d'éléments à stocker . Celle-ci est peu représentative car elle correspond à une fonction de hachage qui renverrait toujours vers la même position de la table, ce qui est le signe d'une fonction de hachage mal adaptée.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-2612' />
Implémentation
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-2613' />
Il peut sembler, à première vue, que garder une version de chaque état soit très consommateur de mémoire vive. De fait, garder chaque état utilisé, quand on en utilise plusieurs millions, alourdit considérablement l'espace requis. Cependant, il ne faut pas oublier que les états sont <em>déjà</em> disponibles dans l'arbre de recherche qui est en mémoire. Il est donc inutile de les dupliquer pour les insérer dans la table de hachage alors qu'une simple référence vers le nœud contenant l'état déjà en mémoire est suffisante. En procédant de la sorte, nous évitons une utilisation excessive de la mémoire ram.
<br />

</div>

<div class="standard"><a id='magicparlabel-2614' />
Le fonctionnement d'une table de hachage est très simple. Il consiste en l'utilisation d'un tableau <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>T</mi>
 </mrow></math></em> de taille <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> </em>dont toutes les cellules correspondent à des listes chaînées. Posons <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>e</mi>
 </mrow></math></em> un nouvel état et <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>x</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></em> une fonction de hachage permettant d'obtenir un nombre naturel à partir d'un état. Un nouvel état <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>e</mi>
 </mrow></math> </em>sera ajouté au début de la liste chaînée correspondant à la cellule <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo>
   <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>e</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="6px" /><mi>n</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo>
  </mrow>
 </mrow></math>. </em>Si la <em>fonction de hachage</em> et la<em> taille de la table</em> sont définies afin de répartir uniformément les états, chaque liste chaînée ne contiendra en moyenne que quelques éléments. Ceci permettra de conserver une complexité moyenne en<em> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>1</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> </em>pour l'ajout, la suppression ou la recherche d'un état<em>. </em>La Figure <a href="#fig_hashage_resume">5.8</a> schématise la manière dont les nœuds de l'arbre de recherche sont ajoutés à la table de hachage.
<em><br />

</em></div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2618' />
<img style='width:80%;' src='assets/master_thesis/30_Users_michael_Desktop_memoire_images_parcours_hashtable.png' alt='image: 30_Users_michael_Desktop_memoire_images_parcours_hashtable.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-2619' />
<div class='float-caption float-caption-figure'>Figure 5.8:<div class="plain_layout"><a id='magicparlabel-2623' />
<a id="fig_hashage_resume" />
Répartition des nœuds de l'arbre de recherche dans une table de hachage</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-2624' />
La <strong>fonction de hachage</strong> doit avant tout veiller à répartir uniformément les états dans la table. Elle a été implémentée de manière intuitive et son efficacité a ensuite été testée. Notre méthode consiste à additionner tous les entiers utilisés pour représenter un état (<em>cf. </em>Section <a href="#sec_Zone">5.5</a>) sur lesquels un <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>l</mi><mi>o</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></em>, où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> correspond à la taille de la table, est à chaque fois appliqué. Un dernier<em> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>l</mi><mi>o</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></em> est ensuite appliqué au total obtenu.
<br />

</div>

<div class="standard"><a id='magicparlabel-2625' />
La <strong>taille de la table</strong> de hachage doit être allouée au début de son utilisation et répondre à certaines conditions pour une utilisation performante. La première est que sa taille corresponde plus ou moins au nombre d'états que nous voulons y stocker. Nous pensons qu'un nombre proche du million représente assez bien notre intention. La deuxième condition est de &ldquo;<em>choisir un nombre premier n pas trop proche d'une puissance de 2</em>&rdquo; afin d'éviter des problèmes de diviseurs communs étant donné que nous utilisons une fonction de hachage basée sur une méthode par division. En respectant ces conditions, nous avons choisi une taille de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>n</mi><mo>=</mo><mn>870967</mn>
  </mrow>
 </mrow></math> cellules.
<br />

</div>

<div class="standard"><a id='magicparlabel-2634' />
La table de hachage a été testée de manière intensive (<em>cf.</em> Tableau <a href="#tab_hashage">5.1</a> et Figure <a href="#fig_hashage">5.9</a>) avec la création d'un arbre de recherche contenant environ 4250000 nœuds. Les résultats attendus correspondent à une moyenne de 5 éléments par liste chaînée. Les résultats obtenus sont assez concluants car 65% des listes contiennent jusqu'à 5 éléments, 90% des listes contiennent jusqu'à 10 éléments et 99% des listes possèdent 20 éléments ou moins. Sans être exceptionnels, ces résultats ne justifient pas la recherche d'une meilleure fonction de hachage.</div>

<div class="standard"><a id='magicparlabel-2635' />
</div>
<div class='float float-table'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2639' />



<table><tbody><tr><td align='center' valign='middle'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2796' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>m</mi>
 </mrow></math></div>
</td>

<td align='center' valign='middle'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2799' />
Nombre de cellules contenant <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>m</mi>
 </mrow></math> états</div>
</td>

<td align='center' valign='middle'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2802' />
Pourcentage</div>
</td>

<td align='center' valign='middle'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-2805' />
Pourcentage cumulé</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2808' />
0</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2811' />
107440</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2814' />
12,34%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2817' />
12,34%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2820' />
1</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2823' />
86301</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2826' />
9,91%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2829' />
22,24%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2832' />
2</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2835' />
113746</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2838' />
13,06%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2841' />
35,30%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2844' />
3</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2847' />
87288</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2850' />
10,02%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2853' />
45,33%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2856' />
4</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2859' />
95698</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2862' />
10,99%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2865' />
56,31%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2868' />
5</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2871' />
71286</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2874' />
8,18%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2877' />
64,50%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2880' />
6</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2883' />
66372</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2886' />
7,62%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2889' />
72,12%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2892' />
7</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2895' />
48497</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2898' />
5,57%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2901' />
77,69%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2904' />
8</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2907' />
44660</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2910' />
5,13%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2913' />
82,81%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2916' />
9</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2919' />
32291</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2922' />
3,71%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2925' />
86,52%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2928' />
10</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2931' />
27286</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2934' />
3,13%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2937' />
89,65%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2940' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2943' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2946' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2949' />
..</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2952' />
15</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2955' />
6975</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2958' />
0,80%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2961' />
97,11%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2964' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2967' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2970' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2973' />
..</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2976' />
20</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2979' />
2083</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2982' />
0,24%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2985' />
99,21%</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2988' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2991' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2994' />
..</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-2997' />
..</div>
</td>
</tr>
<tr><td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-3000' />
45</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-3003' />
8</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-3006' />
0,00%</div>
</td>

<td align='center' valign='middle'><div class="plain_layout"><a id='magicparlabel-3009' />
100,00%</div>
</td>
</tr></tbody>
</table>
</div>

<div class="plain_layout"><a id='magicparlabel-3010' />
<div class='float-caption float-caption-table'>Tableau 5.1:<div class="plain_layout"><a id='magicparlabel-3014' />
<a id="tab_hashage" />
Pourcentage de cellules occupées par un certain nombre d'états stockés</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3015' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3019' />
<img style='width:70%;' src='assets/master_thesis/31_Users_michael_Desktop_memoire_images_hashage.png' alt='image: 31_Users_michael_Desktop_memoire_images_hashage.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3020' />
<div class='float-caption float-caption-figure'>Figure 5.9:<div class="plain_layout"><a id='magicparlabel-3024' />
<a id="fig_hashage" />
Pourcentage des cellules occupées par un nombre maximum d'états stockés</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3025' />
</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 6</span> <a id='magicparlabel-3034' />
Parcours</h1>
<div class="standard"><a id='magicparlabel-3035' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-3036' />
</div>

<div class="standard"><a id='magicparlabel-3041' />
Nous avons vu dans la Section <a href="#sec_Arbre_de_recherche">4.1</a> que la résolution d'un problème de Sokoban nécessitait la construction d'un arbre de recherche. Le moment est venu de décrire les différentes façons de construire cet arbre. Chacune des méthodes proposées possède ses avantages et inconvénients et diffère essentiellement des autres par l'ordre dans lequel les nœuds dans la liste d'attente seront placés dans l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3042' />
Pour illustrer ces différents parcours, nous allons utiliser l'arbre de recherche de la Figure <a href="#fig_arbre_general">6.1</a>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3043' />
Dans les exemples qui vont suivre, nous allons utiliser différents algorithmes pour parcourir l'arbre de recherche illustré. Il faut cependant noter que, dans le cadre de notre solveur, nous ne parcourons pas un arbre de recherche qui existe déjà. Dans les faits, nous parcourons un arbre créé dynamiquement selon des règles prédéfinies : création des états fils, détection des deadlocks, des doublons, &hellip; Les idées principales restent néanmoins les mêmes dans les deux cas.</div>

<div class="standard"><a id='magicparlabel-3044' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3048' />
<img style='width:85%;' src='assets/master_thesis/32_Users_michael_Desktop_memoire_images_parcours_arbre_complet.png' alt='image: 32_Users_michael_Desktop_memoire_images_parcours_arbre_complet.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3049' />
<div class='float-caption float-caption-figure'>Figure 6.1:<div class="plain_layout"><a id='magicparlabel-3053' />
<a id="fig_arbre_general" />
Arbre que nous allons parcourir à l'aide d'algorithmes différents</div>
</div></div>
</div>

<h2 class="section"><span class="section_label">6.1</span> <a id='magicparlabel-3054' />
<a id="sec_Parcours_en_largeur" />
Parcours en largeur</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3055' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3059' />
<strong>parcours en largeur</strong> : <em>Breadth-First Search (BFS)</em> en anglais, traite en priorité les nœuds voisins situés sur un même niveau de l'arbre de recherche. Quand un certain niveau est terminé, il descend au niveau suivant et continue de procéder de cette manière.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3060' />
Le <em>parcours en largeur </em>utilise une liste d'attente <em>FIFO</em> (First In, First Out), c'est-à-dire une file, pour traiter les nœuds en attente. De cette façon, les nœuds arrivés en premier dans la liste d'attente seront placés en priorité dans l'arbre de recherche. Étant donné que l'Algorithme 1 utilise toujours le premier nœud de la liste pour le placer dans l'arbre de recherche, la fonction <em>ajouteDansListe(noeud)</em> va insérer chaque nouveau nœud <strong>à la fin</strong> de la liste chaînée tel qu'illustré sur la Figure <a href="#fig_parcours_largeur">6.2</a>.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3064' />
<img style='width:50%;' src='assets/master_thesis/33_Users_michael_Desktop_memoire_images_parcours_largeur.png' alt='image: 33_Users_michael_Desktop_memoire_images_parcours_largeur.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3065' />
<div class='float-caption float-caption-figure'>Figure 6.2:<div class="plain_layout"><a id='magicparlabel-3069' />
<a id="fig_parcours_largeur" />
Parcours en largeur</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3070' />
Le parcours en largeur explore en priorité les nœuds les plus hauts de l'arbre de recherche. Du fait que dans notre solveur, chaque saut d'un nœud à un autre corresponde à une seule poussée, nous pouvons en déduire que l'optimalité en terme de poussées de la solution sera atteinte. Sur la Figure <a href="#fig_arbre_general">6.1</a>, nous pouvons voir deux nœuds qui contiennent des états solutions. L'une des deux solutions est optimale avec 2 poussées (nœud 8) et l'autre ne l'est pas avec 3 poussées (nœud 12). Avec le parcours en largeur, la solution qui sera trouvée la première sera bien celle qui est optimale.</div>
<h2 class="section"><span class="section_label">6.2</span> <a id='magicparlabel-3071' />
Parcours en profondeur</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3072' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3076' />
<strong>parcours en profondeur</strong> : <em>Depth-First Search (DFS)</em> en anglais, traite en priorité les nœuds situés en profondeur dans l'arbre de recherche.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3077' />
Le <em>parcours en profondeur</em> utilise une liste d'attente <em>LIFO</em> (Last In, First Out), c'est-à-dire une pile, pour traiter les nœuds en attente. De cette façon, les nœuds arrivés en dernier dans la liste d'attente seront placés en priorité dans l'arbre de recherche, privilégiant ainsi les nœuds plus profonds. Étant donné que l'Algorithme 1 utilise toujours le premier nœud de la liste pour le placer dans l'arbre de recherche, la fonction <em>ajouteDansListe(noeud)</em> va insérer chaque nouveau nœud <strong>au début</strong> de la liste chaînée tel qu'illustré sur la Figure <a href="#fig_parcours_profondeur">6.3</a>.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3081' />
<img style='width:35%;' src='assets/master_thesis/34_Users_michael_Desktop_memoire_images_parcours_longueur.png' alt='image: 34_Users_michael_Desktop_memoire_images_parcours_longueur.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3082' />
<div class='float-caption float-caption-figure'>Figure 6.3:<div class="plain_layout"><a id='magicparlabel-3086' />
<a id="fig_parcours_profondeur" />
Parcours en profondeur</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3087' />
Le parcours en profondeur explore en priorité les nœuds les plus profonds de l'arbre de recherche. Certains nœuds situés au niveau <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>p</mi>
 </mrow></math> seront ainsi explorés avant que tous les nœuds situés au niveau <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>p</mi><mo>-</mo><mn>1</mn>
  </mrow>
 </mrow></math> ne le soient. Une solution non-optimale pourrait donc être trouvée avant la solution optimale. Une telle situation est illustrée avec la Figure <a href="#fig_arbre_general">6.1</a>. Si un parcours en profondeur était appliqué sur l'arbre de recherche, le premier nœud solution trouvé serait le 12. Le problème est qu'un autre nœud non exploré, le 8, contient une meilleure solution.
<br />

</div>

<div class="standard"><a id='magicparlabel-3088' />
Le parcours en profondeur, contrairement à celui en largeur, ne trouve donc pas la solution optimale sauf si on le laisse explorer tout l'arbre. Il a néanmoins l'avantage de souvent trouver plus vite une bonne solution à un problème de Sokoban. Les solutions ont plus de chance de se trouver dans les nœuds les plus profonds de l'arbre.</div>
<h2 class="section"><span class="section_label">6.3</span> <a id='magicparlabel-3089' />
Parcours informé</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3090' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3094' />
<strong>parcours informé</strong> : <em>Best-First Search </em>en anglais, a pour principe d'assigner un coût à chaque nœud de l'arbre de recherche. Ce coût correspond à la priorité du nœud pour son insertion dans l'arbre.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3095' />
Le coût peut être basé sur des propriétés de l'état en lui-même ou sur sa position au sein de l'arbre de recherche. La liste d'attente sera triée en fonction de ces coûts, par exemple en positionnant les nœuds dont les coûts sont les plus faibles en tête de liste. Lorsqu'un nouveau nœud est traité, il n'est pas systématiquement inséré en tête ou fin de liste comme c'était le cas auparavant mais à l'endroit exact de la liste qui correspond à son coût. Le parcours de l'arbre de recherche sera alors défini par l'heuristique utilisée pour définir le coût d'un nœud.
<br />

</div>

<div class="standard"><a id='magicparlabel-3096' />
L'intérêt d'une telle méthode est que, si les heuristiques sont assez puissantes, il sera possible de construire un arbre de recherche en traitant en priorité les nœuds les plus susceptibles de mener à une solution. Les autres nœuds, moins utiles, seront rejetés en fin de liste. Son plus grand inconvénient est que les heuristiques pourraient éventuellement rejeter une solution, optimale ou non, en estimant à tort que l'état analysé n'est pas digne d'intérêt.</div>
<h3 class="subsection"><span class="subsection_label">6.3.1</span> <a id='magicparlabel-3097' />
<a id="sub_Tas" />
Tas</h3>
<div class="standard"><a id='magicparlabel-3098' />
Si un parcours informé est utilisé en lieu et place d'un parcours en largeur ou en profondeur, il devient nécessaire de changer la structure de la liste d'attente. En effet, une liste doublement chaînée montre ses limites dès que l'insertion triée devient indispensable. Avec une liste chaînée, il n'y a pas d'alternative possible au parcours de toute la liste pour trouver l'emplacement exact où insérer le nouveau nœud, ce qui implique une complexité en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3099' />
Le <em>tas</em> semble être une bonne alternative à la liste chaînée. Celui-ci permet une opération d'insertion triée plus souple que celle utilisable dans le cadre d'une liste. Le fonctionnement et l'implémentation proposés d'un tas proviennent de <em>Introduction to Algorithms</em> .</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3104' />
Fonctionnement</h4>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3105' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3109' />
<strong>tas </strong>: structure de données contenant des éléments triés dans un arbre binaire. Le tas possède la possibilité d'ajouter une donnée, de retirer la donnée minimale et de repositionner une donnée dans l'arbre binaire en fonction de son coût.</div>
</div></strong>
<br />

</div>

<div class="standard"><a id='magicparlabel-3110' />
Le tas est représenté sous la forme d'un <em>arbre binaire</em>. Il faut différencier l'arbre binaire utilisé pour le tas de l'arbre de recherche qui sert de transition entre les états, ce sont deux arbres dont les rôles sont bien distincts.
<br />

</div>

<div class="standard"><a id='magicparlabel-3111' />
Si l'arbre binaire contient <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>p</mi>
 </mrow></math> niveaux, alors celui-ci doit être complet sur ses <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>p</mi><mo>-</mo><mn>1</mn>
  </mrow>
 </mrow></math> premiers niveaux et le dernier doit être rempli de gauche à droite. Un des aspects les plus pratiques d'un tas est qu'il peut être stocké dans un tableau <em>T </em>tel qu'illustré sur la Figure <a href="#fig_Tas">6.4</a>. L'arbre binaire correspondant au tas doit respecter un certain ordre dans ses éléments : si <em>A</em> et <em>B</em> sont deux nœuds de l'arbre binaire tels que <em>A</em> est le père de <em>B</em>, alors <em><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>t</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>A</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo> &le; </mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>t</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>B</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>.</em>
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3115' />
<img style='width:70%;' src='assets/master_thesis/35_Users_michael_Desktop_memoire_images_tas.png' alt='image: 35_Users_michael_Desktop_memoire_images_tas.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3116' />
<div class='float-caption float-caption-figure'>Figure 6.4:<div class="plain_layout"><a id='magicparlabel-3120' />
<a id="fig_Tas" />
Tas représenté dans un arbre binaire et tableau correspondant</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3121' />
Pour représenter l'arbre binaire d'un tas sous forme d'un tableau <em>T, </em>il suffit d'utiliser certaines relations entre ses cellules. En posant <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> une cellule de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>T</mi>
 </mrow></math>, les relations suivantes définissent les positions des cellules qui correspondent à son père et à ses deux fils dans l'arbre binaire :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3126' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>P</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>i</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>lfloor</mo>
   <mrow><mi>i</mi><mo>/</mo><mn>2</mn>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>rfloor</mo>
  </mrow>
 </mrow></math>
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3127' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>F</mi><mi>i</mi><mi>l</mi><mi>s</mi><mi>G</mi><mi>a</mi><mi>u</mi><mi>c</mi><mi>h</mi><mi>e</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>i</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>2</mn><mo>*</mo><mi>i</mi>
  </mrow>
 </mrow></math>
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3128' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>F</mi><mi>i</mi><mi>l</mi><mi>s</mi><mi>D</mi><mi>r</mi><mi>o</mi><mi>i</mi><mi>t</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>i</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>2</mn><mo>*</mo><mi>i</mi><mo>+</mo><mn>1</mn>
  </mrow>
 </mrow></math>
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-3129' />
Voici les possibilités d'utilisation d'un tas et les complexités correspondantes :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3134' />
Insertion triée (<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mrow><mo> log </mo><mi>n</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>) : insère un nœud dans le tas en fonction de son coût. L'insertion se fait en ajoutant un nœud à la fin du tas et en le <strong>remontant</strong> jusqu'à la position adéquate à l'aide de la fonction <em>repositionneHaut(T, cell)</em>.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3135' />
Extraction (<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mrow><mo> log </mo><mi>n</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>) : récupére et supprime le premier nœud du tas, celui dont le coût est le plus petit. La suppression du premier nœud du tas s'effectue en remplaçant le premier nœud par le dernier et en <strong>redescendant</strong> celui-ci dans le tas jusqu'à la position adéquate à l'aide de la fonction <em>repositionneBas(T, cell)</em>.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-3136' />
Incontestablement, l'insertion est plus rapide avec un tas qu'avec une liste chaînée car la complexité dans le pire des cas passe de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> à <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mrow><mo> log </mo><mi>n</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>. L'extraction, au contraire, devient maintenant dépendante du nombre d'éléments stockés, ce qui n'était pas le cas auparavant. Avec une liste chaînée, il suffisait de déconnecter le premier élément de la liste et de déplacer le pointeur de tête.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3137' />
Implémentation
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3138' />
Les deux fonctions les plus importantes du tas sont celles que nous avons déjà mentionnées : <em>repositionneHaut(T, cell)</em> (<em>cf. </em>Algorithme 2) et <em>repositionneBas(T, cell)</em> (<em>cf. </em>Algorithme 3). Celles-ci permettent de réorganiser l'arbre binaire respectivement après l'insertion d'un nœud ou la suppression du nœud minimum. Ils permettent aussi, entre autres, de repositionner dans l'arbre binaire un nœud dont le coût aurait été modifié. Cette fonctionnalité aura toute son importance dans le cadre du chapitre suivant : le parcours A*.</div>

<div class="standard"><a id='magicparlabel-3139' />
</div>

<div class="standard"><a id='magicparlabel-3159' />
</div>
<h2 class="section"><span class="section_label">6.4</span> <a id='magicparlabel-3189' />
Parcours A*</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3190' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3194' />
<strong>parcours A* </strong>: Parcours informé dans lequel nous définissons le coût d'un nœud par <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>+</mo><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3195' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est la distance déjà parcourue par le nœud <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math>. C'est-à-dire le coût du meilleur chemin, dans l'arbre de recherche, entre le nœud racine et le nœud <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math>.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3196' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est l'estimation de la distance restante à parcourir à partir du nœud <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> pour trouver le nœud solution. <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo> &le; </mo>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est la distance exacte entre le nœud <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> et le nœud solution. L'estimation doit donc être minorante de la distance réelle.</li>
</ul>
</div></strong></div>
<h3 class="subsection"><span class="subsection_label">6.4.1</span> <a id='magicparlabel-3197' />
Fonctionnement</h3>
<div class="standard"><a id='magicparlabel-3198' />
<em>Le parcours A*</em> permet de favoriser les nœuds les plus prometteurs : ceux qui n'ont pas encore parcouru une longue distance et pour lesquels la distance restante devrait être la plus faible.
<br />

</div>

<div class="standard"><a id='magicparlabel-3199' />
Dans le cas du Sokoban, le coût représente le nombre de poussées. Le passage entre un nœud parent et un nœud enfant correspond à une unique poussée. <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est donc facile à calculer et représente la profondeur du nœud dans l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3200' />
Le théorème d'admissibilité  affirme que pour un arbre de recherche <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi> &delta; </mi>
 </mrow></math> tel que :
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-3209' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi> &delta; </mi>
 </mrow></math> contient un nœud solution.</li>
<li class="enumerate_item"><a id='magicparlabel-3210' />
Le nombre de fils d'un nœud quelconque est fini.</li>
<li class="enumerate_item"><a id='magicparlabel-3211' />
Il existe un minorant strictement positif de l'ensemble des coûts des arcs.
<br />

</li>
</ol>
<div class="standard"><a id='magicparlabel-3212' />
alors :
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-3217' />
Les algorithmes de types A* appliqués à <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi> &delta; </mi>
 </mrow></math> se terminent.</li>
<li class="enumerate_item"><a id='magicparlabel-3218' />
Un chemin joignant la racine à un nœud solution est trouvé.</li>
<li class="enumerate_item"><a id='magicparlabel-3219' />
Le chemin découvert est un chemin de coût minimal dans l'arbre de recherche, entre la racine et l'ensemble des nœuds solutions.
<br />

</li>
</ol>
<div class="standard"><a id='magicparlabel-3220' />
Ce théorème signifie donc que, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &forall; </mi><mi>n</mi>
  </mrow>
 </mrow></math> un nœud de l'arbre de recherche, si <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est une heuristique admissible et donc minorante de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, la solution trouvée sera optimale en terme de poussées.
<br />

</div>

<div class="standard"><a id='magicparlabel-3221' />
Si l'estimation de la distance restante était parfaite avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, le parcours A* irait directement de la racine vers le meilleur nœud solution sans s'égarer. Dans les faits, malheureusement, une estimation parfaite est extrèmement difficile à réaliser. La meilleure solution est de multiplier les techniques pour approcher au mieux la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>.</div>
<h3 class="subsection"><span class="subsection_label">6.4.2</span> <a id='magicparlabel-3222' />
Implémentation</h3>
<div class="standard"><a id='magicparlabel-3223' />
Lors du parcours, il a été prévu dans la Section <a href="#sec_Doublons">5.6</a> de rejeter un état si celui-ci est déjà présent dans l'arbre de recherche. Dans le cas du parcours A*, afin de garder l'optimalité des solutions, il ne suffit plus de rejeter tous les doublons. En effet, deux états identiques peuvent se trouver à deux profondeurs différentes de l'arbre de recherche et possèder deux valeurs différentes pour <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math><div class="foot"><span class="foot_label">1</span><div class="foot_inner"><div class="plain_layout"><a id='magicparlabel-3227' />
La valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> ne varie pas en fonction de la position dans l'arbre de recherche d'un même état</div>
</div></div> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> est le nœud contenant l'état. Si le nœud dont la valeur est la plus petite, et donc la meilleure, est traité en deuxième lors du parcours, il sera considéré comme doublon et rejeté à tort. Le risque est que ce nœud mène justement à la solution optimale, qui sera alors perdue.
<br />

</div>

<div class="standard"><a id='magicparlabel-3228' />
Des manipulations supplémentaires sont donc ajoutées pour, dans le cas de doublons, toujours conserver le nœud dont le coût est le plus bas et réorganiser l'arbre de recherche en fonction. Comme ces manipulations diffèrent en fonction de la présence, ou non, du nœud dans la liste d'attente, un moyen a dû être trouvé pour discerner ces deux types de nœuds.
<br />

</div>

<div class="standard"><a id='magicparlabel-3229' />
La table de hachage est dédoublée. La première, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>T</mi>
   </mrow>
   <mrow>
    <mrow><mi>o</mi><mi>u</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>t</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>, est utilisée pour stocker les <em>états ouverts</em> et la seconde, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>T</mi>
   </mrow>
   <mrow>
    <mrow><mi>f</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>, pour stocker les <em>états fermés</em>. Il est ainsi possible, à partir de l'état contenu dans un nœud, de vérifier rapidement sa présence dans l'une ou l'autre table et d'agir en conséquence.</div>

<div class="standard" style='text-align: center;'><a id='magicparlabel-3230' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3234' />
<strong>nœud/état ouvert </strong>: nœud/état de l'arbre de recherche qui est dans la liste d'attente. Ses enfants doivent encore être trouvés.</div>

<div class="plain_layout"><a id='magicparlabel-3235' />
<strong>nœud/état fermé</strong> : nœud/état de l'arbre de recherche pour lequel tous les enfants, s'il en a, ont été trouvés et ajoutés à l'arbre.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3236' />
Il est parfois indispensable de pouvoir accéder directement à l'un des nœuds de la liste d'attente. Le problème est qu'un tas ne permet pas de rechercher efficacement un élément parmi ceux qui sont stockés. La solution la plus simple consisterait à parcourir toutes les cases du tableau correspondant à l'arbre binaire du tas pour trouver celle recherchée. C'est aussi la solution la plus coûteuse car sa complexité serait en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> représente le nombre d'éléments stockés dans le tableau.
<br />

</div>

<div class="standard"><a id='magicparlabel-3237' />
Une solution plus efficace, qui tire profit de la complexité moyenne en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>1</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> de la table de hachage, consiste à ajouter une nouvelle donnée à chaque élément de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>T</mi>
   </mrow>
   <mrow>
    <mrow><mi>o</mi><mi>u</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>t</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> qui correspondrait à la position du nœud dans le tas. Cette donnée supplémentaire de la table de hachage devra être mise à jour à chaque manipulation du tas pour que sa valeur reste cohérente.
<br />

</div>

<div class="standard"><a id='magicparlabel-3238' />
La fonction <em>dejaExistant(noeud)</em> de l'Algorithme 1, utilisée pour détecter les doublons, est modifiée pour mettre l'arbre de recherche à jour si un doublon s'avère meilleur qu'un nœud déjà présent. L'ancien nœud sera remplacé par le nouveau et les coûts des enfants déjà présents seront adaptés.
<br />

</div>

<div class="standard"><a id='magicparlabel-3239' />
</div>

<div class="standard"><a id='magicparlabel-3277' />
L'Algorithme 4 décrit la méthode permettant de gérer efficacement les doublons de manière à conserver l'optimalité de la solution. La première constatation que l'on peut faire est que, dans le cas d'un nouveau nœud qui n'est pas doublon, le fonctionnement est identique à celui des autres parcours. C'est-à-dire que la présence du nœud est déclinée dans la fonction <em>dejaExistant(noeud) </em>et qu'il est ajouté normalement dans l'arbre de recherche sans travail supplémentaire.
<br />

</div>

<div class="standard"><a id='magicparlabel-3278' />
Au contraire, dans le cas d'un nœud déjà présent dans l'arbre de recherche, qu'il soit ouvert ou fermé, des manipulations supplémentaires vont devoir être mises en application. Celles-ci se divisent en deux catégories :</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3279' />
Le nouveau nœud est déjà présent dans l'arbre de recherche et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>n</mi><mi>o</mi><mi>e</mi><mi>u</mi><mi>d</mi><mi>P</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo> &isin; </mo>
   <msub>
    <mrow><mi>T</mi>
    </mrow>
    <mrow>
     <mrow><mi>f</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3280' />
Le nœud présent dans l'arbre de recherche possède, potentiellement, des enfants. Le coût des enfants doit être adapté si la position dans l'arbre de leur ancêtre commun est modifiée. La partie de l'algorithme qui correspond à ce paragraphe est celle qui va de la ligne 2 à la ligne 8.
<br />

</div>

<div class="standard"><a id='magicparlabel-3281' />
Si le coût du nouveau nœud est plus grand que celui du nœud présent, l'arbre de recherche n'est pas modifié. À l'opposé, si le coût du nouveau nœud est plus petit, et donc meilleur que celui du nœud déjà présent, on déplace le sous-arbre formé par le nœud présent à l'endroit du nouveau nœud. Les valeurs de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> de tout le sous-arbre sont ensuite réduites de la différence entre le coût de l'ancien nœud et le coût du nouveau nœud.
<br />

</div>

<div class="standard"><a id='magicparlabel-3282' />
Voici quelques explications sur les fonctions utilisées :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3287' />
<em>noeudFerme ← recupere(<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi>
   <msub><mrow />
    <mrow>
     <mrow><mi>f</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, noeud)</em> : si <em>noeud</em> existe dans la table de hachage <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>T</mi>
   </mrow>
   <mrow>
    <mrow><mi>f</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>,<em> </em>la fonction retourne la référence vers sa position dans l'arbre de recherche. Si le nœud n'existe pas dans la table de hachage, la fonction <em>existe(noeudFerme)</em> retournera <em>faux</em>.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3288' />
<em>attacheNoeud(noeudFerme, parent(noeud))</em> : attache<em> noeudFerme</em> au parent du nœud actuellement traité. L'objectif est de déplacer un sous-arbre entier de l'arbre de recherche à un endroit moins profond et donc relatif à un moindre coût.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3289' />
<em>reduitCout(noeudFerme, cout(noeudFerme) − cout(noeud))</em> : réduit le coût du sous-arbre formé de <em>noeudFerme</em> de la différence de valeur, et donc de profondeur, qu'il y a entre l'ancienne position du sous-arbre et la nouvelle.</li>
</ul>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3290' />
Le nouveau nœud est déjà présent dans l'arbre de recherche et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>n</mi><mi>o</mi><mi>e</mi><mi>u</mi><mi>d</mi><mi>P</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo> &isin; </mo>
   <msub>
    <mrow><mi>T</mi>
    </mrow>
    <mrow>
     <mrow><mi>o</mi><mi>u</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>t</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3291' />
Le nœud déjà présent dans l'arbre de recherche n'a pas encore d'enfants et est toujours en attente de traitement dans la liste d'attente (le tas). Si le coût du nœud change, il devra être replacé dans la liste d'attente en fonction de sa nouvelle priorité. La partie de l'algorithme qui correspond à ce paragraphe est celle qui va de la ligne 10 à la ligne 19.
<br />

</div>

<div class="standard"><a id='magicparlabel-3292' />
Si le coût du nouveau nœud est plus grand que celui du nœud présent, l'arbre de recherche n'est pas modifié. À l'opposé, si le coût du nouveau nœud est plus petit, et donc meilleur que celui du nœud présent, on modifie la valeur du nœud présent et on l'accroche au père du nouveau nœud. Le nœud présent se situera donc à une position moins profonde de l'arbre. Pour terminer, la position dans le tas du nœud présent est révisée en fonction de son nouveau coût.
<br />

</div>

<div class="standard"><a id='magicparlabel-3293' />
Voici quelques explications sur les fonctions utilisées :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3298' />
<em>noeudOuvert ← recupere(<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi>
   <msub><mrow />
    <mrow>
     <mrow><mi>o</mi><mi>u</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>t</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, noeud)</em> : si <em>noeud</em> existe dans la table de hachage <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>T</mi>
   </mrow>
   <mrow>
    <mrow><mi>o</mi><mi>u</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>t</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>,<em> </em>la fonction retourne la référence vers sa position dans l'arbre de recherche. Si le nœud n'existe pas dans la table de hachage, la fonction <em>existe(noeudOuvert)</em> retournera <em>faux</em>.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3299' />
<em>cellule ← recupereCelluleTas(<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>T</mi>
   <msub><mrow />
    <mrow>
     <mrow><mi>o</mi><mi>u</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>t</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, noeud)</em> : grâce à la modification de la table de hachage des nœuds ouverts, il est maintenant possible d'accéder directement à la position d'un nœud dans le tableau correspondant à l'arbre binaire du tas.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3300' />
<em>assigneCout(noeudOuvert, cout(noeud))</em> : assigne simplement un nouveau coût à un nœud. Comme le nœud est ouvert, il n'a pas encore d'enfants et il n'est donc pas nécessaire de s'en préoccuper.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3301' />
<em>repositionneHaut(Tas, cellule)</em> : fonction décrite dans l'Algorithme 2. Permet de repositionner, vers le haut, un nœud dans le tas en fonction de son nouveau coût, qui est plus petit que l'ancien..
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3302' />
<em>attacheNoeud(noeudOuvert, parent(noeud))</em> : attache<em> noeudOuvert</em> au parent du nœud actuellement traité. L'objectif est de déplacer le nœud à un endroit moins profond de l'arbre de recherche et donc relatif à un moindre coût.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-3303' />
Dans les deux cas, une fois l'arbre de recherche modifié, la fonction retournera <em>vrai</em> pour signaler que le nœud est un doublon. Tout le travail pour modifier l'arbre aura déjà été effectué en amont. Le nœud courant n'a donc plus besoin d'être inséré par la suite.</div>
<h3 class="subsection"><span class="subsection_label">6.4.3</span> <a id='magicparlabel-3304' />
<a id="sub_triA" />
Priorité de la liste d'attente</h3>
<div class="standard"><a id='magicparlabel-3305' />
Le tas est organisé de façon à ce que les nœuds les plus prometteurs soient prioritaires. La méthode simple consiste à placer en tête de liste ceux pour lesquels le coût <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est le plus petit. Il est cependant possible d'affiner ce résultat. En cas d'égalité pour les valeurs de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, une deuxième condition portant sur les valeurs de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est ajoutée. Pour deux valeurs égales de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, la plus petite valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> sera prioritaire<div class="foot"><span class="foot_label">2</span><div class="foot_inner"><div class="plain_layout"><a id='magicparlabel-3309' />
Comme <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>+</mo><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, prendre le plus petite valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> revient à prendre la plus grande valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> </div>
</div></div> tel qu'illustré sur la Figure <a href="#fig_astar">6.5</a>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3310' />
Trier le tas d'une façon différente consiste à adapter la fonction <em>estPlusPetit(noeud1, noeud2) </em>utilisée dans les Algorithmes 2 et 3. Cette fonction définit explicitement dans quelles conditions un nœud est plus petit, et donc possède une meilleur priorité, qu'un autre.</div>
<h3 class="subsection"><span class="subsection_label">6.4.4</span> <a id='magicparlabel-3311' />
Exemple </h3>
<div class="standard"><a id='magicparlabel-3312' />
La Figure <a href="#fig_astar">6.5</a> représente les différentes structures qui interviennent lors d'un parcours A*. Pour une lecture plus facile, la liste d'attente n'est pas représentée sous la forme d'un tas mais sous celle d'une liste chaînée triée. On voit que le parcours se dirige assez facilement vers le nœud solution 15 en évitant les autres nœuds dont le coût <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est plus élevé. Si aucune solution en 5 poussées n'était possible, le prochain nœud traité serait le premier de la liste d'attente et donc celui qui est le plus prometteur en 6 poussées.</div>

<div class="standard"><a id='magicparlabel-3313' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3317' />
<img style='width:85%;' src='assets/master_thesis/36_Users_michael_Desktop_memoire_images_parcours_Astar.png' alt='image: 36_Users_michael_Desktop_memoire_images_parcours_Astar.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3318' />
<div class='float-caption float-caption-figure'>Figure 6.5:<div class="plain_layout"><a id='magicparlabel-3322' />
<a id="fig_astar" />
Parcours en profondeur</div>
</div></div>
</div>

<h2 class="section"><span class="section_label">6.5</span> <a id='magicparlabel-3323' />
<a id="sec_Parcours_IDA_" />
Parcours IDA*</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3324' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3328' />
<strong>parcours IDA*</strong> : <em>Iterative Deepening A*</em> est entièrement basé sur l'algorithme A*. Il possède la particularité de fixer une valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> afin que tous les nœuds pour lesquels <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>&gt;</mo>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow>
     <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> soient directement rejetés. En incrémentant la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> à chaque itération de l'algorithme A*, le parcours IDA* finira par trouver la solution optimale.</div>
</div></strong></div>
<h3 class="subsection"><span class="subsection_label">6.5.1</span> <a id='magicparlabel-3329' />
Fonctionnement</h3>
<div class="standard"><a id='magicparlabel-3330' />
Le<em> parcours IDA*</em> fonctionne sur base d'itérations successives du parcours A* pour lesquelles la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> est fixée dès le départ. Ainsi, nous pouvons imaginer que la première itération s'effectuera avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow>
     <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
     </mrow>
    </mrow>
   </msub><mo>=</mo><mn>1</mn>
  </mrow>
 </mrow></math>, la deuxième avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow>
     <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
     </mrow>
    </mrow>
   </msub><mo>=</mo><mn>2</mn>
  </mrow>
 </mrow></math> et ainsi de suite. Chaque itération va tester toutes les possibilités dont les coûts seront dans la limite précisée. Si aucun nœud solution n'est trouvé, le coût maximal sera incrémenté et le parcours A* sera relancé jusqu'à l'obtention d'une solution.
<br />

</div>

<div class="standard"><a id='magicparlabel-3331' />
Cette façon de procéder permet aux différentes itérations du parcours A* de supprimer rapidement de l'arbre de recherche, les sous-arbres dont il sait déjà que les solutions potentielles ne se trouvent pas dans la limite précisée. Prenons par exemple le cas où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow>
     <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
     </mrow>
    </mrow>
   </msub><mo>=</mo><mn>10</mn>
  </mrow>
 </mrow></math>. À un endroit donné de l'arbre de recherche, nous obtenons un nœud pour lequel <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>2</mn>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>9</mn>
  </mrow>
 </mrow></math> et donc <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>11</mn>
  </mrow>
 </mrow></math>. Nous pouvons rejeter ce nœud et par la même occasion tous ses enfants car, au mieux, la solution que l'on y trouvera s'effectuera en 11 poussées. Nous avons donc évité un parcours inutile seulement après les deux premières poussées.
<br />

</div>

<div class="standard"><a id='magicparlabel-3332' />
La Figure <a href="#fig_parcours_ida">6.6</a> montre différentes itérations du parcours A*. Nous pouvons y voir que la solution optimale sera toujours trouvée la première (lors de l'itération pour laquelle <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow>
     <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
     </mrow>
    </mrow>
   </msub><mo>=</mo><mn>10</mn>
  </mrow>
 </mrow></math>). Des solutions moins bonnes pourraient être trouvées lors d'itérations suivantes.</div>

<div class="standard"><a id='magicparlabel-3333' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3337' />
<img style='width:40%;' src='assets/master_thesis/37_Users_michael_Desktop_memoire_images_IDA.png' alt='image: 37_Users_michael_Desktop_memoire_images_IDA.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3338' />
<div class='float-caption float-caption-figure'>Figure 6.6:<div class="plain_layout"><a id='magicparlabel-3342' />
<a id="fig_parcours_ida" />
Les différentes itérations du parcours A*</div>
</div></div>
</div>

<h3 class="subsection"><span class="subsection_label">6.5.2</span> <a id='magicparlabel-3343' />
Avantages</h3>
<div class="standard"><a id='magicparlabel-3344' />
L'utilisation du parcours IDA* possède un double avantage :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3349' />
La solution optimale sera trouvée avec un arbre de recherche plus petit et donc avec une utilisation moins importante de la mémoire. Cela est dû à la suppression de tous les nœuds pour lesquels le coût est plus grand que l'objectif <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> visé.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3350' />
À la fin d'une itération du parcours A* pour laquelle <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow>
     <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
     </mrow>
    </mrow>
   </msub><mo>=</mo><mi>a</mi>
  </mrow>
 </mrow></math>, il y a deux possibilités :

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-3351' />
Soit une solution est trouvée et est optimale.</li>
<li class="enumerate_item"><a id='magicparlabel-3352' />
Soit aucune solution n'est trouvée mais il est possible d'affirmer que le nombre de poussées de la solution optimale sera <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo>&gt;</mo><mi>a</mi>
  </mrow>
 </mrow></math>.</li>
</ol>
</li></ul>
<h3 class="subsection"><span class="subsection_label">6.5.3</span> <a id='magicparlabel-3353' />
Inconvénients</h3>
<div class="standard"><a id='magicparlabel-3354' />
L'inconvénient principal de ce parcours est qu'une même partie de l'arbre de recherche sera explorée plusieurs fois lors d'itérations successives du parcours A*. Ce n'est pas un problème majeur car, dans un arbre, la variation du nombre de nœuds d'une itération à une autre est souvent exponentielle. La dernière itération a donc, la plupart du temps, la propriété d'englober toutes les itérations précédentes en terme de temps de calcul.</div>

<div class="standard"><a id='magicparlabel-3355' />
</div>
<h3 class="subsection"><span class="subsection_label">6.5.4</span> <a id='magicparlabel-3356' />
Optimisations</h3>
<div class="standard"><a id='magicparlabel-3357' />
Deux optimisations ont été mises en place afin d'éviter d'incrémenter le coût en partant de 1 et uniquement par pas de 1.</div>
<h4 class="subparagraph"><span class="subparagraph_label"></span> <a id='magicparlabel-3358' />
Valeur initiale de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math></h4>
<div class="standard"><a id='magicparlabel-3359' />
L'état initial d'un problème possède un coût qui lui est propre. Il est inutile de commencer à appliquer le parcours A* sur cet état avec une limite plus basse que son coût. En effet, le premier nœud rencontré serait directement rejeté. La limite initiale à appliquer est donc le coût de l'état initial.</div>
<h4 class="subparagraph"><span class="subparagraph_label"></span> <a id='magicparlabel-3360' />
Incrémentation de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math></h4>
<div class="standard"><a id='magicparlabel-3361' />
Nous avons remarqué que l'évolution du coût a tendance à évoluer par pas de 2. En effet, si le pousseur est placé du mauvais côté pour pousser une caisse, il va d'abord devoir la pousser une première fois, la contourner, puis la repousser une deuxième fois (<em>cf</em>. Figure <a href="#fig_Ecart_entre_estimation">6.7</a>). L'estimation du coût est ainsi faussée de 2 poussées. Pour ne pas inutilement incrémenter la limite par pas de 1 si on peut progresser plus rapidement, nous allons garder en mémoire le nœud rejeté dont le coût est le plus petit. Par exemple si la limite actuelle est de 10 et qu'à la fin de l'itération, le coût le plus petit qui a été rejeté est 12, nous pourrons commencer l'itération suivante à 12.</div>

<div class="standard"><a id='magicparlabel-3362' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3366' />
<img style='width:35%;' src='assets/master_thesis/38_Users_michael_Desktop_memoire_images_cout.png' alt='image: 38_Users_michael_Desktop_memoire_images_cout.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3367' />
<div class='float-caption float-caption-figure'>Figure 6.7:<div class="plain_layout"><a id='magicparlabel-3371' />
<a id="fig_Ecart_entre_estimation" />
L'écart entre <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est souvent de 2</div>
</div></div>
</div>

<h3 class="subsection"><span class="subsection_label">6.5.5</span> <a id='magicparlabel-3372' />
<a id="sub_triIDA" />
Priorité de la liste d'attente</h3>
<div class="standard"><a id='magicparlabel-3373' />
Avec le parcours IDA* et contrairement au parcours A*, il est possible de trier la liste d'attente des nœuds uniquement par rapport à la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>. En effet, étant donné que la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est majorée par <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>, la seule contrainte de priorité concerne le nombre de poussées restantes pour qu'un nœud mène à une solution.
<br />

</div>

<div class="standard"><a id='magicparlabel-3374' />
Trier le tas d'une façon différente consiste à adapter la fonction <em>estPlusPetit(noeud1, noeud2) </em>utilisée dans les Algorithmes 2 et 3. Cette fonction définit explicitement dans quelles conditions un nœud est plus petit, et donc possède une meilleur priorité, qu'un autre.</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 7</span> <a id='magicparlabel-3375' />
<a id="cha_Estimation" />
Estimation</h1>
<div class="standard"><a id='magicparlabel-3376' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-3377' />
</div>

<div class="standard"><a id='magicparlabel-3382' />
Nous avons vu dans le cadre du parcours A*, et par extension IDA*, que l'efficacité du parcours dépendait de la précision de l'estimation de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> est un nœud de l'arbre de recherche. Estimer correctement le nombre de poussées restantes pour trouver une solution à partir d'un état de l'arbre de recherche est une opération très difficile. Le plus dur est certainement de ne jamais surestimer la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>. Si, lors de la résolution, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &exist; </mi><mi>n</mi><mspace width="6px" /><mspace width="6px" /><mi>t</mi><mi>q</mi><mspace width="6px" /><mspace width="6px" /><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>&gt;</mo>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, le parcours A* ne garantit plus l'obtention de la solution optimale.
<br />

</div>

<div class="standard"><a id='magicparlabel-3383' />
Le parcours A* peut aboutir à une solution optimale avec une estimation peu précise. Cependant, ce n'est qu'avec une très bonne estimation qu'il montre sa réelle efficacité. Il est bon de se rappeler que si <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, c'est-à-dire si l'estimation est parfaite, le parcours dans l'arbre de recherche irait directement de la racine vers la solution.
<br />

</div>

<div class="standard"><a id='magicparlabel-3384' />
Pour trouver la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, l'idée principale est d'estimer le nombre de poussées nécessaires pour placer chaque caisse de l'état sur un goal. Le problème doit alors être décomposé en deux parties.
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-3385' />
Calculer le plus précisément possible le nombre de poussées requises pour placer une caisse sur chacun des goals. Nous appellerons cela l' <em>estimation d'une caisse</em>.</li>
<li class="enumerate_item"><a id='magicparlabel-3386' />
Diriger les caisses présentes dans un état vers les goals de manière à trouver l<em>' estimation totale de l'état</em> la plus juste possible. Il faut s'aider des estimations des caisses et il est important de continuer à minorer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>.</li>
</ol>
<h2 class="section"><span class="section_label">7.1</span> <a id='magicparlabel-3387' />
Estimation d'une caisse</h2>
<div class="standard"><a id='magicparlabel-3388' />
Il y a différentes façons de calculer l'<em>estimation d'une caisse</em>. Plus l'estimation sera précise et plus la taille de l'arbre de recherche aura tendance à diminuer. La méthode la plus simple, la <em>taxi-distance</em> est de loin la plus approximative. La méthode la plus précise, qui prend en compte les positions successives du pousseur, est aussi la plus coûteuse et demande l'application d'un algorithme assez lourd basé sur celui de Dijkstra.
<br />

</div>

<div class="standard"><a id='magicparlabel-3389' />
Comme nous le verrons dans le Chapitre <a href="#cha_Pr___traitement">10</a>, le temps de calcul de l'estimation des caisses n'est pas un problème majeur. Ceci est lié au fait que le calcul n'est réalisé qu'une seule fois par niveau. Par la suite, les résultats seront réutilisables à l'infini. Il est donc préférable d'utiliser les méthodes les plus précises même si elles s'avèrent souvent plus lentes.
<br />

</div>

<div class="standard"><a id='magicparlabel-3390' />
Chaque état contient des caisses sur des emplacements différents. Celles-ci peuvent potentiellement occuper toutes les positions internes d'un niveau (<em>cf.</em> Figure <a href="#fig_Liste_des_cases">5.3</a>). Nous allons construire une matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> carrée <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>N</mi><mo> &times; </mo><mi>N</mi>
  </mrow>
 </mrow></math>, où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>N</mi>
 </mrow></math> est le nombre de positions internes, et dans laquelle la cellule <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>M</mi>
   </mrow>
   <mrow>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>1</mn><mo> &le; </mo><mi>i</mi><mo>,</mo><mi>j</mi><mo> &le; </mo><mi>N</mi>
  </mrow>
 </mrow></math> contiendra le nombre de poussées requises pour déplacer une caisse située sur la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> vers la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>j</mi>
 </mrow></math>. Cette matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> sera aussi appelée <em>la table des estimations.</em>
<br />

</div>

<div class="standard"><a id='magicparlabel-3391' />
En théorie, nous n'avons besoin que des estimations des caisses vers les différents goals. Dans la pratique il est intéressant de généraliser pour trouver les estimations des caisses vers toutes les positions. Ces informations nous seront utiles dans la suite pour, par exemple, le calcul des macro-poussées (<em>cf</em>. Section <a href="#sec_Macro_pouss__es">12.1</a>). De plus, avec l'algorithme de Dijkstra, connaître les estimations des caisses vers les goals ou vers l'ensemble des autres positions nécessite, à peu de choses près, la même quantité de calculs.</div>
<h3 class="subsection"><span class="subsection_label">7.1.1</span> <a id='magicparlabel-3392' />
Taxi-distance</h3>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3393' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3397' />
<strong>taxi-distance</strong> : distance entre deux vecteurs telle que celle-ci est la somme de la valeur absolue des écarts entre chaque coordonnée des vecteurs. exemple : si <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mrow><mi>a</mi><mo>,</mo><mi>b</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>B</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mrow><mi>c</mi><mo>,</mo><mi>d</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo> &isin; </mo>
 </mrow></math> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msup>
   <mrow>
    <mstyle mathvariant='bold'><mi>R</mi>
    </mstyle>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msup>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>t</mi><mi>a</mi><mi>x</mi><mi>i</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mrow><mi>A</mi><mo>,</mo><mi>B</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mo>|</mo><mi>a</mi><mo>-</mo><mi>c</mi><mo>|</mo><mo>+</mo><mo>|</mo><mi>b</mi><mo>-</mo><mi>d</mi><mo>|</mo>
  </mrow>
 </mrow></math>.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3398' />
La <em>taxi-distance</em>, aussi appelée <em>Distance de Manhattan</em>, doit son nom à la distance que doivent effectuer les taxis de Manhattan pour joindre deux points dans la ville. Étant donné la structure de Manhattan qui est composée de quartiers rectangulaires et alignés, la distance réellement parcourue par un taxi correspondra à notre définition et non à la distance euclidienne. La Figure <a href="#fig_manhattan">7.1</a> montre que, quel que soit le chemin emprunté par le taxi dans Manhattan, la longueur totale vaudra 8 longueurs de blocs et correspondra à la taxi-distance.
<br />

</div>

<div class="standard"><a id='magicparlabel-3399' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3403' />
<img style='width:45%;' src='assets/master_thesis/39_Users_michael_Desktop_memoire_images_distance_manhattan.png' alt='image: 39_Users_michael_Desktop_memoire_images_distance_manhattan.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3404' />
<div class='float-caption float-caption-figure'>Figure 7.1:<div class="plain_layout"><a id='magicparlabel-3408' />
<a id="fig_manhattan" />
Illustration de la taxi-distance. Le taxi en bas à droite doit rejoindre le point en haut à gauche</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3409' />
Les déplacements du pousseur et des caisses, dans le jeu de Sokoban s'apparentent aux déplacements d'un taxi new-yorkais. La taxi-distance est donc une méthode simple s'appliquant au Sokoban pour mesurer la distance entre deux points de l'aire de jeu.
<br />

</div>

<div class="standard"><a id='magicparlabel-3410' />
La Figure <a href="#fig_taxi_distance">7.2</a> représente la taxi-distance entre la caisse se situant sur la position <em>F5</em> et l'ensemble des autres positions joignables.
<br />

</div>

<div class="standard"><a id='magicparlabel-3411' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3415' />
<img style='width:42%;' src='assets/master_thesis/40_Users_michael_Desktop_memoire_images_distance_taxi.png' alt='image: 40_Users_michael_Desktop_memoire_images_distance_taxi.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3416' />
<div class='float-caption float-caption-figure'>Figure 7.2:<div class="plain_layout"><a id='magicparlabel-3420' />
<a id="fig_taxi_distance" />
Estimations de la caisse obtenues par la méthode de la taxi-distance</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3421' />
Comme la taxi-distance représente le chemin le plus court entre un point <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> et un point <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>B</mi>
 </mrow></math> si aucun obstacle n'est dans le chemin, il parait clair que cette estimation conservera toujours la propriété d'admissibilité du parcours A*. Les obstacles (caisses et murs) qui pourraient gêner le déplacement de la caisse ne pourraient qu'augmenter la valeur obtenue par la taxi-distance.</div>
<h3 class="subsection"><span class="subsection_label">7.1.2</span> <a id='magicparlabel-3422' />
Distance réelle</h3>
<div class="standard"><a id='magicparlabel-3423' />
La <em>distance réelle</em> représente la distance obtenue pour mettre une caisse sur un goal à l'aide de l'application de l'<em>algorithme de Dijkstra</em> .</div>

<div class="standard" style='text-align: center;'><a id='magicparlabel-3428' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3432' />
<strong>algorithme de Dijkstra</strong> : algorithme permettant de trouver le plus court chemin entre deux sommets d'un graphe connexe pour lequel les arêtes/arcs ont un poids positif ou nul.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3433' />
Un niveau de Sokoban peut toujours être transformé en graphe connexe. Celui-ci sera utilisé pour appliquer l'algorithme de Dijkstra sur les caisses et trouver les distances les plus courtes entre celles-ci et les goals.
<br />

</div>

<div class="standard"><a id='magicparlabel-3434' />
Le graphe connexe créé correspond aux déplacements possibles des caisses. Soit <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>p</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>p</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>p</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math>, trois positions alignées dans un niveau, les conditions requises pour qu'une caisse située en <strong><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>p</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math> </strong>puisse bouger en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>p</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math> sont les suivantes :
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-3435' />
La position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>p</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math> ne doit être ni un mur, ni une caisse. Elle correspond à l'emplacement du pousseur avant la poussée.</li>
<li class="enumerate_item"><a id='magicparlabel-3436' />
La position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>p</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math> ne doit être ni un mur, ni une caisse. Elle correspond à l'emplacement de la caisse après la poussée.
<br />

</li>
</ol>
<div class="standard"><a id='magicparlabel-3437' />
La Figure <a href="#fig_dijkstra1noeuds">7.3</a> représente le graphe connexe utilisé pour calculer l'estimation de la caisse <em>F5 </em>ainsi que le niveau qui comprend les estimations obtenues de la sorte. Sachant que chaque arc du graphe possède un poids unitaire, il est facile d'y appliquer directement l'algorithme de Dijkstra. L'objectif est de trouver le chemin minimal permettant de pousser la caisse <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>s</mi>
   </mrow>
   <mrow><mn>0</mn>
   </mrow>
  </msub>
 </mrow></math> vers les trois goals <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>s</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>s</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>s</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math>, et par la même occasion, les chemins minimaux de la caisse vers toutes les autres positions.
<br />

</div>

<div class="standard"><a id='magicparlabel-3438' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3442' />
<img style='width:38%;' src='assets/master_thesis/41_Users_michael_Desktop_memoire_images_distance_dijkstra1noeud.png' alt='image: 41_Users_michael_Desktop_memoire_images_distance_dijkstra1noeud.png' />
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img style='width:42%;' src='assets/master_thesis/42_Users_michael_Desktop_memoire_images_distance_dijkstra1.png' alt='image: 42_Users_michael_Desktop_memoire_images_distance_dijkstra1.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3443' />
<div class='float-caption float-caption-figure'>Figure 7.3:<div class="plain_layout"><a id='magicparlabel-3447' />
<a id="fig_dijkstra1noeuds" />
Graphe connexe et estimation de la caisse obtenue, via l'algorithme de Dijkstra, dans le niveau correspondant </div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3448' />
En comparant l'estimation obtenue par l'algorithme de Dijkstra avec celle obtenue par la taxi-distance, on peut déjà remarquer une augmentation des valeurs de certaines positions. L'estimation pour joindre le goal situé sur la position <em>D5</em> passe de 2 à 4. La propriété d'admissibilité est conservée car, en aucun cas, un chemin plus court que celui de l'algorithme de Dijkstra ne pourra être trouvé.</div>
<h3 class="subsection"><span class="subsection_label">7.1.3</span> <a id='magicparlabel-3449' />
<a id="sub_Distance_r__elle_avec" />
Distance réelle avec gestion du pousseur</h3>
<div class="standard"><a id='magicparlabel-3450' />
Dans la section précédente, la méthode que nous avons utilisée pour construire le graphe connexe possède un défaut majeur : elle ne prend pas en compte la position du pousseur lors des déplacements successifs des caisses. Ce manquement peut mener à négliger une partie des poussées nécessaires pour positionner une caisse sur un goal.
<br />

</div>

<div class="standard"><a id='magicparlabel-3451' />
À titre d'exemple, sur la Figure <a href="#fig_dijkstra1noeuds">7.3</a>, après une poussée de <em>E4</em> vers <em>D4</em>, le pousseur se trouvera sur la position <em>E4</em>. Par la suite, il n'aura pas la possibilité de déplacer la caisse sur la position <em>D5</em>, contrairement à ce qui est indiqué dans le graphe.
<br />

</div>

<div class="standard"><a id='magicparlabel-3452' />
Deux solutions sont envisageables pour calculer les estimations des caisses en prenant en compte les positions successives du pousseur : l'application d'un <em>parcours en largeur</em> et la <em>création améliorée du graphe connexe</em>.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3453' />
Parcours en largeur
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3454' />
Dans le but de réutiliser des fonctionnalités qui ont déjà été implémentées, cette méthode passe par la création d'un niveau temporaire comprenant une seule caisse et un seul goal. Sur ce niveau, un parcours en largeur sera appliqué tel qu'il a été décrit dans la Section <a href="#sec_Parcours_en_largeur">6.1</a>. Celui-ci permet de trouver la solution optimale d'un niveau. Le nombre de poussées de la solution optimale servira donc d'estimation pour déplacer une caisse de la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> vers la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>j</mi>
 </mrow></math>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3455' />
Cette méthode peut rapidement être mise en place à partir du parcours en largeur déjà existant. La complexité pourrait néanmoins poser un problème.
<br />

</div>

<div class="standard"><a id='magicparlabel-3456' />
Sachant que :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3461' />
Le parcours en largeur est de complexité <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <msup>
    <mrow><mi>b</mi>
    </mrow>
    <mrow><mi>d</mi>
    </mrow>
   </msup><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>b</mi>
 </mrow></math> est le facteur de branchement et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>d</mi>
 </mrow></math> la profondeur de l'arbre de recherche. Notons que la profondeur de l'arbre dépend indirectement de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math>, le nombre de positions internes du niveau.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3462' />
Il faut appliquer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msup>
   <mrow><mi>n</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msup>
 </mrow></math> parcours en largeur pour calculer l'entièreté de la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math>, où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> est le nombre de positions internes.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-3463' />
La quantité de calculs va exploser pour certains niveaux qui possèdent plusieurs centaines de positions. Même si cette situation se présente peu dans nos 90 niveaux de test, il vaut mieux trouver une méthode moins coûteuse afin de pouvoir l'utiliser dans un plus grand nombre de cas.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3464' />
Création améliorée du graphe connexe
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3465' />
Tout en conservant l'utilisation de l'algorithme de Dijkstra, nous créons un graphe connexe en y intégrant l'information de la position du pousseur. Pour atteindre cet objectif, la première chose à faire est de multiplier les sommets dans le graphe. Chaque position interne du niveau est représentée par, au maximum, quatre sommets.
<br />

</div>

<div class="standard"><a id='magicparlabel-3466' />
Les quatre sommets qui représentent une position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> sont les suivants :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3471' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>S</mi>
   </mrow>
   <mrow>
    <msub>
     <mrow><mi>i</mi>
     </mrow>
     <mrow>
      <mrow><mi>d</mi><mi>r</mi><mi>o</mi><mi>i</mi><mi>t</mi><mi>e</mi>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </msub>
 </mrow></math> : la caisse se situe sur la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> et vient de <strong>droite</strong>.</li>
<li class="itemize_item"><a id='magicparlabel-3472' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>S</mi>
   </mrow>
   <mrow>
    <msub>
     <mrow><mi>i</mi>
     </mrow>
     <mrow>
      <mrow><mi>g</mi><mi>a</mi><mi>u</mi><mi>c</mi><mi>h</mi><mi>e</mi>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </msub>
 </mrow></math>: la caisse se situe sur la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> et vient de <strong>gauche</strong>.</li>
<li class="itemize_item"><a id='magicparlabel-3473' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>S</mi>
   </mrow>
   <mrow>
    <msub>
     <mrow><mi>i</mi>
     </mrow>
     <mrow>
      <mrow><mi>h</mi><mi>a</mi><mi>u</mi><mi>t</mi>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </msub>
 </mrow></math>: la caisse se situe sur la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> et vient du <strong>haut</strong>.</li>
<li class="itemize_item"><a id='magicparlabel-3474' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>S</mi>
   </mrow>
   <mrow>
    <msub>
     <mrow><mi>i</mi>
     </mrow>
     <mrow>
      <mrow><mi>b</mi><mi>a</mi><mi>s</mi>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </msub>
 </mrow></math>: la caisse se situe sur la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> et vient du <strong>bas</strong>.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-3475' />
Implicitement, la provenance de la caisse indique la position du pousseur. Celui-ci se situe sur l'emplacement précédent de la caisse et possède une certaine liberté de mouvements (la zone du pousseur). Lorsqu'il est impossible pour une caisse de joindre une position par une certaine direction, le sommet correspondant à cette direction n'est pas utilisé dans le graphe.
<br />

</div>

<div class="standard"><a id='magicparlabel-3476' />
Un arc <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mrow>
   <msub>
    <mrow><mi>S</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>i</mi>
      </mrow>
      <mrow>
       <mrow><mi>d</mi><mi>r</mi><mi>o</mi><mi>i</mi><mi>t</mi><mi>e</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>S</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>j</mi>
      </mrow>
      <mrow>
       <mrow><mi>h</mi><mi>a</mi><mi>u</mi><mi>t</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math>, où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>S</mi>
   </mrow>
   <mrow>
    <msub>
     <mrow><mi>i</mi>
     </mrow>
     <mrow>
      <mrow><mi>d</mi><mi>r</mi><mi>o</mi><mi>i</mi><mi>t</mi><mi>e</mi>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </msub>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>S</mi>
   </mrow>
   <mrow>
    <msub>
     <mrow><mi>j</mi>
     </mrow>
     <mrow>
      <mrow><mi>h</mi><mi>a</mi><mi>u</mi><mi>t</mi>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </msub>
 </mrow></math> sont deux sommets du graphe connexe, signifie que &ldquo;<em>Si la caisse est venue par la droite sur la position i, alors le pousseur est capable de pousser la caisse vers le bas sur la position j&rdquo;</em>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3477' />
Les arcs dans le graphe relient toujours deux sommets qui correspondent à des positions voisines. Deux sommets qui correspondent à la même position ou à des positions non voisines ne sont donc jamais reliés entre eux.
<br />

</div>

<div class="standard"><a id='magicparlabel-3478' />
La Figure <a href="#fig_dijkstra2noeuds">7.4</a> représente le graphe connexe amélioré obtenu en procédant comme indiqué. Pour une meilleure lisibilité, les sommets qui correspondent à une même position sont entourés par des cercles plus clairs. Ceux-ci ne sont pas à prendre en considération dans le graphe connexe. Même si le graphe connexe semble peu lisible à première vue, il est possible de transiter d'un sommet à l'autre en partant de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>s</mi>
   </mrow>
   <mrow><mn>0</mn>
   </mrow>
  </msub>
 </mrow></math> pour arriver à l'un des goals. L'important est de remarquer que le chemin emprunté sera plus long que sur la Figure <a href="#fig_dijkstra1noeuds">7.3</a> car les contraintes imposées par la position du pousseur ne permettent pas toujours le déplacement voulu.
<br />

</div>

<div class="standard"><a id='magicparlabel-3479' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3483' />
<img style='width:75%;' src='assets/master_thesis/43_Users_michael_Desktop_memoire_images_distance_dijkstranoeud2fin.png' alt='image: 43_Users_michael_Desktop_memoire_images_distance_dijkstranoeud2fin.png' />
 </div>

<div class="plain_layout"><a id='magicparlabel-3484' />
<div class='float-caption float-caption-figure'>Figure 7.4:<div class="plain_layout"><a id='magicparlabel-3488' />
<a id="fig_dijkstra2noeuds" />
Graphe connexe amélioré et estimations des caisses obtenues dans le niveau correspondant via l'algorithme de Dijkstra.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3489' />
Lorsque plusieurs sommets représentent une position de départ, l'algorithme de Dijkstra est appliqué sur chacun de ces sommets et la plus petite valeur obtenue est conservée. Ceci afin d'éviter une surestimation éventuelle de la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>x</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> dans des cas particuliers. Lorsque plusieurs sommets représentent une position d'arrivée, celui qui possède la valeur la plus petite sera conservé.</div>
<h4 class="subparagraph"><span class="subparagraph_label"></span> <a id='magicparlabel-3490' />
Implémentation
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3491' />
La construction du graphe se fait à l'aide de quatre tableaux <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>G</mi>
    </mrow>
    <mrow>
     <mrow><mi>d</mi><mi>r</mi><mi>o</mi><mi>i</mi><mi>t</mi><mi>e</mi>
     </mrow>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>G</mi>
    </mrow>
    <mrow>
     <mrow><mi>g</mi><mi>a</mi><mi>u</mi><mi>c</mi><mi>h</mi><mi>e</mi>
     </mrow>
    </mrow>
   </msub><mo>,</mo>
   <msub>
    <mrow><mi>G</mi>
    </mrow>
    <mrow>
     <mrow><mi>h</mi><mi>a</mi><mi>u</mi><mi>t</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>G</mi>
   </mrow>
   <mrow>
    <mrow><mi>b</mi><mi>a</mi><mi>s</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>. Chaque case de ces tableaux correspond à une position dans le niveau. Chaque tableau correspond à l'un des 4 sommets de la position. <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>G</mi>
    </mrow>
    <mrow>
     <mrow><mi>b</mi><mi>a</mi><mi>s</mi>
     </mrow>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo><mi>i</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo>
  </mrow>
 </mrow></math> représentera donc le sommet <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>S</mi>
   </mrow>
   <mrow>
    <msub>
     <mrow><mi>i</mi>
     </mrow>
     <mrow>
      <mrow><mi>b</mi><mi>a</mi><mi>s</mi>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </msub>
 </mrow></math> de notre graphe. L'algorithme de Dijkstra est adapté à cette structure particulière. Lorsque l'algorithme a terminé de s'exécuter sur les 4 tableaux, il suffit de récupérer la valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>m</mi><mi>i</mi><mi>n</mi>{
   <msub>
    <mrow><mi>G</mi>
    </mrow>
    <mrow>
     <mrow><mi>d</mi><mi>r</mi><mi>o</mi><mi>i</mi><mi>t</mi><mi>e</mi>
     </mrow>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo><mi>i</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo><mo>,</mo>
   <msub>
    <mrow><mi>G</mi>
    </mrow>
    <mrow>
     <mrow><mi>g</mi><mi>a</mi><mi>u</mi><mi>c</mi><mi>h</mi><mi>e</mi>
     </mrow>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo><mi>i</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo><mo>,</mo>
   <msub>
    <mrow><mi>G</mi>
    </mrow>
    <mrow>
     <mrow><mi>h</mi><mi>a</mi><mi>u</mi><mi>t</mi>
     </mrow>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo><mi>i</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo><mo>,</mo>
   <msub>
    <mrow><mi>G</mi>
    </mrow>
    <mrow>
     <mrow><mi>b</mi><mi>a</mi><mi>s</mi>
     </mrow>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo><mi>i</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo>}
  </mrow>
 </mrow></math> pour obtenir l'estimation de la caisse vers la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math>.</div>
<h4 class="subparagraph"><span class="subparagraph_label"></span> <a id='magicparlabel-3492' />
Complexité
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3493' />
L'algorithme de Dijkstra s'appuie sur l'utilisation d'une liste des sommets à traiter. Dans notre cas, il s'applique toujours sur des graphes connexes dont les arcs ont des poids unitaires. L'utilisation d'une file permet donc de toujours conserver le sommet de poids le plus faible en tête de liste. Avec une fonction d'extraction en complexité <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mn>1</mn><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, la complexité de l'algorithme est en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mrow><mi>S</mi><mo>+</mo><mi>A</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>S</mi>
 </mrow></math> représente le nombre de sommets et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> représente le nombre d'arcs. Sachant qu'il y a, au plus, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>4</mn><mi>n</mi>
  </mrow>
 </mrow></math> sommets<div class="foot"><span class="foot_label">1</span><div class="foot_inner"><div class="plain_layout"><a id='magicparlabel-3497' />
Chaque position est représentée par, au plus, 4 sommets.</div>
</div></div> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>16</mn><mi>n</mi>
  </mrow>
 </mrow></math> arcs<div class="foot"><span class="foot_label">2</span><div class="foot_inner"><div class="plain_layout"><a id='magicparlabel-3501' />
Chaque sommet est le point de départ de, au plus, 4 arcs.</div>
</div></div>, où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> est le nombre de positions internes du niveau, la complexité peut s'écrire <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mrow><mn>4</mn><mi>n</mi><mo>+</mo><mn>16</mn><mi>n</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mrow><mn>20</mn><mi>n</mi>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>. La complexité de l'algorithme de Dijkstra est donc linéaire sur le nombre de positions internes au niveau.
<br />

</div>

<div class="standard"><a id='magicparlabel-3502' />
Le parcours en largeur proposait de remplir l'entièreté de la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msup>
   <mrow><mi>n</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msup>
 </mrow></math> parcours. La solution basée sur Dijkstra permet de la remplir en seulement <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> itérations de l'algorithme. En effet, l'algorithme de Dijkstra permet de calculer les estimations de <em>toutes</em> les positions à partir d'une position de départ, contrairement au parcours en largeur qui ne permettait de calculer l'estimation de la caisse que vers une seule position à la fois. Il est donc possible de remplir une ligne de la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> en une seule itération de Dijkstra.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3503' />
Conclusion
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3504' />
Si <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> est le nombre de positions internes du niveau :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3509' />
Le parcours en largeur propose de calculer les estimations de toutes les positions internes à l'aide de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msup>
   <mrow><mi>n</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msup>
 </mrow></math> itérations d'un algorithme en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <msup>
    <mrow><mi>b</mi>
    </mrow>
    <mrow><mi>d</mi>
    </mrow>
   </msup><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>d</mi>
 </mrow></math>, la profondeur de l'arbre de recherche, dépend indirectement de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math>. La solution propose donc un temps exponentiel.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3510' />
L'algorithme de Dijkstra, appliqué sur un graphe connexe amélioré, permet de calculer les estimations de toutes les positions internes avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> itérations de l'algorithme qui est en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>. La solution propose donc une complexité quadratique <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <msup>
    <mrow><mi>n</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msup><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-3511' />
Comme les deux solutions permettent de compléter la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> avec les mêmes valeurs, il est préférable d'utiliser l'algorithme de Dijkstra qui possède une complexité moindre.</div>
<h2 class="section"><span class="section_label">7.2</span> <a id='magicparlabel-3512' />
Estimation totale</h2>
<div class="standard"><a id='magicparlabel-3513' />
L'<em>estimation totale</em> consiste à additionner intelligemment les estimations des caisses vers les goals pour trouver la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> la plus juste possible, tout en continuant à minorer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3514' />
La section précédente permet de construire une matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> de taille <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>N</mi><mo> &times; </mo><mi>N</mi>
  </mrow>
 </mrow></math> dans laquelle une case <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>M</mi>
   </mrow>
   <mrow>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>, où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>1</mn><mo> &le; </mo><mi>i</mi><mo>,</mo><mi>j</mi><mo> &le; </mo><mi>N</mi>
  </mrow>
 </mrow></math>, contient le nombre de poussées requises pour déplacer une caisse située sur la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> vers la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>j</mi>
 </mrow></math>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3515' />
Pour trouver la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> est un nœud de l'arbre de recherche, il faut commencer par récupérer un sous-ensemble de la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> correspondant aux positions des caisses et des goals présents dans le nœud actuel. L'objectif est donc de construire une matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>O</mi>
 </mrow></math> de taille <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>C</mi><mo> &times; </mo><mi>G</mi>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>C</mi>
 </mrow></math> est le nombre de caisses et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>G</mi>
 </mrow></math> est le nombre de goals avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>C</mi><mo> &le; </mo><mi>G</mi>
  </mrow>
 </mrow></math>. La case <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>O</mi>
   </mrow>
   <mrow>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>, où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>1</mn><mo> &le; </mo><mi>i</mi><mo> &le; </mo><mi>C</mi>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mn>1</mn><mo> &le; </mo><mi>j</mi><mo> &le; </mo><mi>G</mi>
  </mrow>
 </mrow></math>, contient le nombre de poussées requises pour déplacer la <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msup>
   <mrow><mi>i</mi>
   </mrow>
   <mrow>
    <mrow><mi>e</mi><mi>m</mi><mi>e</mi>
    </mrow>
   </mrow>
  </msup>
 </mrow></math> caisse vers le <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msup>
   <mrow><mi>j</mi>
   </mrow>
   <mrow>
    <mrow><mi>e</mi><mi>m</mi><mi>e</mi>
    </mrow>
   </mrow>
  </msup>
 </mrow></math>goal.
<br />

</div>

<div class="standard"><a id='magicparlabel-3516' />
La Figure <a href="#fig_matrice_O">7.5</a> représente un nœud ainsi que la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>O</mi>
 </mrow></math> correspondante. Pour être fidèle à la réalité, la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> utilisée pour créer la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>O</mi>
 </mrow></math> a été générée à l'aide de la méthode de la Section <a href="#sub_Distance_r__elle_avec">7.1.3</a> impliquant Dijkstra et le graphe amélioré. L'intersection entre la ligne <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>c</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math> et la colonne <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi>
   <msub><mrow />
    <mrow><mn>3</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> contient l'estimation requise pour positionner la caisse <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>c</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math> sur le goal <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>g</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3517' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3521' />
<img style='width:65%;' src='assets/master_thesis/44_Users_michael_Desktop_memoire_images_distance_modelebon2.png' alt='image: 44_Users_michael_Desktop_memoire_images_distance_modelebon2.png' />
 </div>

<div class="plain_layout"><a id='magicparlabel-3522' />
<div class='float-caption float-caption-figure'>Figure 7.5:<div class="plain_layout"><a id='magicparlabel-3526' />
<a id="fig_matrice_O" />
nœud (état) de l'arbre de recherche et la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>O</mi>
 </mrow></math> associée.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3527' />
Il est possible que certaines intersections contiennent la valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo>+</mo><mi> &infin; </mi>
  </mrow>
 </mrow></math>. C'est le cas lorsqu'une caisse ne peut pas atteindre un certain goal car elle se situe sur une position particulière comme un bord ou un coin. Par exemple, sur notre niveau de test, si une caisse se trouvait sur la position <em>F8</em>, elle ne pourrait se diriger que vers <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi>
   <msub><mrow />
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>. Ses estimations pour joindre les autres goals <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi>
   <msub><mrow />
    <mrow><mn>1</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi>
   <msub><mrow />
    <mrow><mn>3</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> seraient assignées à <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo>+</mo><mi> &infin; </mi>
  </mrow>
 </mrow></math>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3528' />
L'objectif de cette section consiste à trouver une association caisses-goals permettant de maximiser l'estimation totale. La difficulté réside dans le fait qu'il faut continuer à borner inférieurement <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> pour que la valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> soit admissible.
<br />

</div>
<h3 class="subsection"><span class="subsection_label">7.2.1</span> <a id='magicparlabel-3529' />
Goal le plus proche</h3>
<div class="standard"><a id='magicparlabel-3530' />
La solution la plus simple, mais également la moins efficace, consiste à associer chaque caisse à son goal le plus proche. Dans notre exemple, cela conduit à associer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>c</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math>avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi>
   <msub><mrow />
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>c</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math> avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi>
   <msub><mrow />
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>c</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math> avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi>
   <msub><mrow />
    <mrow><mn>3</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> pour un total de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>8</mn>
  </mrow>
 </mrow></math>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3531' />
Il est à souligner que, dans cette solution, deux caisses ont pour destination le même goal, ce qui s'avère impossible dans la pratique. Cette façon de procéder conserve la propriété d'admissibilité car les caisses se dirigent toujours vers le goal le plus proche, ce qui ne peut que minimiser ou égaler la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>.</div>
<h3 class="subsection"><span class="subsection_label">7.2.2</span> <a id='magicparlabel-3532' />
<a id="sub_Goal_le_plus" />
Goal le plus proche avec réservation</h3>
<div class="standard"><a id='magicparlabel-3533' />
Cette méthode améliore la précédente et permet d'éviter l'utilisation indésirable d'un même goal par plusieurs caisses. Elle permet de bloquer un goal lorsque celui-ci devient, pour la première fois, la destination de l'une des caisses. Les caisses restantes ont alors moins de possibilités de déplacements.
<br />

</div>

<div class="standard"><a id='magicparlabel-3534' />
L'application de cette méthode sur notre exemple (<em>cf.</em> Figure <a href="#fig_matrice_O">7.5</a>) conduit à associer :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3539' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>c</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math> avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi>
   <msub><mrow />
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> (goal 2 bloqué).</li>
<li class="itemize_item"><a id='magicparlabel-3540' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>c</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math> avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi>
   <msub><mrow />
    <mrow><mn>3</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> (goal 3 bloqué).</li>
<li class="itemize_item"><a id='magicparlabel-3541' />
<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>c</mi>
   </mrow>
   <mrow><mn>3</mn>
   </mrow>
  </msub>
 </mrow></math> avec <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi>
   <msub><mrow />
    <mrow><mn>1</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> .
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-3542' />
Ce qui nous mène à un total de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>3</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>=</mo><mn>15</mn>
  </mrow>
 </mrow></math>. Le problème de cette méthode est que le goal associé à la dernière caisse lui est imposé. Avec parfois une estimation excessive.
<br />

</div>

<div class="standard"><a id='magicparlabel-3543' />
Cette méthode ne conserve pas la propriété d'admissibilité car il existe des états pour lesquels <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>&gt;</mo>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>. L'un de ces états est illustré sur la Figure <a href="#fig_contreexemple">7.6</a>. Dans celui-ci, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>9</mn>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>11</mn>
  </mrow>
 </mrow></math>. Ceci est dû au fait que, pour minimiser l'estimation totale, il est plus intéressant de déplacer la caisse <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>c</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math> vers le goal le plus éloigné (<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>g</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math>) que vers le goal le plus proche (<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>g</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math>).
<br />

</div>

<div class="standard"><a id='magicparlabel-3544' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3548' />
<img style='width:65%;' src='assets/master_thesis/45_Users_michael_Desktop_memoire_images_distance_contreexemple.png' alt='image: 45_Users_michael_Desktop_memoire_images_distance_contreexemple.png' />
 </div>

<div class="plain_layout"><a id='magicparlabel-3549' />
<div class='float-caption float-caption-figure'>Figure 7.6:<div class="plain_layout"><a id='magicparlabel-3553' />
<a id="fig_contreexemple" />
nœud (état) de l'arbre de recherche et la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>O</mi>
 </mrow></math> associée.</div>
</div></div>
</div>

<h3 class="subsection"><span class="subsection_label">7.2.3</span> <a id='magicparlabel-3554' />
<a id="sub_hongrois" />
Association caisses-goals minimisant l'estimation totale</h3>
<div class="standard"><a id='magicparlabel-3555' />
Pour que la méthode puisse donner des résultats admissibles, il faut qu'elle soit capable de trouver une association entre les caisses et les goals, à l'aide de la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>O</mi>
 </mrow></math>, de manière à minimiser l'estimation totale. La matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>O</mi>
 </mrow></math>, qui contient les estimations des caisses vers chacun des goals, peut être représentée dans un graphe biparti tel qu'illustré sur la Figure <a href="#fig_graphe_biparti">7.7</a>. Chaque arête du graphe biparti possède un poids. L'arête qui relie la caisse <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> au goal <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>j</mi>
 </mrow></math> possède le poids relatif à la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>O</mi>
   </mrow>
   <mrow>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> de la matrice.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3559' />
<img style='width:35%;' src='assets/master_thesis/46_Users_michael_Desktop_memoire_images_distance_biparti2.png' alt='image: 46_Users_michael_Desktop_memoire_images_distance_biparti2.png' />
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img style='width:35%;' src='assets/master_thesis/47_Users_michael_Desktop_memoire_images_distance_biparti3.png' alt='image: 47_Users_michael_Desktop_memoire_images_distance_biparti3.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3560' />
<div class='float-caption float-caption-figure'>Figure 7.7:<div class="plain_layout"><a id='magicparlabel-3564' />
<a id="fig_graphe_biparti" />
Graphe biparti représentant la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>O</mi>
 </mrow></math> et une éventuelle couverture de poids minimum.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3565' />
Remarquons que nous obtenons là un problème typique d'assignation dans un graphe biparti complet pondéré. Le but est de trouver la couverture de poids minimum (<em>minimum weighted bipartite matching</em>) permettant de pousser chaque caisse sur son goal. Pour cette opération, un algorithme se présente à nous : la <em>méthode Hongroise</em>. Gardons à l'esprit que cet algorithme est en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mrow><mi>n</mi><mo>³</mo>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> représente le nombre de caissesFrank (<a href='#LyXCite-Munkres'>Pas d'année</a>). La puissance demandée pour ce traitement, à chaque nœud de l'arbre de recherche, représente une partie très gourmante de notre solveur.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3566' />
Implémentation
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3567' />
Pour ne pas devoir réimplémenter la méthode Hongroise à partir de rien, une version C++ existanteWeaver (<a href='#LyXCite-MunkresCode'>Pas d'année</a>), déjà déboguée et optimisée, a été intégrée à notre solveur. Nos données ont été adaptées pour correspondre aux contraintes des fonctions existantes.</div>
<h2 class="section"><span class="section_label">7.3</span> <a id='magicparlabel-3568' />
Méthodes utilisées</h2>
<div class="standard"><a id='magicparlabel-3569' />
Trois méthodes ont été présentées pour calculer l'estimation d'une caisse et trois méthodes ont été présentées pour calculer l'estimation totale. En théorie il y a donc neuf possibilités d'associations entre ces méthodes comme illustré sur la Figure <a href="#fig_association">7.8</a>. Dans la pratique, on peut directement éliminer la méthode de la Section <a href="#sub_Goal_le_plus">7.2.2</a> du goal le plus proche avec réservation car elle ne respecte pas la propriété d'admissibilité du parcours A*. Si une solution est trouvée, il ne sera donc pas possible d'affirmer que celle-ci est optimale.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3573' />
<img style='width:65%;' src='assets/master_thesis/48_Users_michael_Desktop_memoire_images_distance_association.png' alt='image: 48_Users_michael_Desktop_memoire_images_distance_association.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3574' />
<div class='float-caption float-caption-figure'>Figure 7.8:<div class="plain_layout"><a id='magicparlabel-3578' />
<a id="fig_association" />
Associations de méthodes possibles pour calculer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3579' />
Des six associations restantes possibles et qui sont admissibles, il est préférable de prendre celle qui maximise l'estimation de manière à être le plus proche de la valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>. Comme le démontre la Figure <a href="#fig_evolution">7.9</a>, c'est l'algorithme de Dijkstra avec graphe amélioré qui majore le plus l'estimation d'une caisse vers chacune des positions. C'est donc la méthode qui s'avère la plus efficace. Rien d'étonnant à cela, c'est la méthode qui prend en compte le plus de contraintes, dont la position du pousseur.
<br />

</div>

<div class="standard"><a id='magicparlabel-3580' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3584' />
<img style='width:80%;' src='assets/master_thesis/49_Users_michael_Desktop_memoire_images_distance_evolution.png' alt='image: 49_Users_michael_Desktop_memoire_images_distance_evolution.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3585' />
<div class='float-caption float-caption-figure'>Figure 7.9:<div class="plain_layout"><a id='magicparlabel-3589' />
<a id="fig_evolution" />
Différences des estimations d'une caisse vers toutes les positions, en fonction des méthodes appliquées</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3590' />
La méthode Hongroise, qui permet de trouver l'association entre les caisses et les goals qui minimise l'estimation totale, s'avère la plus coûteuse. Elle possède une complexité en <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <msup>
    <mrow><mi>n</mi>
    </mrow>
    <mrow><mn>3</mn>
    </mrow>
   </msup><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> est le nombre de caisses. Les estimations totales qu'elle obtient sont cependant nettement plus précises que celles obtenues par la méthode des goals les plus proches.
<br />

</div>

<div class="standard"><a id='magicparlabel-3591' />
Pour calculer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, nous allons donc trouver les estimations de chacune des positions (la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math>) par la méthode de <em>la distance réelle avec gestion du pousseur</em>. Ensuite, nous calculerons l'estimation totale à l'aide de l'<em>association caisses-goals minimisant l'estimation totale</em>.</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 8</span> <a id='magicparlabel-3592' />
<a id="cha_Deadlocks" />
Deadlock</h1>
<div class="standard"><a id='magicparlabel-3593' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-3594' />
</div>

<div class="standard"><a id='magicparlabel-3599' />
Sokoban est un jeu dans lequel nous pouvons être confrontés à ce que nous appelons des <em>deadlocks</em>.</div>

<div class="standard" style='text-align: center;'><a id='magicparlabel-3600' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3604' />
<strong>deadlock</strong> : état de l'arbre de recherche à partir duquel aucun état solution ne pourra être trouvé.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3605' />
De manière générale, un deadlock est provoqué par un sous-ensemble des caisses de l'état qui provoque une situation dans laquelle il est impossible de pousser toutes les caisses sur des goals.
<br />

</div>

<div class="standard"><a id='magicparlabel-3606' />
Si nous parcourons l'arbre de recherche en ignorant ces deadlocks, il est fort probable que nous obtenions un nombre très conséquent de sous-arbres condamnés à ne jamais aboutir à une solution. La taille de l'arbre va alors augmenter de manière importante. C'est pourquoi il existe plusieurs procédés afin d'éviter ce problème.</div>
<h2 class="section"><span class="section_label">8.1</span> <a id='magicparlabel-3607' />
<a id="sec_Deadlocks_1caisse" />
Deadlock à une caisse</h2>
<div class="standard"><a id='magicparlabel-3608' />
Le <em>deadlock à une caisse</em> est celui qui se produit le plus fréquemment. Il correspond à un cas particulier de deadlock provoqué par un sous-ensemble de caisses de l'état qui ne comprend qu'une seule caisse. Ceux-ci sont répartis en deux catégories : <em>deadlocks en coin</em> et <em>deadlocks en ligne</em>.</div>
<h3 class="subsection"><span class="subsection_label">8.1.1</span> <a id='magicparlabel-3609' />
Deadlock en coin</h3>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3610' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3614' />
<strong>deadlock en coin</strong> : deadlock provoqué par une caisse coincée sur une position qui n'est pas un goal et qui est cernée par deux murs de manière à former un coin.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3615' />
Un exemple de <em>deadlock en coin </em>est illustré sur la Figure <a href="#fig_Impasses____une">8.2</a>. Selon les règles du jeu, il parait clair que la caisse située sur la position absolue <em>D2</em> ne pourra pas rejoindre l'un des goals.
<br />

</div>

<div class="standard"><a id='magicparlabel-3616' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3620' />
<img style='width:35%;' src='assets/master_thesis/50_Users_michael_Desktop_memoire_images_1boxdeadlock.png' alt='image: 50_Users_michael_Desktop_memoire_images_1boxdeadlock.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3621' />
<div class='float-caption float-caption-figure'>Figure 8.1:<div class="plain_layout"><a id='magicparlabel-3625' />
<a id="fig_cornerdead" />
La caisse sur la position absolue <em>D2 </em>provoque un deadlock en coin</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3626' />
Pour détecter les positions qui provoquent des deadlocks en coin, nous parcourons toutes les positions internes d'un niveau afin de tester si elles sont bornées par des murs, sur deux côtés consécutifs, de manière à former un coin. Si tel est le cas, nous enregistrons une zone ne comprenant que les positions concernées comme illustré à l'aide de croix sur la Figure <a href="#fig_Impasses____une">8.2</a>. La zone sera utilisée par la suite afin de rejeter de l'arbre de recherche tous les états qui ont une caisse sur l'une des croix.</div>

<div class="standard"><a id='magicparlabel-3627' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3631' />
<img style='width:35%;' src='assets/master_thesis/51_Users_michael_Desktop_memoire_images_listedeadlocks.png' alt='image: 51_Users_michael_Desktop_memoire_images_listedeadlocks.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3632' />
<div class='float-caption float-caption-figure'>Figure 8.2:<div class="plain_layout"><a id='magicparlabel-3636' />
<a id="fig_Impasses____une" />
Positions qui provoquent un deadlock en coin si une caisse s'y trouve</div>
</div></div>
</div>

<h3 class="subsection"><span class="subsection_label">8.1.2</span> <a id='magicparlabel-3637' />
Deadlock en ligne</h3>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3638' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3642' />
<strong>deadlock en ligne</strong> : deadlock provoqué par une caisse qui se situe contre un mur et qui est incapable de s'en dégager pour se diriger vers un goal.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3643' />
Un exemple de <em>deadlock en ligne </em>est illustré sur la Figure <a href="#fig_dead_line">8.3</a>. Selon les règles du jeu, il parait clair que la caisse située sur la position absolue <em>C2</em> ne pourra pas s'écarter du mur pour rejoindre l'un des goals.
<br />

</div>

<div class="standard"><a id='magicparlabel-3644' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3648' />
<img style='width:35%;' src='assets/master_thesis/52_Users_michael_Desktop_memoire_images_1boxdeadlock2.png' alt='image: 52_Users_michael_Desktop_memoire_images_1boxdeadlock2.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3649' />
<div class='float-caption float-caption-figure'>Figure 8.3:<div class="plain_layout"><a id='magicparlabel-3653' />
<a id="fig_dead_line" />
La caisse sur la position absolue <em>C2 </em>provoque un deadlock en ligne</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3654' />
Les deadlocks en ligne sont provoqués par des murs qui ne possèdent pas de possibilité d'échappement, c'est-à-dire un passage par lequel le pousseur pourrait repousser la caisse dans l'autre sens. La méthode utilisée pour détecter les lignes problématiques consiste à utiliser les positions de deadlock en coin. En se servant de l'une de ces positions pour en joindre un deuxième via une ligne droite, si l'un des deux côtés de cette ligne droite est exclusivement formé de murs, alors nous pouvons considérer toutes les positions de cette ligne comme des deadlocks.
<br />

</div>

<div class="standard"><a id='magicparlabel-3655' />
Une fois tous les deadlocks en ligne trouvés, nous enregistrons une zone ne comprenant que les positions concernées comme illustré à l'aide de croix sur la Figure <a href="#fig_deadlinelist">8.4</a>. La zone sera utilisée par la suite afin de rejeter de l'arbre de recherche tous les états qui ont une caisse sur l'une des croix.</div>

<div class="standard"><a id='magicparlabel-3656' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3660' />
<img style='width:35%;' src='assets/master_thesis/53_Users_michael_Desktop_memoire_images_listedeadlocks3.png' alt='image: 53_Users_michael_Desktop_memoire_images_listedeadlocks3.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3661' />
<div class='float-caption float-caption-figure'>Figure 8.4:<div class="plain_layout"><a id='magicparlabel-3665' />
<a id="fig_deadlinelist" />
Positions trouvées à l'aide de la méthode de deadlock en ligne</div>
</div></div>
</div>

<h3 class="subsection"><span class="subsection_label">8.1.3</span> <a id='magicparlabel-3666' />
Implémentation</h3>
<div class="standard"><a id='magicparlabel-3667' />
Grâce à l'utilisation des zones, les deadlocks à une caisse sont rapidement évincés de l'arbre de recherche. L'idée consiste à créer une zone <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow>
    <mrow><mi>d</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> comprenant toutes les positions pour lesquelles l'état sera déclaré comme un deadlock si une caisse s'y trouve. Une telle zone est illustrée sur la Figure <a href="#fig_deadsummary">8.5</a>.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3671' />
<img style='width:35%;' src='assets/master_thesis/54_Users_michael_Desktop_memoire_images_listedeadlocks2.png' alt='image: 54_Users_michael_Desktop_memoire_images_listedeadlocks2.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3672' />
<div class='float-caption float-caption-figure'>Figure 8.5:<div class="plain_layout"><a id='magicparlabel-3676' />
<a id="fig_deadsummary" />
Ensemble des positions qui provoquent des deadlocks à une caisse. Il ne reste que 4 positions sur lesquelles une caisse peut se déplacer.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3677' />
Posons <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow>
    <msub>
     <mrow><mi>z</mi>
     </mrow>
     <mrow>
      <mrow><mi>c</mi><mi>a</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>s</mi>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </msub>
 </mrow></math> la zone des caisses d'un état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>e</mi>
 </mrow></math>. La méthode consiste à tester, pour chaque nouvel état rencontré lors du parcours de l'arbre de recherche, l'affirmation <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>e</mi>
    </mrow>
    <mrow>
     <msub>
      <mrow><mi>z</mi>
      </mrow>
      <mrow>
       <mrow><mi>c</mi><mi>a</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>s</mi>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </msub><mo> &cap; </mo>
   <msub>
    <mrow><mi>z</mi>
    </mrow>
    <mrow>
     <mrow><mi>d</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi>
     </mrow>
    </mrow>
   </msub><mo>=</mo><mn>0</mn>
  </mrow>
 </mrow></math>. Si l'affirmation est vraie, alors l'état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>e</mi>
 </mrow></math> ne possède pas de deadlock à une caisse. Si l'affirmation est fausse, cela signifie qu'une caisse de l'état en cours se situe sur une position de deadlock et l'état est alors rejeté.</div>
<h2 class="section"><span class="section_label">8.2</span> <a id='magicparlabel-3678' />
Deadlock à plusieurs caisses</h2>
<div class="standard"><a id='magicparlabel-3679' />
Le <em>deadlock à plusieurs caisses</em> correspond à un cas particulier de deadlock provoqué par un sous-ensemble de caisses de l'état qui comprend plusieurs caisses. Ce type de deadlock est réparti en plusieurs catégories en fonction de la technique utilisée pour la détection.</div>
<h3 class="subsection"><span class="subsection_label">8.2.1</span> <a id='magicparlabel-3680' />
Dernière poussée</h3>
<div class="standard"><a id='magicparlabel-3681' />
Un type de deadlock à plusieurs caisses facile à détecter est celui induit par la <em>dernière</em> <em>poussée</em>. Il existe des situations dans lesquelles des caisses se gênent mutuellement de manière à ce qu'aucune d'entre elles ne puisse plus bouger. La méthode la plus simple pour détecter ces situations est de tester la nouvelle position de la dernière caisse poussée.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3682' />
Deadlock en carré</h4>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3683' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3687' />
<strong>deadlock en carré</strong> : deadlock provoqué lorsque la dernière caisse poussée forme un carré composé de caisses et de murs avec trois de ses positions voisines.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3688' />
Comme il est impossible pour le pousseur de pousser une caisse si la position derrière celle-ci n'est pas libre, un <em>deadlock en carré </em>provoque une situation dans laquelle aucune des caisses du carré ne pourra être dégagée. À moins que les caisses présentes dans le carré ne soient toutes sur des goals, l'état courant sera alors un deadlock et rejeté de l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3689' />
La caisse qui vient d'être poussée sur la position absolue <em>H9 </em>de la Figure <a href="#fig_deadcarre">8.6</a> provoque un deadlock en carré avec les trois autres positions <em>G8</em>, <em>G9</em> et <em>H8</em>.</div>

<div class="standard"><a id='magicparlabel-3690' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3694' />
<img style='width:50%;' src='assets/master_thesis/55_Users_michael_Desktop_memoire_images_deadlockcarre.png' alt='image: 55_Users_michael_Desktop_memoire_images_deadlockcarre.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3695' />
<div class='float-caption float-caption-figure'>Figure 8.6:<div class="plain_layout"><a id='magicparlabel-3699' />
<a id="fig_deadcarre" />
deadlock en carré induit par la dernière poussée</div>
</div></div>
</div>

<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3700' />
Deadlock en Z</h4>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3701' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3705' />
<strong>deadlock en Z</strong> : proche du deadlock en carré, il se produit lorsque la dernière caisse poussée forme une situation précise dans laquelle deux caisses sont alignées et ne peuvent plus bouger pour rejoindre un goal à cause des murs avoisinants.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3706' />
Le <em>deadlock en Z</em> est décliné en 4 versions qui sont représentées sur la Figure <a href="#fig_deadZ">8.7</a>.</div>

<div class="standard"><a id='magicparlabel-3707' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3711' />
<img style='width:11%;' src='assets/master_thesis/56_Users_michael_Desktop_memoire_images_deadlockz1.png' alt='image: 56_Users_michael_Desktop_memoire_images_deadlockz1.png' />
&nbsp;&nbsp;&nbsp;<img style='width:11%;' src='assets/master_thesis/57_Users_michael_Desktop_memoire_images_deadlockz2.png' alt='image: 57_Users_michael_Desktop_memoire_images_deadlockz2.png' />
&nbsp;&nbsp;&nbsp;<img style='width:15%;' src='assets/master_thesis/58_Users_michael_Desktop_memoire_images_deadlockz3.png' alt='image: 58_Users_michael_Desktop_memoire_images_deadlockz3.png' />
&nbsp;&nbsp;&nbsp;<img style='width:15%;' src='assets/master_thesis/59_Users_michael_Desktop_memoire_images_deadlockz4.png' alt='image: 59_Users_michael_Desktop_memoire_images_deadlockz4.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3712' />
<div class='float-caption float-caption-figure'>Figure 8.7:<div class="plain_layout"><a id='magicparlabel-3716' />
<a id="fig_deadZ" />
Les 4 situations qui provoquent un deadlock en Z</div>
</div></div>
</div>

<h3 class="subsection"><span class="subsection_label">8.2.2</span> <a id='magicparlabel-3717' />
<a id="sub_Deadlock_Zone" />
Deadlock Zone</h3>
<div class="standard"><a id='magicparlabel-3718' />
La méthode de la <em>deadlock zone</em> a été conçue en regardant le solveur s'exécuter sur certains niveaux. Il apparaissait régulièrement que certaines caisses n'évoluaient plus dans l'un des sous-arbres de l'arbre de recherche, alors que toutes les autres caisses continuaient de bouger. En analysant la situation, le phénomène était compréhensible car, peu importe la façon dont il aurait été possible de pousser l'une des caisses bloquées, elle introduisait toujours un deadlock. L'état courant n'était donc pas reconnu comme un deadlock mais il n'était pas possible de dégager l'une des caisses bloquées sans en provoquer un. La Figure <a href="#fig_deadlock_zone">8.8</a> montre cette situation par les deux caisses bloquées situées sur les positions absolues <em>C3</em> et <em>D3</em>. Il n'est pas possible de bouger l'une de ces caisses sans provoquer de deadlock en coin.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3722' />
<img style='width:35%;' src='assets/master_thesis/60_Users_michael_Desktop_memoire_images_deadlockzone.png' alt='image: 60_Users_michael_Desktop_memoire_images_deadlockzone.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3723' />
<div class='float-caption float-caption-figure'>Figure 8.8:<div class="plain_layout"><a id='magicparlabel-3727' />
<a id="fig_deadlock_zone" />
La zone formée par les positions absolues <em>C2</em>, <em>C3</em>, <em>D2</em> et <em>D3</em> est une deadlock zone.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3728' />
La méthode proposée a donc pour objectif de découvrir les sous-ensembles de caisses qui ne provoquent pas directement de deadlock mais qui ne peuvent pas être poussées sans en provoquer un. De manière générale, les caisses qui sont bloquées entourent, avec des murs, un certain nombre de positions vides. Le fonctionnement de la méthode consiste à détecter des positions vides dont les caisses limitrophes sont toutes bloquées. On appellera ces positions et ces caisses bloquées une deadlock zone<em>. </em>La<em> </em>Figure <a href="#fig_3deadlocks">8.9</a> indique trois de ces deadlock zones.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3732' />
<img style='width:50%;' src='assets/master_thesis/61_Users_michael_Desktop_memoire_images_exemplesdeadlockzone.png' alt='image: 61_Users_michael_Desktop_memoire_images_exemplesdeadlockzone.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3733' />
<div class='float-caption float-caption-figure'>Figure 8.9:<div class="plain_layout"><a id='magicparlabel-3737' />
<a id="fig_3deadlocks" />
État d'un niveau qui provoque 3 deadlock zones</div>
</div></div>
</div>


<div class="standard" style='text-align: center;'><a id='magicparlabel-3738' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3742' />
<strong>deadlock zone</strong> : ensemble de positions construit comme une zone du pousseur telle que définie dans la Section <a href="#sec___tat">5.2</a> mais en admettant que la construction ne débute pas de la position du pousseur mais d'une position quelconque de l'état.
<br />

</div>

<div class="plain_layout"><a id='magicparlabel-3743' />
Pour que la zone ainsi construite soit considérée comme une deadlock zone, il faut que les positions comprises dans cette zone :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3744' />
ne contiennent pas de goal.</li>
<li class="itemize_item"><a id='magicparlabel-3745' />
ne contiennent pas de positions en commun avec celles de la zone du pousseur de l'état.</li>
<li class="itemize_item"><a id='magicparlabel-3746' />
contiennent uniquement des <em>caisses bloquées</em>.
<br />

</li>
</ul>
<div class="plain_layout"><a id='magicparlabel-3747' />
<strong>caisse bloquée</strong>: caisse que le pousseur ne pourra pousser que vers une situation de deadlock.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3748' />
De manière générale, la méthode de la deadlock zone est assez coûteuse mais permet de détecter des situations de deadlock éventuellement provoquées par un grand nombre de caisses (<em>cf. </em>Figure <a href="#fig_granddeadlocks">8.10</a>). Cette méthode vérifie, pour chaque état, que celui-ci ne contient pas une deadlock zone. Si un état en contient une, alors il est rejeté de l'arbre de recherche.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3752' />
<img style='width:45%;' src='assets/master_thesis/62_Users_michael_Desktop_memoire_images_grandedeadlockzone.png' alt='image: 62_Users_michael_Desktop_memoire_images_grandedeadlockzone.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3753' />
<div class='float-caption float-caption-figure'>Figure 8.10:<div class="plain_layout"><a id='magicparlabel-3757' />
<a id="fig_granddeadlocks" />
État d'un niveau qui provoque une deadlock zone composée de 6 caisses</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3758' />
L'aspect le plus intéressant de cette méthode est qu'elle est récursive. En effet, lorsqu'on teste si une caisse est bloquée, on teste ses déplacements possibles et on regarde si ceux-ci provoquent, ou non, un deadlock. Toutes les techniques de détection de deadlock, y compris celle de la deadlock zone, sont donc à nouveau appliquées sur l'état induit par la poussée de la caisse. Cette capacité à fonctionner récursivement permet d'anticiper des situations de deadlock plusieurs poussées avant qu'elles ne se produisent (<em>cf.</em> Figure <a href="#fig_deadschema">8.11</a>).
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3762' />
<img style='width:75%;' src='assets/master_thesis/63_Users_michael_Desktop_memoire_images_deadlockzone_schema.png' alt='image: 63_Users_michael_Desktop_memoire_images_deadlockzone_schema.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3763' />
<div class='float-caption float-caption-figure'>Figure 8.11:<div class="plain_layout"><a id='magicparlabel-3767' />
<a id="fig_deadschema" />
La deadlock zone du premier état est testée récursivement et validée par un deadlock en carré</div>
</div></div>
</div>

<h3 class="subsection"><span class="subsection_label">8.2.3</span> <a id='magicparlabel-3768' />
<a id="sub_Deadlock_m__thodique" />
Deadlock méthodique</h3>
<div class="standard"><a id='magicparlabel-3769' />
Rappelons-nous la définition d'un deadlock : &ldquo;<em>un deadlock est un état de l'arbre de recherche à partir duquel il est impossible de trouver un état solution</em>&rdquo;. Un deadlock est souvent provoqué par un <em>sous-état</em> de l'état testé. Il dépend donc des positions des caisses et de celle du pousseur. On peut d'ailleurs remarquer sur la Figure <a href="#fig_Etat_d_un_niveau">8.12</a> qu'un deadlock ne serait pas détecté si le pousseur occupait la position <em>D12</em>.</div>

<div class="standard" style='text-align: center;'><a id='magicparlabel-3770' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3774' />
<strong>sous-état</strong> : un sous-état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>s</mi>
 </mrow></math> d'un état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>e</mi>
 </mrow></math> est un état pour lequel on peut affirmer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>s</mi><mo> &isin; </mo><mi>e</mi>
  </mrow>
 </mrow></math> tel que nous l'avons défini dans la Section <a href="#sub_Op__rations">5.5.4</a>.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3775' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3779' />
<img style='width:40%;' src='assets/master_thesis/64_Users_michael_Desktop_memoire_images_etat.png' alt='image: 64_Users_michael_Desktop_memoire_images_etat.png' />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img style='width:40%;' src='assets/master_thesis/65_Users_michael_Desktop_memoire_images_sousetat.png' alt='image: 65_Users_michael_Desktop_memoire_images_sousetat.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3780' />
<div class='float-caption float-caption-figure'>Figure 8.12:<div class="plain_layout"><a id='magicparlabel-3784' />
<a id="fig_Etat_d_un_niveau" />
État d'un niveau dont l'un des sous-états provoque un deadlock.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3785' />
Le <em>deadlock méthodique</em> consiste à tester un sous-état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>s</mi>
 </mrow></math> pour voir s'il provoque, ou non, un deadlock. Cette méthode n'utilise que des outils qui sont déjà en notre possession. Elle consiste à appliquer le solveur sur ce sous-état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>s</mi>
 </mrow></math> et à observer si une solution est possible ou si l'arbre de recherche ne peut jamais aboutir à une solution. Si le sous-état ne comprend pas trop de caisses, la présence d'une solution devrait être rapidement vérifiée.
<br />

</div>

<div class="standard"><a id='magicparlabel-3786' />
Dans le cas où le sous-état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>s</mi>
 </mrow></math> provoque un deadlock, celui-ci sera enregistré et, par la suite, tous les états de l'arbre de recherche qui le contiennent seront rejetés.
<br />

</div>

<div class="standard"><a id='magicparlabel-3787' />
Le solveur utilisé pour tester les sous-états ne doit pas forcément être optimal. Il doit surtout être rapide car nous ne cherchons pas une solution mais simplement la présence ou l'absence d'une solution. C'est pour cela qu'une version modifiée de notre solveur, que nous appellerons <em>goodPushes</em><div class="foot"><span class="foot_label">1</span><div class="foot_inner"><div class="plain_layout"><a id='magicparlabel-3791' />
Par opposition à <em>BestPushes</em>, notre solveur optimal</div>
</div></div>, a été utilisée. Ce solveur utilise le même principe que le parcours A* avec l'utilisation comme coût de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>+</mo><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>. La différence est que cette fois-ci, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est fixé à 0. Il ne prend donc en compte que la distance entre un état donné et l'état solution, ce qui a l'avantage d'aboutir très vite à un résultat qui ne sera pas forcément optimal.
<br />

</div>

<div class="standard"><a id='magicparlabel-3792' />
L'intérêt du deadlock méthodique est qu'il sert de <em>soutien</em> aux autres méthodes de deadlock. En effet, il est programmé pour ne pas prendre en compte les sous-états déjà bloqués par les autres méthodes pour limiter le nombre de sous-états à stocker en mémoire.
<br />

</div>

<div class="standard"><a id='magicparlabel-3793' />
Il existe deux méthodes pour rechercher les deadlocks : la <em>recherche passive</em> et la <em>recherche active</em>.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3794' />
Recherche passive
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3795' />
La <em>recherche passive</em> consiste à créer, à partir d'un niveau, tous les états possibles de 1 caisse, 2 caisses, 3 caisses ou plus. Le solveur <em>goodPushes</em> est ensuite exécuté sur chacun de ces états et ceux-ci sont enregistrés lorsqu'un deadlock est détecté. Tous les états ainsi créés sont potentiellement des sous-états qui pourraient apparaître dans l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3796' />
En fonction de la taille des niveaux, il sera parfois difficile de trouver les deadlocks de 3 caisses et plus à cause du temps de calcul. La méthode reste néanmoins très intéressante car moins un sous-état contient de caisses et plus il a de chance d'être inclus dans un état de l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3797' />
Nous verrons que la recherche passive de deadlocks est un cas particulier de la recherche passive de pénalités. La Section <a href="#sub_penalpassive">9.2.1</a> décrit plus en profondeur la technique employée pour créer les états à 1, 2 ou 3 caisses.</div>
<h4 class="paragraph"><span class="paragraph_label"></span> <a id='magicparlabel-3798' />
Recherche active
<br />


<br />

</h4>
<div class="standard"><a id='magicparlabel-3799' />
La <em>recherche active</em> part du principe que la recherche passive est trop générale car elle teste des sous-états sans pouvoir affirmer qu'ils seront présents dans l'arbre de recherche. La technique employée ici consiste à essayer de détecter des sous-états qui pourraient provoquer des deadlocks dans chaque état rencontré dans l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3800' />
En fonction de la limite de puissance allouée à chaque état rencontré, il est possible de créer <em>sur mesure</em> des sous-états de plus de 3 caisses qui sont inclus dans l'état en cours. L'effort est ainsi dirigé vers les caisses présentes, ce qui permet d'augmenter la probabilité de trouver un deadlock utile.
<br />

</div>

<div class="standard"><a id='magicparlabel-3801' />
Comme la recherche passive, la recherche active de deadlocks est un cas particulier de la recherche active de pénalités. La Section <a href="#sub_penalactive">9.2.2</a> explique comment créer des sous-états à tester à partir d'un état de l'arbre de recherche.</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 9</span> <a id='magicparlabel-3802' />
<a id="cha_P__nalit__" />
Pénalité</h1>
<div class="standard"><a id='magicparlabel-3803' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-3804' />
</div>

<div class="standard"><a id='magicparlabel-3809' />
Ce chapitre décrit une technique utilisée pour affiner l'estimation <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> d'un nœud dans l'arbre de recherche. Pour rappel, plus l'estimation de la distance restante est proche de la distance réelle <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, plus l'arbre de recherche sera petit et plus vite une solution optimale sera trouvée.
<br />

</div>

<div class="standard"><a id='magicparlabel-3810' />
Les techniques développées dans le Chapitre <a href="#cha_Estimation">7</a> permettent d'obtenir une estimation <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> en fonction des positions des caisses et des goals dans le nœud. Rien dans ces techniques ne permet de mettre en évidence le surcoût occasionné lorsque plusieurs caisses se gênent mutuellement.
<br />

</div>

<div class="standard"><a id='magicparlabel-3811' />
Le cas d'un sous-état contenant des caisses qui se gênent mutuellement, illustré sur la Figure <a href="#fig_penalite1">9.1</a>, n'est pourtant pas rare. À partir des méthodes d'estimation décrites précédemment, on obtient pour ce sous-état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>20</mn>
  </mrow>
 </mrow></math>. Dans les faits cependant, on voit directement que la caisse située sur la position absolue <em>H9</em> ne pourra pas être atteinte par le pousseur sans qu'il ne commence par pousser la caisse située en<em> H6</em> vers le bas. Ce mouvement supplémentaire donnera au final <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>22</mn>
  </mrow>
 </mrow></math>. La différence entre l'estimation et le coût réel est donc de 2.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3815' />
<img style='width:65%;' src='assets/master_thesis/66_Users_michael_Desktop_memoire_images_penalite_penalite1.png' alt='image: 66_Users_michael_Desktop_memoire_images_penalite_penalite1.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3816' />
<div class='float-caption float-caption-figure'>Figure 9.1:<div class="plain_layout"><a id='magicparlabel-3820' />
<a id="fig_penalite1" />
Sous-état d'un niveau qui provoque une pénalité de 2.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3821' />
Cette différence entre coût estimé et coût réel du sous-état, que nous appellerons <em>pénalité d'un sous-état</em>, devra s'appliquer dans tous les états dans lesquels ce sous-état est inclus. La <em>pénalité déduite d'un état</em> <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>e</mi>
 </mrow></math> comprend l'application des pénalités (<em>cf</em>. Section <a href="#sec_Application">9.4</a>) de tous les sous-états <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>s</mi>
   <msub><mrow />
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo>,</mo><mspace width="6px" /><mi>s</mi>
   <msub><mrow />
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo>,</mo><mspace width="6px" />
   <mi>&hellip;
   </mi><mo>,</mo><mspace width="6px" /><mi>s</mi>
   <msub><mrow />
    <mrow><mi>n</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> tels que <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>s</mi>
   <msub><mrow />
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo> &isin; </mo><mi>e</mi><mo>,</mo><mspace width="6px" /><mi>s</mi>
   <msub><mrow />
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo> &isin; </mo><mi>e</mi><mo>,</mo><mspace width="6px" />
   <mi>&hellip;
   </mi><mo>,</mo><mspace width="6px" /><mi>s</mi>
   <msub><mrow />
    <mrow><mi>n</mi>
    </mrow>
   </msub><mo> &isin; </mo><mi>e</mi>
  </mrow>
 </mrow></math>. Contrairement à la pénalité d'un sous-état, la pénalité déduite d'un état n'est pas toujours la différence exacte entre le coût estimé et le coût réel, ce n'est qu'une meilleure approche de la valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math></div>
<h2 class="section"><span class="section_label">9.1</span> <a id='magicparlabel-3822' />
Définition</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-3823' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3827' />
<strong>pénalité d'un (sous-)état</strong> : différence entre le coût estimé <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> et le coût réel <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> pour un certain (sous-)état.</div>

<div class="plain_layout"><a id='magicparlabel-3828' />
<strong>pénalité déduite d'un état </strong>: valeur ajoutée à l'estimation d'un état par l'application des pénalités des sous-états compris dans celui-ci. La pénalité déduite ne correspond pas toujours à la différence exacte entre le coût estimé et le coût réel.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3829' />
À partir d'un niveau, nous allons donc essayer de trouver un maximum de sous-états qui contiennent des pénalités. Ceux-ci vont nous aider à trouver les pénalités déduites des états de l'arbre de recherche afin d'améliorer leurs estimations de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3830' />
Cette technique est une généralisation de celle des deadlocks méthodiques (<em>cf</em>. Section <a href="#sub_Deadlock_m__thodique">8.2.3</a>). En effet, un sous-état qui provoque un deadlock peut être considéré comme un sous-état dont la pénalité est infinie. L'état qui comprend ce sous-état aura alors une pénalité déduite infinie et une valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mi> &infin; </mi>
  </mrow>
 </mrow></math>. Le coût du nœud contenant l'état va alors provoquer son rejet de l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3831' />
L'objectif est de rechercher des pénalités de sous-états qui ne sont pas nulles et donc des sous-états pour lesquels <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
   <mrow>
    <mrow><mo> &ssetmn; </mo>
    </mrow><mo>=</mo>
   </mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>. Plus le nombre de sous-états trouvés sera grand et plus les coûts des nœuds de l'arbre de recherche auront la possibilité d'être précis.
<br />

</div>

<div class="standard"><a id='magicparlabel-3832' />
Cette recherche de sous-états pénalisés n'est pas une chose aisée pour deux raisons :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3837' />
Il faut trouver les sous-états qui apporteront une pénalité parmi un nombre très important de possibilités différentes. Nous verrons dans la Section <a href="#sec_Recherche">9.2</a> comment rechercher efficacement.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3838' />
Il faut pouvoir affirmer que la différence entre l'estimation de la distance <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> du sous-état et sa distance réelle <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> s'applique bien pour positionner les caisses présentes sur tous les sous-ensembles possibles de goals. Nous verrons dans la Section <a href="#sec_Validation">9.3</a> comment une pénalité trouvée doit être validée avant de pouvoir être appliquée sur un état.</li>
</ul>
<h2 class="section"><span class="section_label">9.2</span> <a id='magicparlabel-3839' />
<a id="sec_Recherche" />
Recherche</h2>
<div class="standard"><a id='magicparlabel-3840' />
Tout comme la méthode des deadlocks méthodiques, la recherche de sous-états potentiellement pénalisés s'effectue de deux façons : <em>passivement</em> et <em>activement</em>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3841' />
Pour vérifier qu'un sous-état provoque une pénalité, nous créons un niveau contenant les caisses du sous-état ainsi que tous les goals et nous appliquons le solveur <em>bestPushes</em> avec une limite <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow>
     <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
     </mrow>
    </mrow>
   </msub><mo>=</mo><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est l'estimation actuelle du sous-état testé. En appliquant un solveur optimal avec une limite fixée de poussées, nous avons deux possibilités :
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-3842' />
<strong>Une solution est trouvée</strong> : la limite <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> introduite correspond à la distance exacte entre le nœud initial et le nœud solution. L'estimation actuelle du sous-état correspond donc à la distance réelle. Aucune pénalité ne doit être assignée au sous-état.
<br />

</li>
<li class="enumerate_item"><a id='magicparlabel-3843' />
<strong>Aucune solution n'est trouvée</strong> : la limite <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> introduite est plus petite que la distance exacte entre l'état initial et le nœud solution. Cela signifie que l'estimation actuelle du sous-état ne correspond pas à la distance réelle. Selon le résultat de la validation (<em>cf</em>. Section <a href="#sec_Validation">9.3</a>), le sous-état va alors être pénalisé.</li>
</ol>
<h3 class="subsection"><span class="subsection_label">9.2.1</span> <a id='magicparlabel-3844' />
<a id="sub_penalpassive" />
Recherche passive</h3>
<div class="standard"><a id='magicparlabel-3845' />
La <em>recherche passive</em> consiste à créer, à partir d'un niveau, tous les états possibles de 1 caisse, 2 caisses, 3 caisses ou plus. Le solveur optimal <em>bestPushes</em> est ensuite exécuté sur chacun de ces états avec une limite <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>f</mi>
    </mrow>
    <mrow>
     <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
     </mrow>
    </mrow>
   </msub><mo>=</mo><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> où <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est l'estimation actuelle de l'état testé. Lorsqu'une pénalité est détectée et validée pour un état, celle-ci est alors enregistrée.
<br />

</div>

<div class="standard"><a id='magicparlabel-3846' />
Pour tester tous les états possibles de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>c</mi>
 </mrow></math> caisses dans un niveau qui comprend <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>p</mi>
 </mrow></math> positions internes, il faut faire évoluer les caisses sur les positions selon les règles suivantes :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3847' />
Au départ, Les caisses occupent les <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>c</mi>
 </mrow></math> premières positions internes du niveau.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3848' />
Pour créer chaque nouvel état, la technique consiste à avancer d'une position la caisse qui sait encore avancer et qui est sur la position la plus grande. Si une caisse avance sur la position <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> et que <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>j</mi>
 </mrow></math> autres caisses sont sur des positions plus grandes, celles-ci seront déplacées sur les positions <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo>,</mo>
   <mi>&hellip;
   </mi><mo>,</mo><mi>i</mi><mo>+</mo><mi>j</mi>
  </mrow>
 </mrow></math> avant le prochain déplacement.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3849' />
La création de tous les états de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>c</mi>
 </mrow></math> caisses s'arrête lorsque les positions <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>p</mi><mo>,</mo><mi>p</mi><mo>-</mo><mn>1</mn><mo>,</mo>
   <mi>&hellip;
   </mi><mo>,</mo><mi>p</mi><mo>-</mo><mi>c</mi>
  </mrow>
 </mrow></math> sont toutes occupées par des caisses.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-3850' />
Lorsque tous les états de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>c</mi>
 </mrow></math> caisses ont été créés et testés, on incrémente le nombre de caisses jusqu'à la limite désirée et on recommence ces manipulations.
<br />

</div>

<div class="standard"><a id='magicparlabel-3851' />
La zone des caisses de chaque état sera ainsi créée à partir des positions des caisses obtenues par ce procédé. Il faut ensuite chercher toutes les zones du pousseur possibles à partir de chaque zone des caisses. Pour chaque couple possible (<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow>
    <mrow><mi>c</mi><mi>a</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>s</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>z</mi>
   </mrow>
   <mrow>
    <mrow><mi>p</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>u</mi><mi>r</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>) tel qu'illustré sur la Figure <a href="#fig_passive">9.2</a>, un état sera créé et testé. La position du pousseur dans le niveau transmis au solveur <em>bestPushes</em> n'a que peu d'importance tant qu'elle se situe bien dans la zone du pousseur trouvée. Dans notre exemple, le pousseur se situe chaque fois sur la première position relative à la zone du pousseur à tester.</div>

<div class="standard"><a id='magicparlabel-3852' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3856' />
<img style='width:35%;' src='assets/master_thesis/67_Users_michael_Desktop_memoire_images_passive_screen1.png' alt='image: 67_Users_michael_Desktop_memoire_images_passive_screen1.png' />
&nbsp;&nbsp;&nbsp;&nbsp;<img style='width:35%;' src='assets/master_thesis/68_Users_michael_Desktop_memoire_images_passive_screen2.png' alt='image: 68_Users_michael_Desktop_memoire_images_passive_screen2.png' />
</div>

<div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3857' />
<img style='width:35%;' src='assets/master_thesis/69_Users_michael_Desktop_memoire_images_passive_screen3.png' alt='image: 69_Users_michael_Desktop_memoire_images_passive_screen3.png' />
&nbsp;&nbsp;&nbsp;&nbsp;<img style='width:35%;' src='assets/master_thesis/70_Users_michael_Desktop_memoire_images_passive_screen4.png' alt='image: 70_Users_michael_Desktop_memoire_images_passive_screen4.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3858' />
<div class='float-caption float-caption-figure'>Figure 9.2:<div class="plain_layout"><a id='magicparlabel-3862' />
<a id="fig_passive" />
États à tester à partir des positions relatives des caisses 12, 14 et 34.</div>
</div></div>
</div>

<h3 class="subsection"><span class="subsection_label">9.2.2</span> <a id='magicparlabel-3863' />
<a id="sub_penalactive" />
Recherche active</h3>
<div class="standard"><a id='magicparlabel-3864' />
La <em>recherche active</em> part du principe que la recherche passive est trop générale car elle teste des sous-états sans pouvoir affirmer qu'ils seront présents dans l'arbre de recherche. La technique employée ici consiste à essayer de détecter des sous-états qui pourraient provoquer des pénalités dans chaque état rencontré dans l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3865' />
Il serait trop optimiste de tester dans un temps raisonnable tous les sous-états pouvant être formés à partir des caisses présentes dans l'état. Nous allons devoir utiliser des techniques pour obtenir en un temps minimum les sous-états qui ont le plus de chances de mener à des pénalités. La méthode employée s'inspire fortement de celle des <em>Pattern Search </em>développée par <em>Andreas Junghanns</em>Junghanns (<a href='#LyXCite-931399'>1999</a>).
<br />

</div>

<div class="standard"><a id='magicparlabel-3866' />
Le fonctionnement consiste à utiliser la dernière caisse poussée de l'état en cours. La première chose à faire est de rechercher la pénalité du sous-état correspondant à cette unique caisse et à la position du pousseur. À partir de la solution du niveau utilisée pour chercher la pénalité, on récupère deux éléments : le <em>chemin du pousseur </em>et le <em>chemin des caisses</em>.</div>

<div class="standard" style='text-align: center;'><a id='magicparlabel-3867' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3871' />
<strong>chemin du pousseur</strong> : à partir d'un niveau et de sa solution sous forme d'une série de déplacements du pousseur, on récupère la liste des positions sur lesquelles le pousseur est passé. On récupère également l'ordre dans lequel il est passé sur celles-ci.</div>

<div class="plain_layout"><a id='magicparlabel-3872' />
<strong>chemin des caisses </strong>: à partir d'un niveau et de sa solution sous forme d'une série de déplacements du pousseur, on récupère la liste des positions sur lesquelles au moins une caisse est passée. On récupère également l'ordre dans lequel elles ont été occupées.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3873' />
Ces deux chemins vont nous servir à décider quelle caisse sera la prochaine à ajouter à l'état dont on va rechercher la pénalité. Le principe est qu'on a plus de chance d'introduire une pénalité si on ajoute une caisse qui se trouve sur le chemin de la solution précédente.
<br />

</div>

<div class="standard"><a id='magicparlabel-3874' />
Pour savoir quelle caisse ajouter à partir des deux chemins, la règle est la suivante :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-3879' />
On insère d'abord les caisses présentes dans l'état en cours et qui se trouvent sur la plus petite position du chemin des caisses.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-3880' />
Lorsque toutes les caisses de l'état qui se trouvent sur le chemin des caisses ont été ajoutées, la caisse qui se trouve sur la plus petite position du chemin du pousseur sera à son tour ajoutée.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-3881' />
Nous allons ainsi introduire de nouvelles caisses jusqu'à ce que l'une des trois conditions suivantes soit remplie :
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-3882' />
Une pénalité est trouvée et enregistrée.</li>
<li class="enumerate_item"><a id='magicparlabel-3883' />
Toutes les caisses de l'état qui se trouvent sur l'un des chemins ont été ajoutées.</li>
<li class="enumerate_item"><a id='magicparlabel-3884' />
La recherche active des sous-états pénalisés d'un état est limitée par une certaine quantité de nœuds. Si cette quantité est dépassée pour un certain état, on arrête la recherche de sous-états pénalisés.
<br />

</li>
</ol>
<div class="standard"><a id='magicparlabel-3885' />
Pour illustrer cette méthode, nous avons repris l'exemple présenté dansJunghanns (<a href='#LyXCite-931399'>1999</a>) La Figure <a href="#fig_active1">9.3</a> correspond à une poussée. La recherche active va s'appliquer sur la caisse qui vient d'être poussée en créant plusieurs sous-états qui sont susceptibles de provoquer des pénalités comme illustré sur la Figure <a href="#fig_active2">9.4</a>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3886' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3890' />
<img style='width:35%;' src='assets/master_thesis/71_Users_michael_Desktop_memoire_images_active_avant.png' alt='image: 71_Users_michael_Desktop_memoire_images_active_avant.png' />
&nbsp;&nbsp;&nbsp;&nbsp;<img style='width:35%;' src='assets/master_thesis/72_Users_michael_Desktop_memoire_images_active_apres.png' alt='image: 72_Users_michael_Desktop_memoire_images_active_apres.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3891' />
<div class='float-caption float-caption-figure'>Figure 9.3:<div class="plain_layout"><a id='magicparlabel-3895' />
<a id="fig_active1" />
État de l'arbre de recherche avant et après une poussée.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3896' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3900' />
<img style='width:35%;' src='assets/master_thesis/73_Users_michael_Desktop_memoire_images_active_1.png' alt='image: 73_Users_michael_Desktop_memoire_images_active_1.png' />
&nbsp;&nbsp;&nbsp;&nbsp;<img style='width:35%;' src='assets/master_thesis/74_Users_michael_Desktop_memoire_images_active_2.png' alt='image: 74_Users_michael_Desktop_memoire_images_active_2.png' />
</div>

<div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3901' />
<img style='width:35%;' src='assets/master_thesis/75_Users_michael_Desktop_memoire_images_active_3.png' alt='image: 75_Users_michael_Desktop_memoire_images_active_3.png' />
&nbsp;&nbsp;&nbsp;&nbsp;<img style='width:35%;' src='assets/master_thesis/76_Users_michael_Desktop_memoire_images_active_4.png' alt='image: 76_Users_michael_Desktop_memoire_images_active_4.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3902' />
<div class='float-caption float-caption-figure'>Figure 9.4:<div class="plain_layout"><a id='magicparlabel-3906' />
<a id="fig_active2" />
Sous-états créés à partir de la dernière poussée et de la recherche active. Ils pourraient éventuellement être pénalisés.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3907' />
</div>

<div class="standard"><a id='magicparlabel-3908' />
Le chemin des caisses récupéré à partir de la solution du sous-état représenté en haut à gauche de la Figure <a href="#fig_active2">9.4</a> passe par les positions absolues <em>C6</em>, <em>C5</em>, <em>C4</em>, <em>C3</em>. On ajoute donc la caisse située sur la position <em>C5</em> dans le sous-état suivant. Pour le troisième sous-état représenté, on utilise le chemin du pousseur car aucune caisse ne se trouve plus sur le chemin des caisses.
<br />

</div>

<div class="standard"><a id='magicparlabel-3909' />
Le dernier sous-état est considéré comme un deadlock et possède donc une pénalité infinie. La recherche active s'arrête pour cet état (qui sera rejeté) et le sous-état pénalisé est enregistré. Celui-ci servira à déduire les pénalités d'autres états qui pourront être rencontrés dans la suite de l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3910' />
Nous pouvons remarquer que seulement trois des quatre caisses présentes dans le dernier sous-état provoquent un deadlock. La plus petite situation provoquant la pénalité sera recherchée lors de la validation qui est détaillée dans le chapitre suivant.</div>
<h2 class="section"><span class="section_label">9.3</span> <a id='magicparlabel-3911' />
<a id="sec_Validation" />
Validation</h2>
<div class="standard"><a id='magicparlabel-3912' />
La pénalité d'un sous-état doit pouvoir s'appliquer quel que soit le sous-ensemble de goals utilisé par les caisses. Si un sous-état possède une pénalité qui ne s'applique pas quel que soit le sous-ensemble de goals utilisé, cela signifie qu'il y a au moins une possibilité d'association caisses-goals pour que la pénalité provoque une majoration de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3913' />
Sur l'exemple de la Figure <a href="#fig_validationse">9.5</a>, on remarque que la différence entre le coût réel et le coût estimé est de 1. Une pénalité de 1 devrait donc être assignée à ce sous-état. Cependant, il existe un sous-ensemble de goals pour lequel l'estimation correspond bien au coût réel. Dans ce cas, la pénalité n'est pas validée car elle va majorer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> si la solution comprend les trois caisses positionnées sur les goals <em>F14</em>, <em>F15</em> et <em>K14</em>.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3917' />
<img style='width:35%;' src='assets/master_thesis/77_Users_michael_Desktop_memoire_images_penalite_validation.png' alt='image: 77_Users_michael_Desktop_memoire_images_penalite_validation.png' />
&nbsp;&nbsp;&nbsp;&nbsp;<img style='width:35%;' src='assets/master_thesis/78_Users_michael_Desktop_memoire_images_penalite_validation2.png' alt='image: 78_Users_michael_Desktop_memoire_images_penalite_validation2.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3918' />
<div class='float-caption float-caption-figure'>Figure 9.5:<div class="plain_layout"><a id='magicparlabel-3922' />
<a id="fig_validationse" />
Sous-état dont la pénalité devrait valoir 1. Celle-ci n'est pas validée à cause de l'un des sous-ensembles de goals pour lequel la pénalité ne s'applique pas.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3923' />
Si <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msup>
    <mrow><mi>h</mi>
    </mrow>
    <mrow><mo>*</mo>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est majoré pour un nœud de l'arbre, cela signifie que nous risquons de perdre l'optimalité de la solution. Pour éviter ce cas précis, chaque sous-état pénalisé doit être testé pour voir si il s'applique bien à tous les sous-ensembles de goals.
<br />

</div>

<div class="standard"><a id='magicparlabel-3924' />
Dès que plus de trois caisses sont comprises dans un sous-état, le nombre de sous-ensembles de goals à tester risque d'être très grand. Nous ne testerons pas tous les sous-ensembles de goals mais uniquement une partie qui se veut représentative. Pour ce faire, pour valider un sous-état de 3 caisses dans un niveau qui contient 10 goals, nous allons tester les pénalités avec les sous-ensembles de goals suivants : (1,2,3), (4,5,6), (7,8,9), (8,9,10). Remarquons que le dernier sous-ensemble est en partie redondant afin de tester toutes les positions des goals.</div>
<h3 class="subsection"><span class="subsection_label">9.3.1</span> <a id='magicparlabel-3925' />
Sous-état pénalisé minimum</h3>
<div class="standard"><a id='magicparlabel-3926' />
Il peut arriver qu'un sous-état pénalisé contienne plus de caisses que nécessaire pour que la pénalité s'applique (<em>cf. </em>4ème état de la Figure <a href="#fig_active2">9.4</a>). Il faut donc trouver le <em>sous-état pénalisé minimum</em>, c'est-à-dire le sous-état qui comprend le moins de caisses tout en provoquant la même pénalité. Pour y arriver, pour chaque état de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>c</mi>
 </mrow></math> caisses qui est validé, nous allons tester les pénalités de tous les sous-états de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>n</mi><mo>-</mo><mn>1</mn>
  </mrow>
 </mrow></math> caisses. Par récursivité, tous les sous-états qui provoquent une pénalité seront trouvés.</div>
<h2 class="section"><span class="section_label">9.4</span> <a id='magicparlabel-3927' />
<a id="sec_Application" />
Application</h2>
<div class="standard"><a id='magicparlabel-3928' />
Pour déduire la pénalité d'un état de l'arbre de recherche, nous commençons par regrouper tous les sous-états pénalisés qui sont inclus dans celui-ci. Il n'est pas possible d'appliquer directement toutes les pénalités trouvées. En effet, celles-ci sont parfois relatives aux mêmes caisses qui ne peuvent pas être réutilisées plusieurs fois. Il faut donc trouver l'ensemble des sous-états pénalisés compris dans l'état qui maximisera la pénalité déduite sans utiliser deux fois une même caisse.
<br />

</div>

<div class="standard"><a id='magicparlabel-3929' />
La méthode utilisée consiste à classer tous les sous-états pénalisés en fonction du nombre de caisses qu'ils contiennent en utilisant une liste par nombre de caisses. Ensuite, chaque liste sera triée par ordre décroissant de pénalité pour obtenir une organisation comme celle illustrée sur la Figure <a href="#fig_sousetatspenalises">9.6</a>.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3933' />
<img style='width:45%;' src='assets/master_thesis/79_Users_michael_Desktop_memoire_images_penalite_table.png' alt='image: 79_Users_michael_Desktop_memoire_images_penalite_table.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3934' />
<div class='float-caption float-caption-figure'>Figure 9.6:<div class="plain_layout"><a id='magicparlabel-3938' />
<a id="fig_sousetatspenalises" />
Classement de tous les sous-états pénalisés qui correspondent à l'état en cours.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-3939' />
Avant de commencer, nous créons un état temporaire <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow>
    <mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> qui est une copie de l'état en cours. Ensuite, à partir du classement des sous-états, on recherche la pénalité la plus haute disponible et on prend le sous-état avec le moins de caisses correspondant à celle-ci. Pour s'assurer qu'aucune caisse ne puisse être utilisée deux fois, la zone du pousseur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow>
    <mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> est réduite des caisses présentes dans le sous-état pénalisé. On continue à procéder de la sorte tant que des sous-états pénalisés sont inclus dans l'état <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow>
    <mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3940' />
Au final, nous obtiendrons la pénalité déduite de l'état grâce à tous les sous-états pénalisés qui ont pu être inclus dans celui-ci. Cette pénalité déduite s'ajoutera à l'estimation de l'état qui a été calculée à l'aide des méthodes du Chapitre <a href="#cha_Estimation">7</a>.
<br />

</div>

<div class="standard"><a id='magicparlabel-3941' />
Un exemple de pénalité déduite est illustré sur la Figure <a href="#fig_deductionpenalite">9.7</a>. Celle-ci représente la copie <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow>
    <mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> de l'état en cours (en haut à gauche) qui possède une estimation de <em>189</em>. Chaque fois qu'une pénalité est appliquée sur l'état en cours, les caisses correspondantes sont supprimées de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow>
    <mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> et d'autres pénalités qui correspondent aux caisses restantes peuvent ensuite être appliquées. Au total, la pénalité déduite de l'état est de <em>10+6+4=20</em>. L'estimation de la distance restante de l'état est donc de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>+</mo><mi>p</mi><mi>e</mi><mi>n</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>e</mi><mspace width="6px" /><mi>d</mi><mi>e</mi><mi>d</mi><mi>u</mi><mi>i</mi><mi>t</mi><mi>e</mi><mo>=</mo><mn>189</mn><mo>+</mo><mn>20</mn><mo>=</mo><mn>209</mn>
  </mrow>
 </mrow></math>.</div>

<div class="standard"><a id='magicparlabel-3942' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-3946' />
<img style='width:80%;' src='assets/master_thesis/80_Users_michael_Desktop_memoire_images_penalite_deduitetout.png' alt='image: 80_Users_michael_Desktop_memoire_images_penalite_deduitetout.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-3947' />
<div class='float-caption float-caption-figure'>Figure 9.7:<div class="plain_layout"><a id='magicparlabel-3951' />
<a id="fig_deductionpenalite" />
Évolution de l'état temporaire <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>e</mi>
   </mrow>
   <mrow>
    <mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> (gauche) et pénalités appliquées (droite).</div>
</div></div>
</div>

<h1 class="chapter"><span class="chapter_label">Chapitre 10</span> <a id='magicparlabel-3952' />
<a id="cha_Pr___traitement" />
Pré-traitement</h1>
<div class="standard"><a id='magicparlabel-3953' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-3954' />
</div>

<div class="standard" style='text-align: center;'><a id='magicparlabel-3959' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3963' />
<strong>pré-traitement</strong> : travail effectué par le solveur sur un niveau avant de commencer à construire l'arbre de recherche.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3964' />
Le <em>pré-traitement</em> d'un niveau permet de rechercher une certaine quantité d'informations sur celui-ci avant même de commencer à parcourir l'arbre de recherche. C'est une préparation du niveau qui nous aidera à aller plus vite lors de sa résolution.
<br />

</div>

<div class="standard"><a id='magicparlabel-3965' />
Tout l'intérêt du pré-traitement est qu'il est facultatif. C'est-à-dire qu'il est tout à fait possible d'utiliser le solveur sans pré-traitement, avec un petit pré-traitement ou encore en pré-traitant le niveau pendant plusieurs jours pour être sûr de récolter un maximum d'informations utiles.
<br />

</div>

<div class="standard"><a id='magicparlabel-3966' />
Un autre intérêt est qu'il est tout à fait possible de continuer un pré-traitement exactement là où on l'a arrêté la dernière fois. Les informations récoltées sont persistantes et peuvent être réutilisées à l'infini. Plus le temps consacré sur chaque niveau sera important et plus le parcours de l'arbre de recherche aura des chances d'être performant.
<br />

</div>

<div class="standard"><a id='magicparlabel-3967' />
Les pré-traitements concernent deux aspects de la résolution des niveaux que nous avons déjà vus : la<em> table des estimations</em> et les<em> pénalités.</em></div>
<h2 class="section"><span class="section_label">10.1</span> <a id='magicparlabel-3968' />
Table des estimations</h2>
<div class="standard"><a id='magicparlabel-3969' />
La <em>table des estimations</em> correspond à la matrice <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> que nous avons construite lors du Chapitre <a href="#cha_Estimation">7</a>. Celle-ci nous permet de connaître l'estimation du coût nécessaire pour pousser une caisse de la position relative <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> vers la position relative <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>j</mi>
 </mrow></math> d'un niveau.
<br />

</div>

<div class="standard"><a id='magicparlabel-3970' />
Même si la génération de la table des estimations est relativement rapide, il est intéressant de la calculer une seule fois et de l'enregistrer. Ainsi, nous éviterons de nombreux calculs inutiles lors de prochains essais de résolution du niveau. De plus, tous les états et sous-états d'un niveau possèdent la même table des estimations, il ne sera donc pas nécessaire de la recalculer lors de l'application du solveur <em>bestPushes</em> sur les sous-états dont nous voulons tester la pénalité.</div>
<h2 class="section"><span class="section_label">10.2</span> <a id='magicparlabel-3971' />
Pénalités</h2>
<div class="standard"><a id='magicparlabel-3972' />
Les <em>pénalités</em> correspondent aux sous-états pénalisés du Chapitre <a href="#cha_P__nalit__">9</a>. En général, plus le solveur connait de pénalités avant de commencer à résoudre un niveau et moins l'arbre de recherche sera grand. La recherche passive de pénalités que nous avons vue dans la Section <a href="#sub_penalpassive">9.2.1</a> permet de détecter des pénalités avant même de construire l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3973' />
L'intérêt du pré-traitement des pénalités est que si on recherche passivement tous les sous-états pénalisés de 3 caisses et moins, l'obtention de meilleures estimations <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> pour les nœuds de l'arbre de recherche est fort probable. Il est donc possible de lancer la résolution d'un niveau avec l'obligation de tester d'abord tous les sous-états de 3 caisses et moins.
<br />

</div>

<div class="standard"><a id='magicparlabel-3974' />
Cette opération pourra prendre plusieurs heures<div class="foot"><span class="foot_label">1</span><div class="foot_inner"><div class="plain_layout"><a id='magicparlabel-3978' />
sur un Pentium M 1.73Ghz avec 1Go de ram</div>
</div></div> mais pourra être exécutée en plusieurs fois. En effet, la position des caisses du dernier sous-état testé sera sauvegardée et il sera donc possible de reprendre la recherche là où elle a été arrêtée.
<br />

</div>

<div class="standard"><a id='magicparlabel-3979' />
Pour les niveaux les plus difficiles et si la puissance et le temps ne sont pas un problème, rien n'empêche l'utilisateur de continuer la recherche pour 4 caisses et plus. Chaque sous-état pénalisé supplémentaire permettra peut-être de supprimer de nombreux sous-arbres de l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-3980' />
Le fichier contenant les sous-états pénalisés est le même pour la recherche passive et la recherche active de pénalités. La recherche active va donc compléter les résultats obtenus par le pré-traitement lors du parcours de l'arbre de recherche.</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 11</span> <a id='magicparlabel-3981' />
<a id="cha_Post_traitement" />
Post-traitement</h1>
<div class="standard"><a id='magicparlabel-3982' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-3983' />
</div>

<div class="standard" style='text-align: center;'><a id='magicparlabel-3988' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-3992' />
<strong>post-traitement</strong> : travail effectué par le solveur sur un niveau après avoir construit et parcouru l'arbre de recherche sans trouver de solution.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-3993' />
Le <em>post-traitement</em> d'un niveau permet d'analyser l'arbre de recherche à la fin d'un parcours qui n'a pas mené à une solution à cause d'un dépassement de la mémoire allouée ou du nombre de nœuds maximum autorisé. Analyser l'arbre de recherche permet de trouver des informations ou des indices sur ce qui peut encore être amélioré.
<br />

</div>

<div class="standard"><a id='magicparlabel-3994' />
De nouveau, le post-traitement est facultatif, une certaine quantité d'informations va être déduite de l'arbre de recherche mais rien n'oblige l'utilisateur à les utiliser lors du redémarrage du solveur sur le niveau.
<br />

</div>

<div class="standard"><a id='magicparlabel-3995' />
Les post-traitements concernent deux aspects de la résolution des niveaux : l'<em>itération du parcours IDA*</em> et les <em>pénalités probables</em> qui se trouvent dans l'arbre de recherche.</div>
<h2 class="section"><span class="section_label">11.1</span> <a id='magicparlabel-3996' />
Itération du parcours IDA*</h2>
<div class="standard"><a id='magicparlabel-3997' />
Nous avons vu dans la Section <a href="#sec_Parcours_IDA_">6.5</a> que le parcours IDA* procédait à plusieurs itérations du parcours A*, avec une valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> progressive, dans le but de limiter au mieux les efforts de chaque itération. Il arrive parfois que des millions de nœuds soient nécessaires pour qu'une itération de A* se termine entièrement sans trouver de solution pour un certain <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>. Celui-ci va alors être incrémenté pour l'itération suivante du parcours A*.
<br />

</div>

<div class="standard"><a id='magicparlabel-3998' />
Afin d'éviter de recommencer toutes les itérations du parcours A* à chaque exécution du solveur sur un niveau, la valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> est enregistrée dans un fichier à chaque incrémentation de sa valeur. Il est ainsi possible de reprendre la résolution d'un niveau à la dernière itération rencontrée, ce qui peut faire gagner beaucoup de temps. Il sera alors possible d'affirmer : &ldquo;<em>le niveau n'a pas de solution dont le nombre de poussées est en deçà de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>&rdquo;.</em></div>
<h2 class="section"><span class="section_label">11.2</span> <a id='magicparlabel-3999' />
Pénalités probables</h2>
<div class="standard"><a id='magicparlabel-4000' />
En analysant l'arbre de recherche, il est possible de mettre en évidence certains sous-états dont une <em>pénalité non-détectée est probable</em>. Ce sont généralement les sous-états qui apparaissent le plus souvent dans l'arbre de recherche.
<br />

</div>

<div class="standard"><a id='magicparlabel-4001' />
Prenons le cas extrême où un sous-état de 4 caisses provoque un deadlock, et donc une pénalité infinie qui n'est pas détectée. Dans le sous-arbre créé à partir de la dernière poussée formant le deadlock, les 4 caisses resteront immobiles alors que toutes les autres continueront de bouger. Selon nos observations, un tel sous-arbre va souvent contenir plusieurs milliers de nœuds avant d'être abandonné au profit d'un autre plus prometteur.
<br />

</div>

<div class="standard"><a id='magicparlabel-4002' />
Tous les nœuds de ce sous-arbre contiendront 4 caisses sur les mêmes positions. Si nous pouvions détecter tous les sous-états qui sont <em>figés </em>dans l'arbre de recherche et tester leurs pénalités, plusieurs sous-arbres pourraient être évités. C'est ce que nous avons essayé de mettre en place à l'aide de méthodes simples.</div>
<h3 class="subsection"><span class="subsection_label">11.2.1</span> <a id='magicparlabel-4003' />
Positions fréquentes</h3>
<div class="standard"><a id='magicparlabel-4004' />
Lorsqu'un parcours est terminé sans qu'une solution ne soit trouvée, un petit algorithme récursif va parcourir tous les nœuds de l'arbre de recherche et enregistrer le nombre de caisses positionnées sur chaque position du niveau.
<br />

</div>

<div class="standard"><a id='magicparlabel-4005' />
À l'aide du nombre total de caisses sur chaque position, on va établir deux classements :
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-4010' />
Les 15 positions les plus utilisées, excepté les positions qui correspondent aux goals.</li>
<li class="enumerate_item"><a id='magicparlabel-4011' />
Les 15 positions les plus utilisées, toutes positions confondues.
<br />

</li>
</ol>
<div class="standard"><a id='magicparlabel-4012' />
Le premier classement est créé afin de ne pas tenir compte des caisses placées sur un goal qui se situe un coin. Ces positions sont peu intéressantes dans la recherche de sous-états pénalisés. Elles ne bougent pas dans un certain sous-arbre mais ne sont pas nécessairement considérées comme des indications d'une pénalité à découvrir.
<br />

</div>

<div class="standard"><a id='magicparlabel-4013' />
Si nous ne prenons que les 15 positions les plus utilisées, c'est uniquement par compromis entre temps de calcul et nombre de sous-états pénalisés qu'il sera possible de trouver.</div>
<h3 class="subsection"><span class="subsection_label">11.2.2</span> <a id='magicparlabel-4014' />
Sous-états probablement pénalisés</h3>
<div class="standard"><a id='magicparlabel-4015' />
En utilisant les deux classements de positions obtenus dans la section précédente, nous allons créer une liste de tous les sous-états à tester de 1 à 6 caisses pour lesquels les caisses se trouvent toutes sur l'une des 15 positions. Les sous-états de 1 à 3 caisses ne seront pas recréés s'ils ont déjà été testés lors du pré-traitement.
<br />

</div>

<div class="standard"><a id='magicparlabel-4016' />
Ces deux listes comprennent des sous-états qui ont de fortes chances d'être pénalisés. Chaque sous-état sera enregistré dans un fichier. Si rien n'est précisé lors de la prochaine exécution du solveur sur le niveau, chaque sous-état contenu dans le fichier sera testé en pré-traitement et donc, avant le nouveau parcours de l'arbre de recherche.</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 12</span> <a id='magicparlabel-4017' />
Optimisations</h1>
<div class="standard"><a id='magicparlabel-4018' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-4019' />
</div>

<div class="standard"><a id='magicparlabel-4024' />
Ce chapitre présente des fonctionnalités qui ont été intégrées dans notre solveur avec pour objectif de trouver des résultats plus vite et dans un arbre de recherche plus petit. Celles-ci sont basées sur deux méthodes. La première permet de prendre des <em>raccourcis</em> dans l'arbre de recherche en autorisant d'autres types de transitions plus efficaces. La deuxième permet de supprimer une certaine quantité de nœuds inutiles de l'arbre de recherche.</div>
<h2 class="section"><span class="section_label">12.1</span> <a id='magicparlabel-4025' />
<a id="sec_Macro_pouss__es" />
Macro-poussées</h2>
<div class="standard" style='text-align: center;'><a id='magicparlabel-4026' />
<strong><div class='Boxed' style='width: 75%; '><div class="plain_layout"><a id='magicparlabel-4030' />
<strong>macro-poussée</strong> : transition entre deux nœuds de l'arbre de recherche qui permet de pousser directement une caisse sur un goal même s'il faut plusieurs poussées pour y arriver.</div>
</div></strong></div>

<div class="standard"><a id='magicparlabel-4031' />
Les <em>macro-poussées</em> introduisent une nouvelle couche d'abstraction au niveau des transitions possibles dans l'arbre de recherche. Notre première couche d'abstraction était d'utiliser les <em>poussées des caisses</em> au lieu des <em>mouvements du pousseur</em>. Ceci nous avait permis de réduire considérablement l'arbre de recherche en transformant la position du pousseur en une zone du pousseur.
<br />

</div>

<div class="standard"><a id='magicparlabel-4032' />
La nouvelle couche d'abstraction que représentent les macro-poussées se montre très pratique pour prendre des raccourcis dans l'arbre de recherche. Si une caisse peut être poussée sur un goal sans qu'il ne soit nécessaire de bouger d'autres caisses, alors un nouvel état sera créé dans l'arbre avec la caisse située sur le goal et le pousseur juste à côté. Les macro-poussées interviennent en plus des poussées régulières comme illustré sur la Figure <a href="#sec_Macro_pouss__es">12.1</a>.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-4036' />
<img style='width:75%;' src='assets/master_thesis/81_Users_michael_Desktop_memoire_images_macro_macropoussee.png' alt='image: 81_Users_michael_Desktop_memoire_images_macro_macropoussee.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-4037' />
<div class='float-caption float-caption-figure'>Figure 12.1:<div class="plain_layout"><a id='magicparlabel-4041' />
<a id="fig_macropoussee" />
Estimation de l'état en cours ainsi que trois sous-états pénalisés qui y sont inclus.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-4042' />
Pour trouver les macro-poussées qui sont réalisables à partir d'un état de l'arbre de recherche, nous appliquons l'algorithme de Dijkstra sur le graphe connexe amélioré décrit dans la Section <a href="#sub_Distance_r__elle_avec">7.1.3</a>. Le but est de connaître quelles positions du niveau qui contiennent un goal peuvent être atteintes par la caisse.
<br />

</div>

<div class="standard"><a id='magicparlabel-4043' />
Dans la Section <a href="#sub_Distance_r__elle_avec">7.1.3</a>, le graphe connexe calculait la distance d'une caisse vers chacun des goals sans prendre en compte les autres caisses. Cette fois-ci, toutes les autres caisses devront être considérées comme des obstacles. Le graphe connexe amélioré sera donc créé à partir de l'état courant en considérant toutes les autres caisses comme si elles étaient des murs.
<br />

</div>

<div class="standard"><a id='magicparlabel-4044' />
Contrairement à ce que l'on pourrait croire, on n'ajoute pas toutes les macro-poussées détectées dans un état. On ajoute uniquement celles qui ont l'air les plus prometteuses. Inspirée de l'ordonnancement des goals deDemaret (<a href='#LyXCite-DEM07'>2007</a>), cette méthode n'autorise que les macro-poussées des caisses vers les goals qui sont cernés, sur les 4 positions directement voisines, par le plus de caisses et de murs.
<br />

</div>

<div class="standard"><a id='magicparlabel-4045' />
Par exemple, admettons que <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>g</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math> soit un goal dont le voisin du haut est un mur, celui de droite une caisse et les deux autres des positions vides et que <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>g</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math> soit un goal dont trois des quatre voisins sont des positions vides. On assignera un coût 2 à <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>g</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math> et un coût 1 à <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>g</mi>
   </mrow>
   <mrow><mn>2</mn>
   </mrow>
  </msub>
 </mrow></math>. Les macro-poussées autorisées seront uniquement celles qui aboutiront sur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>g</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msub>
 </mrow></math>. Cette technique permet de commencer par remplir les goals des coins et évite ainsi de bloquer des goals derrière des amas de caisses infranchissables.
<br />

</div>

<div class="standard"><a id='magicparlabel-4046' />
En utilisant la méthode des macro-poussées, l'affirmation qui disait que <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> représentait la profondeur d'un nœud dans l'arbre de recherche n'est plus vérifiée. En effet, la valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> d'un état obtenu après macro-poussée correspondra à la somme de la valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> de son père et du nombre de poussées relatif à la macro-poussée.
<br />

</div>

<div class="standard"><a id='magicparlabel-4047' />
Une autre difficulté relative à l'introduction des macro-poussées concerne la remontée dans l'arbre de recherche à partir du nœud solution. Cette remontée permet de trouver le chemin emprunté par le pousseur entre le nœud initial et le nœud solution. Trouver les mouvements successifs du pousseur alors que deux couches d'abstractions sont utilisées n'est pas évident. De nombreuses techniques impliquant l'algorithme de Dijkstra au niveau du pousseur et au niveau des caisses seront utilisées.</div>
<h2 class="section"><span class="section_label">12.2</span> <a id='magicparlabel-4048' />
Élagage</h2>
<div class="standard"><a id='magicparlabel-4049' />
Nous partons de la constatation suivante : un nœud de l'arbre de recherche qui n'est pas solution et dont tous les fils sont rejetés pour cause de deadlock, coût excessif ou duplication est inutile. Ce nœud correspond à une <em>feuille</em> de l'arbre dont on peut affirmer qu'elle ne donnera pas naissance à un sous-arbre car aucun de ses fils n'est en liste d'attente.
<br />

</div>

<div class="standard"><a id='magicparlabel-4050' />
La suppression d'un de ces nœuds<em> </em>inutiles s'effectue lors de son traitement. Nous comptons ses fils réellement placés dans l'arbre de recherche. Si aucun fils n'est gardé à la fin de son traitement, nous décidons de supprimer le nœud de l'arbre.
<br />

</div>

<div class="standard"><a id='magicparlabel-4051' />
Sur base de nombreuses exécutions de notre solveur, nous avons remarqué que cette méthode nous permettait d'économiser en moyenne 30% de la structure de l'arbre de recherche. Ce résultat a pu être obtenu en comparant le nombre de nœuds traités et le nombre de nœuds réellement stockés dans l'arbre de recherche. Ce pourcentage ne nous parait pas incroyable. De fait, nous avons vu que, dans un arbre binaire complet, les feuilles représentent environ la moitié de la structure de l'arbre. Notre arbre de recherche n'est pas binaire et encore moins équilibré mais un gain non négligeable est quand même présent.
<br />

</div>

<div class="standard"><a id='magicparlabel-4052' />
Nous avons voulu pousser l'idée jusqu'à supprimer des sous-arbres complets de l'arbre de recherche qui ne pourraient plus s'étendre. L'objectif était de remonter dans l'arbre de recherche lorsqu'une feuille était trouvée et de supprimer le plus haut nœud pour lequel tous les descendants étaient inutiles. L'idée fonctionnait très bien sur certains niveaux mais, étant donné qu'un nœud peut parfois être obtenu via plusieurs chemins différents, il arrivait que la méthode boucle en repassant de très nombreuses fois sur des chemins qui étaient chaque fois supprimés.
<br />

</div>

<div class="standard"><a id='magicparlabel-4053' />
Cette technique n'est efficace qu'avec une bonne organisation des nœuds en attente. En effet, si nous parcourons en priorité les nœuds pour lesquels <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> est petit, nous obtenons un parcours proche du parcours en largeur. Le résultat est que les feuilles mortes apparaîtront souvent très tardivement dans la recherche ce qui en réduit l'intérêt. Plus le parcours de l'arbre de recherche ressemble à un parcours en profondeur, plus la méthode est efficace. Les tris de liste d'attente conseillés dans les parcours A* et IDA* (<em>cf. </em>Sections <a href="#sub_triA">6.4.3</a> et <a href="#sub_triIDA">6.5.5</a>) sont adaptés à un bon fonctionnement de l'élagage de l'arbre de recherche.</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 13</span> <a id='magicparlabel-4054' />
Résultats</h1>
<div class="standard"><a id='magicparlabel-4055' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-4056' />
</div>

<div class="standard"><a id='magicparlabel-4061' />
Ce chapitre présente les résultats de l'exécution de notre solveur <em>bestPushes</em> sur les 90 niveaux originaux de Sokoban. Ceux-ci constituent une bonne base de tests commune à la plupart des solveurs existants.</div>
<h2 class="section"><span class="section_label">13.1</span> <a id='magicparlabel-4062' />
Généralités</h2>
<div class="standard"><a id='magicparlabel-4063' />
Dans ce mémoire, nous avons présenté un nombre conséquent de méthodes diverses et complémentaires. Tester chaque combinaison de ces méthodes sur les 90 niveaux se serait avéré long et fastidieux. Il faut en effet compter plusieurs heures pour un bon pré-traitement ainsi que plusieurs heures pour la résolution en elle-même. C'est pourquoi nous n'indiquons que les derniers résultats qui ont été obtenus avec l'utilisation de toutes les méthodes présentées.
<br />

</div>

<div class="standard"><a id='magicparlabel-4064' />
Pour plus d'information sur les répercussions de chaque méthode sur le parcours effectué ainsi que sur la taille de l'arbre, il est conseillé de se référer àJunghanns (<a href='#LyXCite-931399'>1999</a>) qui comprend de nombreux tests à ce sujet.
<br />

</div>

<div class="standard"><a id='magicparlabel-4065' />
De manière générale, les méthodes les plus significatives sont :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-4070' />
<strong>La détection des doublons</strong> à l'aide de la table de hachage. Elle permet d'éviter les sous-arbres identiques et les cycles dans l'arbre.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-4071' />
<strong>Les parcours A* et IDA*</strong> qui améliorent grandement l'efficacité du parcours de l'arbre par rapport aux parcours en largeur et en profondeur. L'utilisation des méthodes les plus performantes pour calculer <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> influe beaucoup sur la taille de l'arbre.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-4072' />
<strong>Les différentes méthodes de deadlock</strong> qui réduisent considérablement la taille de l'arbre de recherche.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-4073' />
<strong>La recherche passive et active de sous-états pénalisés</strong> pour affiner la valeur de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>h</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo><mi>n</mi><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-4074' />
Chaque amélioration citée permet d'utiliser de moins en moins de nœuds pour trouver la solution optimale d'un niveau.
<br />

</div>

<div class="standard"><a id='magicparlabel-4075' />
À titre d'exemple, pour être résolu, le niveau 4 nécessite environ :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-4080' />
<strong>4000000 nœuds</strong> à l'aide du parcours en largeur et de la méthode des doublons.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-4081' />
<strong>600000 nœuds</strong> avec le parcours IDA* et les deadlocks simples.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-4082' />
<strong>200000 nœuds</strong> avec la recherche passive de deadlocks de 3 caisses.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-4083' />
<strong>1500 nœuds</strong> avec la recherche passive de pénalités de 3 caisses.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-4084' />
<strong>106 nœuds</strong> avec la recherche active de pénalités et l'utilisation des macro-poussées.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-4085' />
Toutes les méthodes sont complémentaires les unes des autres. Si l'une d'entre elles n'est pas activée, les résultats se montreront nettement moins bons.</div>
<h2 class="section"><span class="section_label">13.2</span> <a id='magicparlabel-4086' />
Tableau des résultats</h2>
<div class="standard"><a id='magicparlabel-4087' />
Le tableau des résultats reprend plusieurs données pour chacun des niveaux.
<br />

</div>

<ol class="enumerate"><li class="enumerate_item"><a id='magicparlabel-4092' />
Le <strong>nombre de poussées de la meilleure solution existante</strong> provient deOriginalHighScore (<a href='#LyXCite-OriginalHighScore'>Pas d'année</a>) etExtraHighScore (<a href='#LyXCite-ExtraHighScore'>Pas d'année</a>). Son optimalité n'est pas garantie mais elle a de grandes chances de l'être.
<br />

</li>
<li class="enumerate_item"><a id='magicparlabel-4093' />
Le <strong>pré-processing</strong> représente le nombre de caisses utilisées lors de la recherche des sous-états pénalisés. Si le chiffre est 3, cela signifie que tous les sous-états pénalisés de 3 caisses et moins ont été trouvés avant de résoudre le niveau.
<br />

</li>
<li class="enumerate_item"><a id='magicparlabel-4094' />
<strong>L'itération IDA* en cours (<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math>)</strong> contient la dernière itération du parcours IDA* atteinte par le solveur.
<br />

</li>
<li class="enumerate_item"><a id='magicparlabel-4095' />
<strong>Le nombre de poussées/mouvements de la solution trouvée</strong>. Les solveurs bestPushes et Rolling Stone trouvent la solution optimale. Le solveur Talking Stone (2) créé par <em>Jean-Noël Demaret</em> trouve une <em>bonne</em> solution qui sera rarement optimale.
<br />

</li>
<li class="enumerate_item"><a id='magicparlabel-4096' />
<strong>Les nœuds explorés<em> </em></strong>correspondent aux nombres de nœuds de l'arbre de recherche qui ont été explorés, lors de la dernière itération d'IDA*, avant de trouver une solution.
<br />

</li>
</ol>
<div class="standard"><a id='magicparlabel-4097' />
Deux variantes de notre solveur ont été créées et utilisées :</div>
<h4 class="subparagraph"><span class="subparagraph_label"></span> <a id='magicparlabel-4102' />
Le parcours lent</h4>
<div class="standard"><a id='magicparlabel-4103' />
C'est le parcours qui est le plus puissant. Une recherche active de pénalités sera appliquée sur la dernière caisse poussée de chaque état rencontré dans l'arbre de recherche. Le but étant de pouvoir détecter un maximum de sous-états pénalisés. L'arbre de recherche s'en trouvera fort réduit mais, en contrepartie, le parcours sera très lent.</div>
<h4 class="subparagraph"><span class="subparagraph_label"></span> <a id='magicparlabel-4104' />
Le parcours rapide</h4>
<div class="standard"><a id='magicparlabel-4105' />
C'est un parcours qui est moins puissant mais qui avance plus vite. Une recherche active ne sera appliquée que tous les 100000 états rencontrés dans l'arbre de recherche. Celle-ci s'appliquera sur toutes les caisses de l'état. Cette précaution doit permettre de détecter les plus grosses pénalités à moindre coût.
<br />

</div>

<div class="standard"><a id='magicparlabel-4106' />
Il est aussi possible d'utiliser un parcours lent pendant quelques milliers de nœuds pour détecter le plus de sous-états pénalisés possibles pour ensuite utiliser un parcours rapide qui bénéficiera de ceux-ci.</div>

<div class="standard"><a id='magicparlabel-4107' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-4111' />
<img style='width:100%;' src='assets/master_thesis/82_Users_michael_Desktop_memoire_images_resultats1.png' alt='image: 82_Users_michael_Desktop_memoire_images_resultats1.png' />
</div>
</div>


<div class="standard"><a id='magicparlabel-4112' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-4116' />
<img style='width:100%;' src='assets/master_thesis/83_Users_michael_Desktop_memoire_images_resultats2.png' alt='image: 83_Users_michael_Desktop_memoire_images_resultats2.png' />
</div>
</div>


<div class="standard"><a id='magicparlabel-4117' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-4121' />
<img style='width:100%;' src='assets/master_thesis/84_Users_michael_Desktop_memoire_images_resultats3.png' alt='image: 84_Users_michael_Desktop_memoire_images_resultats3.png' />
</div>
</div>

<h1 class="chapter"><span class="chapter_label">Chapitre 14</span> <a id='magicparlabel-4122' />
Perspectives</h1>
<div class="standard"><a id='magicparlabel-4123' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-4124' />
</div>

<div class="standard"><a id='magicparlabel-4129' />
Ce chapitre contient quelques pistes pour une future évolution du solveur. Certaines concernent des améliorations de méthodes déjà utilisées et d'autres proposent d'ajouter de nouvelles méthodes.</div>
<h2 class="section"><span class="section_label">14.1</span> <a id='magicparlabel-4130' />
Pénalités probables : améliorations</h2>
<div class="standard"><a id='magicparlabel-4131' />
La méthode de détection des pénalités probables en post-traitement est actuellement très naïve. Elle peut certainement s'avérer plus performante à l'aide des deux améliorations suivantes.</div>
<h3 class="subsection"><span class="subsection_label">14.1.1</span> <a id='magicparlabel-4132' />
Détection d'ensembles de positions occupées simultanément</h3>
<div class="standard"><a id='magicparlabel-4133' />
Nous avons parlé du post-traitement dans le Chapitre <a href="#cha_Post_traitement">11</a>. L'une des méthodes proposée consistait à analyser l'arbre de recherche après l'exécution du solveur pour en déduire les sous-états dont la probabilité d'être pénalisés était forte.
<br />

</div>

<div class="standard"><a id='magicparlabel-4134' />
Notre méthode était de trouver les positions les plus souvent occupées par des caisses pour en déduire une longue liste de sous-états à tester. Une meilleure approche consisterait à détecter non pas les <em>positions</em> les plus utilisées mais les <em>ensembles de positions</em> les plus utilisées simultanément. Bien entendu, un travail bien plus important sur l'arbre de recherche devra être effectué.
<br />

</div>

<div class="standard"><a id='magicparlabel-4135' />
L'avantage d'une telle approche est que les ensembles de positions les plus souvent présents dans l'arbre de recherche vont souvent correspondre à une nouvelle pénalité. Dans le cas actuel où on crèe tous les sous-états possibles à partir de 15 positions différentes, on utilise plutôt une méthode de type <em>brute force</em> qui indiquera un taux bien plus bas de sous-états pénalisés.</div>
<h3 class="subsection"><span class="subsection_label">14.1.2</span> <a id='magicparlabel-4136' />
Détection dynamique des pénalités probables</h3>
<div class="standard"><a id='magicparlabel-4137' />
Le post-traitement consiste à attendre qu'un parcours se termine infructueusement sur un arbre de recherche pour pouvoir analyser ce dernier. Il pourrait être envisageable de ne pas attendre la fin du parcours pour effectuer cette analyse.
<br />

</div>

<div class="standard"><a id='magicparlabel-4138' />
Le but premier de la méthode serait de détecter qu'un sous-ensemble de caisses reste constant dans l'un des sous-arbres de l'arbre de recherche, signe d'une pénalité non détectée. Une technique envisagée serait d'associer un compteur à chaque nœud qui indiquerait le nombre total de ses descendants. À chaque ajout d'un nœud dans l'arbre, le compteur de tous ses parents serait incrémenté.
<br />

</div>

<div class="standard"><a id='magicparlabel-4139' />
Lorsqu'un nœud dépasserait un certain nombre de descendants, l'analyse du sous-arbre formé par ce nœud serait effectuée dans le but de trouver des caisses qui ne bougent pas. Un test classique de pénalité sera alors appliqué sur le sous-état formé par ces caisses.</div>

<div class="standard"><a id='magicparlabel-4140' />
</div>
<h2 class="section"><span class="section_label">14.2</span> <a id='magicparlabel-4141' />
Pénalités restrictives</h2>
<div class="standard"><a id='magicparlabel-4142' />
Sur base de nos résultats et de ceux du solveur Rolling Stone, on remarque que certains niveaux sont difficiles à résoudre<div class="foot"><span class="foot_label">1</span><div class="foot_inner"><div class="plain_layout"><a id='magicparlabel-4146' />
Posons <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>v</mi><mi>a</mi>
   <msub>
    <mrow><mi>l</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> la valeur <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>f</mi>
   </mrow>
   <mrow>
    <mrow><mi>m</mi><mi>a</mi><mi>x</mi>
    </mrow>
   </mrow>
  </msub>
 </mrow></math> de la dernière itération d'IDA* appliquée sans résultat sur un niveau. Posons <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>v</mi><mi>a</mi>
   <msub>
    <mrow><mi>l</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> le nombre de poussées de la meilleure solution connue. On considère un niveau comme difficile à résoudre par le solveur si les deux valeurs <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>v</mi><mi>a</mi>
   <msub>
    <mrow><mi>l</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> et <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>v</mi><mi>a</mi>
   <msub>
    <mrow><mi>l</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> sont éloignées. </div>
</div></div>. Ceux-ci correspondent généralement aux niveaux dont les aires des goals sont multiples (<em>cf</em>. Figure <a href="#fig_difficile1">14.1</a>) ou pour lesquels plusieurs entrées sont possibles pour une unique aire de goal (<em>cf</em>. Figure <a href="#fig_difficile2">14.2</a>). Par <em>aire de goals</em>, nous parlons d'un ensemble de positions voisines qui sont des goals. En effet les goals sont souvent proches les uns des autres.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-4150' />
<img style='width:40%;' src='assets/master_thesis/85_Users_michael_Desktop_memoire_images_difficile1.png' alt='image: 85_Users_michael_Desktop_memoire_images_difficile1.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-4151' />
<div class='float-caption float-caption-figure'>Figure 14.1:<div class="plain_layout"><a id='magicparlabel-4155' />
<a id="fig_difficile1" />
Niveau dans lequel les aires de goals sont multiples.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-4156' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-4160' />
<img style='width:40%;' src='assets/master_thesis/86_Users_michael_Desktop_memoire_images_difficile2.png' alt='image: 86_Users_michael_Desktop_memoire_images_difficile2.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-4161' />
<div class='float-caption float-caption-figure'>Figure 14.2:<div class="plain_layout"><a id='magicparlabel-4165' />
<a id="fig_difficile2" />
Niveau dans lequel l'aire de goals possède plusieurs entrées.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-4166' />
Une raison pour laquelle ces niveaux sont plus difficiles est qu'il arrive souvent que la pénalité d'un sous-état n'affecte qu'un certain sous-ensemble de goals (<em>cf</em>. Figure <a href="#fig_validationse">9.5</a>). Nous appellerons ces pénalités particulières des <em>pénalités restrictives</em>. Selon les méthodes utilisées, ces pénalités ne peuvent pas être gardées. Le but de la validation de pénalité est justement de ne garder que celles qui s'appliquent indépendamment de la destination des caisses.
<br />

</div>

<div class="standard"><a id='magicparlabel-4167' />
Si ces pénalités pouvaient être prises en compte lors du parcours de l'arbre, il est évident que les coûts des nœuds seraient plus précis et par conséquent que la recherche de solution serait plus efficace.
<br />

</div>

<div class="standard"><a id='magicparlabel-4168' />
Le problème est que ces pénalités restrictives sont assez difficiles à utiliser pour les raisons suivantes :
<br />

</div>

<ul class="itemize"><li class="itemize_item"><a id='magicparlabel-4169' />
<strong>Détection</strong>&nbsp;&nbsp;&nbsp;Pour être sûr de pouvoir détecter toutes les pénalités restrictives, il faudrait tester la pénalité de chaque sous-état de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> caisses vers tous les sous-ensembles possibles de <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>n</mi>
 </mrow></math> goals. Un traîtement qui sera très coûteux s'il est fait systématiquement.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-4170' />
<strong>Stockage&nbsp;&nbsp;&nbsp;</strong>S'il faut stocker chaque sous-état relativement à des goals particuliers, le nombre d'informations en mémoire risque d'exploser et la recherche de la pénalité va s'avérer fastidieuse.
<br />

</li>
<li class="itemize_item"><a id='magicparlabel-4171' />
<strong>Application&nbsp;&nbsp;&nbsp;</strong>Actuellement, si un sous-état pénalisé est compris dans l'état en cours, la pénalité trouvée sera ajoutée à l'estimation de l'état. Pour appliquer une pénalité restrictive, il faudrait adapter la méthode hongroise de la Section <a href="#sub_hongrois">7.2.3</a> pour minimiser l'association caisses-goals en prenant en compte cette pénalité.
<br />

</li>
</ul>
<div class="standard"><a id='magicparlabel-4172' />
Si une méthode est trouvée pour résoudre le problème des pénalités restrictives tout en contournant ces trois difficultés, nul doute qu'elle symbolisera une nouvelle avancée dans la résolution de niveaux de Sokoban.</div>
<h2 class="section"><span class="section_label">14.3</span> <a id='magicparlabel-4173' />
Macro-Tunnels</h2>
<div class="standard"><a id='magicparlabel-4174' />
La méthode des <em>Macro-Tunnels</em> provient deJunghanns (<a href='#LyXCite-931399'>1999</a>) et consiste à détecter des tunnels dans les niveaux. Un tunnel est une succession de positions qui forment une ligne bornée sur deux côtés par des murs tel qu'illustré sur la Figure <a href="#fig_tunnel">14.3</a>. Si deux caisses s'engagent en même temps dans un tunnel, elles y resteront bloquées et formeront un deadlock.
<br />

</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-4178' />
<img style='width:40%;' src='assets/master_thesis/87_Users_michael_Desktop_memoire_images_macrotunnel.png' alt='image: 87_Users_michael_Desktop_memoire_images_macrotunnel.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-4179' />
<div class='float-caption float-caption-figure'>Figure 14.3:<div class="plain_layout"><a id='magicparlabel-4183' />
<a id="fig_tunnel" />
Les positions absolues <em>E6</em> à <em>H6</em> forment un tunnel.</div>
</div></div>
</div>


<div class="standard"><a id='magicparlabel-4184' />
La technique utilisée dans les macro-tunnels consiste à <em>téléporter</em> une caisse qui rentre dans un tunnel directement vers sa sortie (de <em>E6</em> à <em>H6</em> et vice-versa). Le nombre moindre de positions pouvant être occupées par des caisses mènera à un arbre de recherche plus petit.
<br />

</div>

<div class="standard"><a id='magicparlabel-4185' />
Dans les faits, la technique des macro-tunnels ne permet pas d'améliorer les performances du solveur de façon surprenante, mais le faible coût lié à son implémentation suffit à justifier sa présence.</div>
<h1 class="chapter"><span class="chapter_label">Chapitre 15</span> <a id='magicparlabel-4186' />
Conclusion</h1>
<div class="standard"><a id='magicparlabel-4187' />
<hr />

</div>

<div class="standard"><a id='magicparlabel-4188' />
</div>

<div class="standard"><a id='magicparlabel-4193' />
Le but de ce mémoire était de créer un programme qui permettait de rechercher et de trouver les solutions optimales de niveaux de Sokoban. Grâce à l'implémentation de nombreuses méthodes provenant de précédentes recherches et à l'intégration de nouvelles fonctionnalités, nous pouvons dire que cet objectif est atteint. À ce jour, notre solveur a réussi à trouver 20 solutions optimales à partir des 90 niveaux originaux que nous avons testés.
<br />

</div>

<div class="standard"><a id='magicparlabel-4194' />
L'implémentation en C++ d'un ensemble de méthodes existantes concernant le parcours, les deadlocks ou les pénalités a été l'un des gros enjeux de ce mémoire. Il a en plus été possible d'intégrer des nouvelles méthodes personnelles à celles existantes. Les nouvelles fonctionnalités les plus pertinentes concernent les deadlock zones, les deadlocks en Z, l'amélioration de l'estimation d'un niveau à l'aide d'un graphe connexe sophistiqué et, d'une manière plus générale, le concept des zones et des traitements binaires.
<br />

</div>

<div class="standard"><a id='magicparlabel-4195' />
Après autant de travail, il peut paraître déconcertant de n'obtenir qu'une vingtaine de solutions optimales. Ce faible taux de résultats est en partie dû à un manque de temps de calcul. En effet, entre la dernière version stable du solveur et la date de remise du mémoire, il n'y a eu que quelques semaines. Celles-ci ont dû être mises à profit pour pré-traîter au mieux les niveaux et essayer de les résoudre. Le pré-traitement a occupé une grande partie de ce temps n'en laissant que peu pour la résolution. Nul doute qu'avec plus de temps, d'autres résultats auraient pu être obtenus. De fait, alors que certains niveaux n'ont été testés que quelques minutes, ceux pour lesquels la recherche a été la plus poussée n'ont pas été testés au delà de quelques centaines de milliers de nœuds : ce qui équivaut à moins de 100Mo de ram. Une marge de progression est donc possible.
<br />

</div>

<div class="standard"><a id='magicparlabel-4196' />
Il peut être intéressant de considérer l'ensemble des sous-états pénalisés trouvés pour chaque niveau comme des résultats intermédiaires de ce mémoire. En effet, ce sont des résultats utiles qui pourraient éventuellement être réutilisés par d'autres solveurs.
<br />

</div>

<div class="standard"><a id='magicparlabel-4197' />
Il y a un point pour lequel notre solveur n'a pas à rougir : le nombre de nœuds parcourus lorsqu'une solution est trouvée. Dans notre tableau de résultats, il est en effet très fréquent que notre arbre de recherche contienne moins de nœuds que celui de Rolling Stone lorsqu'une solution est trouvée. Cette différence provient sûrement de notre méthode des macro-poussées qui privilégie les poussées vers les positions les plus intéressantes.
<br />

</div>

<div class="standard"><a id='magicparlabel-4198' />
Les évolutions de notre solveur sont possibles dans deux directions différentes. La première consiste à ajouter et améliorer les méthodes qui conservent l'optimalité des solutions. La deuxième consiste à ajouter des heuristiques très puissantes, telles que celles présentées par <em>Jean-Noël Demaret</em> dans Talking Stone (2)Demaret (<a href='#LyXCite-DEM07'>2007</a>), sur chaque état exploré de notre arbre de recherche. En ajoutant de bonnes heuristiques à l'efficacité du parcours décrit dans ce mémoire, il est fort probable que le nombre de solutions non-optimales trouvées soit assez important.
<br />

</div>

<div class="standard"><a id='magicparlabel-4199' />
Lors de la rédaction de ce mémoire, l'accent a été mis sur la description des méthodes à l'aide d'exemples illustrés et en évitant d'insérer trop de pseudo-code pour ne pas alourdir la lecture. Pour plus de détails quant à l'implémentation de certaines méthodes, je vous suggère de vous référer au code et aux nombreuses pages de documentation générées à partir de celui-ci. Ces documents se trouvent sur le support numérique accompagnant ce mémoire ainsi que sur <span class="flex_url">http://www.opengl.fr/memoire/</span>.</div>

<div class="standard"><a id='magicparlabel-4204' />
</div>

<div class="standard"><a id='magicparlabel-4210' />
</div>

<div class="standard"><a id='magicparlabel-4230' />
<h2 class='bibtex'>Références</h2><div class='bibtex'><div class='bibtexentry'><a id='LyXCite-culbersonculbersonsokoban' />
<span class='bibtexlabel'>Culberson Pas d'année</span><span class='bibtexinfo'><span class="bib-author">Joseph Culberson</span>, "<span class="bib-title">Sokoban is PSPACE-complete</span>".</span></div>
<div class='bibtexentry'><a id='LyXCite-DEM07' />
<span class='bibtexlabel'>Demaret 2007</span><span class='bibtexinfo'><span class="bib-author">Demaret, Jean-Noël</span>, "<span class="bib-title">L'intelligence artificielle et les jeux : cas du Sokoban</span>" (<span class="bib-year">2007</span>).</span></div>
<div class='bibtexentry'><a id='LyXCite-dor_sokoban' />
<span class='bibtexlabel'>Dor et Zwick Pas d'année</span><span class='bibtexinfo'><span class="bib-author">Dorit Dor and Uri Zwick</span>, "<span class="bib-title">SOKOBAN and other motion planning problems (Extended Abstract)</span>".</span></div>
<div class='bibtexentry'><a id='LyXCite-ExtraHighScore' />
<span class='bibtexlabel'>ExtraHighScore Pas d'année</span><span class='bibtexinfo'>"<span class="bib-title">Extra - sokoban highscore table</span>".</span></div>
<div class='bibtexentry'><a id='LyXCite-Munkres' />
<span class='bibtexlabel'>Frank Pas d'année</span><span class='bibtexinfo'><span class="bib-author">Andras Frank</span>, "<span class="bib-title">Bipartite Matching and the Hungarian Method</span>".</span></div>
<div class='bibtexentry'><a id='LyXCite-931399' />
<span class='bibtexlabel'>Junghanns 1999</span><span class='bibtexinfo'><span class="bib-author">Andreas Junghanns</span>, "<span class="bib-title">Pushing the limits: new developments in single-agent search</span>", <span class="bib-publisher">University of Alberta</span> (<span class="bib-year">1999</span>).</span></div>
<div class='bibtexentry'><a id='LyXCite-OriginalHighScore' />
<span class='bibtexlabel'>OriginalHighScore Pas d'année</span><span class='bibtexinfo'>"<span class="bib-title">Original - sokoban highscore table</span>".</span></div>
<div class='bibtexentry'><a id='LyXCite-SoHistory' />
<span class='bibtexlabel'>SoHistory Pas d'année</span><span class='bibtexinfo'>"<span class="bib-title">Sokoban History</span>".</span></div>
<div class='bibtexentry'><a id='LyXCite-AutomaticSolver' />
<span class='bibtexlabel'>Takahashi Pas d'année</span><span class='bibtexinfo'><span class="bib-author">Ken'ichiro Takahashi</span>, "<span class="bib-title">Sokoban Automatic Solver</span>".</span></div>
<div class='bibtexentry'><a id='LyXCite-VL06' />
<span class='bibtexlabel'>Van Lishout 2006</span><span class='bibtexinfo'><span class="bib-author">Van Lishout, François</span>, "<span class="bib-title">Single-Player Games: Introduction To A New Solving Method</span>" (<span class="bib-year">2006</span>).</span></div>
<div class='bibtexentry'><a id='LyXCite-MunkresCode' />
<span class='bibtexlabel'>Weaver Pas d'année</span><span class='bibtexinfo'><span class="bib-author">John Weaver</span>, "<span class="bib-title">Munkres Code V2</span>".</span></div>
<div class='bibtexentry'><a id='LyXCite-WikiSokoban' />
<span class='bibtexlabel'>WikiSokoban Pas d'année</span><span class='bibtexinfo'>"<span class="bib-title">Sokoban</span>".</span></div>
</div></div>

<div class="standard"><a id='magicparlabel-4231' />
</div>

-->

</div>
