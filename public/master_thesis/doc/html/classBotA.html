<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ISokoban: BotA Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>BotA Class Reference</h1><!-- doxytag: class="BotA" -->A implementation of A* algorithm without specific function f(x) = g(x) + h(x) (this class must be derived).  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="BotA_8h-source.html">BotA.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for BotA:</div>
<div class="dynsection">

<p><center><img src="classBotA.png" usemap="#BotA_map" border="0" alt=""></center>
<map name="BotA_map">
<area href="classBotBestMovesS.html" alt="BotBestMovesS" shape="rect" coords="0,56,100,80">
</map>
</div>

<p>
<a href="classBotA-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#ab85547e677baf43658369ab19a461c4">SOLVER_NAME</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#9445dbf366ee48d823b3a14c8a2f2ccc">BotA</a> (Base *base, <a class="el" href="classLevel.html">Level</a> *level, int maxNodeNumber, int maxRamSize, int openTableSize, int closeTableSize, int <a class="el" href="classBotA.html#7af1b189a9fdad2493d37bfe95a88f01">costLimit</a>, int deadlockedBoxesSearch=2, bool onlyPushNumber=false, bool <a class="el" href="classBotA.html#0c3b3a1502633bce12a4c24c11bc94a8">quickSearch</a>=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#c2684957f288ca6d0bbe8df235e73d77">getMinReject</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#f679b068a36cdf048dc69c03b0f0e673">getCostLimit</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#0f2306d676e3583d56cfb487f7a1ce51">getQuickSearch</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#d607c14485f9d5fa20fd30e30b6167a9">getSize</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#0cf8ff14953027a208fc9a4b4aa3e2a6">getInitialCost</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#e6a4b7fbc9556cebde69fb6645e33c5e">process</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#c261752475e178e7c24dc71971e7e052">saveMostUsedPositions</a> (int numberOfPos)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#13af1593d0bbd3232fa3402f93d9fffd">isDeadTreeNode</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#0661c8a1282d795601a08cdcadecee23">deleteDeadTreeNode</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#2b98a2d6a402cac989295d0e61e41c3e">workOnAlreadySearched</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode, int *counter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#e2f84fb58a1a2083ddedeb0aa1be8417">firstTreeNode</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Child **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#d28875b477b72a8828c974db207253a7">findPonderedChildren</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#e948f2346aaa4c84393d5ef0cfe0eb2f">addTreeNodeToCloseList</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#df50adec8741de89e6e15cba2354a85b">initHashTable</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#a5899fa5196b3e759df41295819a5172">initCloseNodeList</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#1d03bd289e6c6f2425c29d8a8e0b3933">createTreeNode</a> (<a class="el" href="classNode.html">Node</a> *node, <a class="el" href="classTreeNode.html">TreeNode</a> *parentTreeNode, int pushCost)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#ad58285e1b3d2b39df61627f3b1be0bc">moveTreeNode</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode, <a class="el" href="classTreeNode.html">TreeNode</a> *newParent)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#7f064a1906ff8150a2326a8f9d73c2f7">f</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode, int pushCost) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#a1210833ae6accea9e659a2deb062a2a">g</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode, int pushCost) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#c9d54cca141a1f1638a3482a616e9403">h</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#36ac7cef4eb59696ca81ce1aee4f0131">testSolution</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#783294a958a9f517e653f7b3c00d0ebb">solutionNode</a> (const <a class="el" href="classTreeNode.html">TreeNode</a> *treeNode) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#32c08ab7a41550f6d59a9ccdd2f405dd">mostUsedPositions</a> (int number, bool withGoals)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#5a136484ea281a4d12706c6e16576b89">findMaxCellAndReplaceValue</a> (int *tab, int tabLength, bool withGoals)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#3639c29ef6ad542783101d7902432865">printInfos</a> (<a class="el" href="classTreeNode.html">TreeNode</a> *treeNode)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#7af1b189a9fdad2493d37bfe95a88f01">costLimit</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#ddbcca4ef824b0eec4c9e6b06bbcd3cd">minReject</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBotA.html#0c3b3a1502633bce12a4c24c11bc94a8">quickSearch</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A implementation of A* algorithm without specific function f(x) = g(x) + h(x) (this class must be derived). <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="9445dbf366ee48d823b3a14c8a2f2ccc"></a><!-- doxytag: member="BotA::BotA" ref="9445dbf366ee48d823b3a14c8a2f2ccc" args="(Base *base, Level *level, int maxNodeNumber, int maxRamSize, int openTableSize, int closeTableSize, int costLimit, int deadlockedBoxesSearch=2, bool onlyPushNumber=false, bool quickSearch=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BotA::BotA           </td>
          <td>(</td>
          <td class="paramtype">Base *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLevel.html">Level</a> *&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxNodeNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxRamSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>openTableSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>closeTableSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>costLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>deadlockedBoxesSearch</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>onlyPushNumber</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>quickSearch</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for a solver of a level <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>main class of the game </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classLevel.html" title="Class containing a level and every functions about it.">Level</a> to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxNodeNumber</em>&nbsp;</td><td>Limit number of nodes to explore </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxRamSize</em>&nbsp;</td><td>Limit max ram size to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>openTableSize</em>&nbsp;</td><td>size of Open Table to allocate (hashtable) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>closeTableSize</em>&nbsp;</td><td>size of Close Table to allocate (hashtable) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>of accepted f(x). if costLimit = -1, costLimit = +infinity </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deadlockedBoxesSearch</em>&nbsp;</td><td>number of boxes to use when testing every possible positions of deadlock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>onlyPushNumber</em>&nbsp;</td><td>only keep number of pushes in Stats object. don't generate solution <a class="el" href="classPath.html" title="Class usefull to represent a way to move in a level.">Path</a> (CPU saving for deadlocks and penalties) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quickSearch</em>&nbsp;</td><td>don't test penalties of every nodes before adding it on the tree </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="ab85547e677baf43658369ab19a461c4"></a><!-- doxytag: member="BotA::SOLVER_NAME" ref="ab85547e677baf43658369ab19a461c4" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* BotA::SOLVER_NAME           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Name of this solver 
<p>Implemented in <a class="el" href="classBotBestMovesS.html#c29b9292fd9d234d1d4e7c8ef4e36720">BotBestMovesS</a>.</p>

</div>
</div><p>
<a class="anchor" name="c2684957f288ca6d0bbe8df235e73d77"></a><!-- doxytag: member="BotA::getMinReject" ref="c2684957f288ca6d0bbe8df235e73d77" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BotA::getMinReject           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
minReject 
</div>
</div><p>
<a class="anchor" name="f679b068a36cdf048dc69c03b0f0e673"></a><!-- doxytag: member="BotA::getCostLimit" ref="f679b068a36cdf048dc69c03b0f0e673" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BotA::getCostLimit           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
limit of accepted f(x) 
</div>
</div><p>
<a class="anchor" name="0f2306d676e3583d56cfb487f7a1ce51"></a><!-- doxytag: member="BotA::getQuickSearch" ref="0f2306d676e3583d56cfb487f7a1ce51" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BotA::getQuickSearch           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
quick search 
</div>
</div><p>
<a class="anchor" name="d607c14485f9d5fa20fd30e30b6167a9"></a><!-- doxytag: member="BotA::getSize" ref="d607c14485f9d5fa20fd30e30b6167a9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BotA::getSize           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return size in octets of the actual state of this solver <dl class="return" compact><dt><b>Returns:</b></dt><dd>size in octets of the actual state of this solver </dd></dl>

</div>
</div><p>
<a class="anchor" name="0cf8ff14953027a208fc9a4b4aa3e2a6"></a><!-- doxytag: member="BotA::getInitialCost" ref="0cf8ff14953027a208fc9a4b4aa3e2a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BotA::getInitialCost           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get cost of first treeNode <dl class="return" compact><dt><b>Returns:</b></dt><dd>cost of first treeNode </dd></dl>

</div>
</div><p>
<a class="anchor" name="e6a4b7fbc9556cebde69fb6645e33c5e"></a><!-- doxytag: member="BotA::process" ref="e6a4b7fbc9556cebde69fb6645e33c5e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BotA::process           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to resolve this level with a fixed max number of nodes or a fixed max number of ram size to allocate. (first to be reached) 
</div>
</div><p>
<a class="anchor" name="c261752475e178e7c24dc71971e7e052"></a><!-- doxytag: member="BotA::saveMostUsedPositions" ref="c261752475e178e7c24dc71971e7e052" args="(int numberOfPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BotA::saveMostUsedPositions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numberOfPos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If ram limit or node limit are reached, we save a list of sub-states of boxes where cells are most used by boxes in the tree. This list of sub-states will be tested before next solving of same level <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>number</em>&nbsp;</td><td>of "top" cell positions we want to keep. If we take 15, we will have list of every sub-states of 1,2,3,4,5 and 6 boxes for 15 most used positions </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="13af1593d0bbd3232fa3402f93d9fffd"></a><!-- doxytag: member="BotA::isDeadTreeNode" ref="13af1593d0bbd3232fa3402f93d9fffd" args="(TreeNode *treeNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BotA::isDeadTreeNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if a treenode is a dead branch (treenode and all children are in openTable) or not <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>treeNode</em>&nbsp;</td><td>node to be tested </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if treenode is a dead branch, false if not </dd></dl>

</div>
</div><p>
<a class="anchor" name="0661c8a1282d795601a08cdcadecee23"></a><!-- doxytag: member="BotA::deleteDeadTreeNode" ref="0661c8a1282d795601a08cdcadecee23" args="(TreeNode *treeNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BotA::deleteDeadTreeNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
delete a dead treenode from the tree and all its children. Also delete this node from openTable. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>treeNode</em>&nbsp;</td><td>node to be deleted </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b98a2d6a402cac989295d0e61e41c3e"></a><!-- doxytag: member="BotA::workOnAlreadySearched" ref="2b98a2d6a402cac989295d0e61e41c3e" args="(TreeNode *treeNode, int *counter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BotA::workOnAlreadySearched           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>counter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If this node is already searched, we look at the cost of stocked treeNode and move what it need to be moved to keep the lowest cost <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>treeNode</em>&nbsp;</td><td>treenode we want to look if it's new or beter than anything existing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>counter</em>&nbsp;</td><td>counter of children of actual treeNode </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if it's already searched and doesn't need to be added. false if it's not already searched and we need to add it. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e2f84fb58a1a2083ddedeb0aa1be8417"></a><!-- doxytag: member="BotA::firstTreeNode" ref="e2f84fb58a1a2083ddedeb0aa1be8417" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTreeNode.html">TreeNode</a> * BotA::firstTreeNode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get first treeNode from closeNodeList and delete it from the list <dl class="return" compact><dt><b>Returns:</b></dt><dd>first treeNode from closeNodeList </dd></dl>

</div>
</div><p>
<a class="anchor" name="d28875b477b72a8828c974db207253a7"></a><!-- doxytag: member="BotA::findPonderedChildren" ref="d28875b477b72a8828c974db207253a7" args="(TreeNode *treeNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Child ** BotA::findPonderedChildren           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get list of children from a treeNode and move this treenode from close list to open list. This function take macro children too. (children with many pushes to put a box on a goal in one step) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>treeNode</em>&nbsp;</td><td>treeNode we want to find children </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>list of children (terminated by NULL) with list of cost (number of push) of every children. When it's not a macro push, it's always 1. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e948f2346aaa4c84393d5ef0cfe0eb2f"></a><!-- doxytag: member="BotA::addTreeNodeToCloseList" ref="e948f2346aaa4c84393d5ef0cfe0eb2f" args="(TreeNode *treeNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BotA::addTreeNodeToCloseList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new <a class="el" href="classTreeNode.html" title="Improved node representation for trees.">TreeNode</a> to the waiting list at the right position. New Treenode is added TO THE CORRECT PLACE DEPENDING OF ITS COST (best-first search) 
</div>
</div><p>
<a class="anchor" name="df50adec8741de89e6e15cba2354a85b"></a><!-- doxytag: member="BotA::initHashTable" ref="df50adec8741de89e6e15cba2354a85b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BotA::initHashTable           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize empty hashtables 
</div>
</div><p>
<a class="anchor" name="a5899fa5196b3e759df41295819a5172"></a><!-- doxytag: member="BotA::initCloseNodeList" ref="a5899fa5196b3e759df41295819a5172" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BotA::initCloseNodeList           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize empty waiting node list 
</div>
</div><p>
<a class="anchor" name="1d03bd289e6c6f2425c29d8a8e0b3933"></a><!-- doxytag: member="BotA::createTreeNode" ref="1d03bd289e6c6f2425c29d8a8e0b3933" args="(Node *node, TreeNode *parentTreeNode, int pushCost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTreeNode.html">TreeNode</a> * BotA::createTreeNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>parentTreeNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pushCost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a <a class="el" href="classTreeNode.html" title="Improved node representation for trees.">TreeNode</a> from a node and its parent treeNode in the search tree (if he got one, else NULL) and assign a cost at it <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td><a class="el" href="classNode.html" title="Lowest representation of a node. Only contain pusher zone and boxes zone.">Node</a> we want to put in the new <a class="el" href="classTreeNode.html" title="Improved node representation for trees.">TreeNode</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parentTreeNode</em>&nbsp;</td><td>Parent <a class="el" href="classTreeNode.html" title="Improved node representation for trees.">TreeNode</a> we want to attach to new <a class="el" href="classTreeNode.html" title="Improved node representation for trees.">TreeNode</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pushCost</em>&nbsp;</td><td>number of pushes from its parent (usefull for macro-pushes) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new <a class="el" href="classTreeNode.html" title="Improved node representation for trees.">TreeNode</a> that contains param "Node" and a definied cost </dd></dl>

</div>
</div><p>
<a class="anchor" name="ad58285e1b3d2b39df61627f3b1be0bc"></a><!-- doxytag: member="BotA::moveTreeNode" ref="ad58285e1b3d2b39df61627f3b1be0bc" args="(TreeNode *treeNode, TreeNode *newParent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BotA::moveTreeNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>newParent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move a treenode in the tree by split it from its parent and attach it to a new parent <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>treeNode</em>&nbsp;</td><td>treenode we want to move in the tree </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newParent</em>&nbsp;</td><td>new parent for this treenode </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7f064a1906ff8150a2326a8f9d73c2f7"></a><!-- doxytag: member="BotA::f" ref="7f064a1906ff8150a2326a8f9d73c2f7" args="(TreeNode *treeNode, int pushCost) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int BotA::f           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pushCost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cost function to evaluate the cost of a treenode with its position in the tree (parent of treenode must be assigned before calling this function) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>treeNode</em>&nbsp;</td><td>to be computed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pushCost</em>&nbsp;</td><td>number of pushes from its parent (usefull for macro-pushes) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>cost value of this node </dd></dl>

</div>
</div><p>
<a class="anchor" name="a1210833ae6accea9e659a2deb062a2a"></a><!-- doxytag: member="BotA::g" ref="a1210833ae6accea9e659a2deb062a2a" args="(TreeNode *treeNode, int pushCost) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int BotA::g           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pushCost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cost function to evaluate the cost of getting to this treeNode from the initial treenode (parent of treenode must be assigned before calling this function) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>treeNode</em>&nbsp;</td><td>to be computed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pushCost</em>&nbsp;</td><td>number of pushes from its parent (usefull for macro-pushes) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>cost value from start to this node </dd></dl>

</div>
</div><p>
<a class="anchor" name="c9d54cca141a1f1638a3482a616e9403"></a><!-- doxytag: member="BotA::h" ref="c9d54cca141a1f1638a3482a616e9403" args="(TreeNode *treeNode) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int BotA::h           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cost function to evaluate the cost of admissibly estimated distance to a goal treenode from this treenode (parent of treenode must be assigned before calling this function) 
<p>Implemented in <a class="el" href="classBotBestMovesS.html#737fff641aa19f3d89cf98cf87c6ba76">BotBestMovesS</a>.</p>

</div>
</div><p>
<a class="anchor" name="36ac7cef4eb59696ca81ce1aee4f0131"></a><!-- doxytag: member="BotA::testSolution" ref="36ac7cef4eb59696ca81ce1aee4f0131" args="(TreeNode *treeNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BotA::testSolution           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if a treeNode is a solution node and create Stats object. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>treeNode</em>&nbsp;</td><td>treenode we want to test </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if this treenode is a solution, false if not </dd></dl>

</div>
</div><p>
<a class="anchor" name="783294a958a9f517e653f7b3c00d0ebb"></a><!-- doxytag: member="BotA::solutionNode" ref="783294a958a9f517e653f7b3c00d0ebb" args="(const TreeNode *treeNode) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BotA::solutionNode           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if a treenode is a solution treenode (based on h(x)=0 value) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>treeNode</em>&nbsp;</td><td><a class="el" href="classTreeNode.html" title="Improved node representation for trees.">TreeNode</a> to tested </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if this node is solution (h(x) = 0), false if not </dd></dl>

</div>
</div><p>
<a class="anchor" name="32c08ab7a41550f6d59a9ccdd2f405dd"></a><!-- doxytag: member="BotA::mostUsedPositions" ref="32c08ab7a41550f6d59a9ccdd2f405dd" args="(int number, bool withGoals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * BotA::mostUsedPositions           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>withGoals</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find most used positions (boxes on them). Positions with goals or without goals. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>number</em>&nbsp;</td><td>number of most used positions we want to find </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>withGoals</em>&nbsp;</td><td>true if we want to take care of goals, false if not </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>tab of "number" cells filled with most used positions. Be carefull, this tab can be ended with several -1 "number" is bigger than usefull cells </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a136484ea281a4d12706c6e16576b89"></a><!-- doxytag: member="BotA::findMaxCellAndReplaceValue" ref="5a136484ea281a4d12706c6e16576b89" args="(int *tab, int tabLength, bool withGoals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BotA::findMaxCellAndReplaceValue           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tabLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>withGoals</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find max cell of a tab, keep it, and replace it with -1 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tab</em>&nbsp;</td><td>tab of values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tabLength</em>&nbsp;</td><td>length of tab </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>withGoals</em>&nbsp;</td><td>true if we want to take care of goals, false if not </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>max cell of the tab </dd></dl>

</div>
</div><p>
<a class="anchor" name="3639c29ef6ad542783101d7902432865"></a><!-- doxytag: member="BotA::printInfos" ref="3639c29ef6ad542783101d7902432865" args="(TreeNode *treeNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BotA::printInfos           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>treeNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
During solving, print usefull infos in the console <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>treeNode</em>&nbsp;</td><td>treenode to draw </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="7af1b189a9fdad2493d37bfe95a88f01"></a><!-- doxytag: member="BotA::costLimit" ref="7af1b189a9fdad2493d37bfe95a88f01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBotA.html#7af1b189a9fdad2493d37bfe95a88f01">BotA::costLimit</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
limit of accepted f(x) 
</div>
</div><p>
<a class="anchor" name="ddbcca4ef824b0eec4c9e6b06bbcd3cd"></a><!-- doxytag: member="BotA::minReject" ref="ddbcca4ef824b0eec4c9e6b06bbcd3cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classBotA.html#ddbcca4ef824b0eec4c9e6b06bbcd3cd">BotA::minReject</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
minimum value of rejected f(x) for next iteration of IDA*. Maybe costLimit+1 but somethimes it's costLimit+2 or more 
</div>
</div><p>
<a class="anchor" name="0c3b3a1502633bce12a4c24c11bc94a8"></a><!-- doxytag: member="BotA::quickSearch" ref="0c3b3a1502633bce12a4c24c11bc94a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBotA.html#0c3b3a1502633bce12a4c24c11bc94a8">BotA::quickSearch</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test penalties of every nodes 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>include/Solver/BotA/<a class="el" href="BotA_8h-source.html">BotA.h</a><li>src/Solver/BotA/BotA.cpp</ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jun 1 18:02:05 2008 for ISokoban by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
