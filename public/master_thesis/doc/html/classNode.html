<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ISokoban: Node Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>Node Class Reference</h1><!-- doxytag: class="Node" -->Lowest representation of a node. Only contain pusher zone and boxes zone.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="Node_8h-source.html">Node.h</a>&gt;</code>
<p>

<p>
<a href="classNode-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#18da1ba0aa4ae3a68de1b2a50e4d46ce">Node</a> (const Solver *<a class="el" href="classNode.html#68847a1ead037b788c4c8d4495ea5f7b">solver</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#42084887a696848731462de80203b3d7">Node</a> (const Solver *<a class="el" href="classNode.html#68847a1ead037b788c4c8d4495ea5f7b">solver</a>, <a class="el" href="classZone.html">Zone</a> *<a class="el" href="classNode.html#c790ea0a62d0afd78353bb42ab213d93">pusherZone</a>, <a class="el" href="classZone.html">Zone</a> *<a class="el" href="classNode.html#db218c8805a8f69e1b20e7fc07999d42">boxesZone</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#3a5d189805a56b425ce85dac3ecf569e">Node</a> (const <a class="el" href="classNode.html">Node</a> *otherNode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a0840c3cb5c7159be6d992adecd2097c">~Node</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const Solver *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#efc2b775577b323c9b727f4f1f05a991">getSolver</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#6e8ba21ef67fbe0012318900b7f210aa">getPusherZone</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2984742e4312653e1403324f6be153c">getBoxesZone</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#46510e71c4cbda1300948d375e188312">setPusherZone</a> (<a class="el" href="classZone.html">Zone</a> *<a class="el" href="classNode.html#c790ea0a62d0afd78353bb42ab213d93">pusherZone</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#0f5a7e37dd3cd17f91e8aa73962a769d">setBoxesZone</a> (<a class="el" href="classZone.html">Zone</a> *<a class="el" href="classNode.html#db218c8805a8f69e1b20e7fc07999d42">boxesZone</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#6d3e8d8b4fba3b2405e69bccfb7e82ea">isEgal</a> (<a class="el" href="classNode.html">Node</a> *otherNode) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#cb1173c78f7b3b71b45c8281d341234a">isSolution</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classNode.html">Node</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#79458fe90f375dc6c23f316bf6f4c72f">findChildren</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Child **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#2bc13b438c902d39444d12c7f9670e0e">findMacroChildren</a> (<a class="el" href="classNode.html">Node</a> **nodeList)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a730f2ec83d1d3d5224cb97cb127e1e7">listMovesFromAToB</a> (const int posA, const int posB) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#969627276733f88fc8740b0a54d82478">countMovesFromAToB</a> (const int posA, const int posB) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#1ff239408f3d6f9e7d9e2b2f378b5150">print</a> (void) const </td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4a48cf4b4d6698d255169b3ab8aae84">dijkstraRec</a> (int *levelTab, const int startPos, const int colsNumber) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#b2cdfdaa1da7b794bee11ac004575c28">computeCostOfGoals</a> (<a class="el" href="classNode.html">Node</a> *node)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const Solver *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#68847a1ead037b788c4c8d4495ea5f7b">solver</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#c790ea0a62d0afd78353bb42ab213d93">pusherZone</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#db218c8805a8f69e1b20e7fc07999d42">boxesZone</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode_1_1Macro.html">Macro</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Lowest representation of a node. Only contain pusher zone and boxes zone. 
<p>
This is the minimum representation of a level state. But this state cannot be used without the original level <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="18da1ba0aa4ae3a68de1b2a50e4d46ce"></a><!-- doxytag: member="Node::Node" ref="18da1ba0aa4ae3a68de1b2a50e4d46ce" args="(const Solver *solver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node           </td>
          <td>(</td>
          <td class="paramtype">const Solver *&nbsp;</td>
          <td class="paramname"> <em>solver</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for a empty node assigned to a solver <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solver</em>&nbsp;</td><td>Assigned solver </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="42084887a696848731462de80203b3d7"></a><!-- doxytag: member="Node::Node" ref="42084887a696848731462de80203b3d7" args="(const Solver *solver, Zone *pusherZone, Zone *boxesZone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node           </td>
          <td>(</td>
          <td class="paramtype">const Solver *&nbsp;</td>
          <td class="paramname"> <em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>pusherZone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>boxesZone</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for a node with defined pusherZone and boxesZone <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solver</em>&nbsp;</td><td>Assigned solver </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pusherZone</em>&nbsp;</td><td>zone where pusher can move </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxesZone</em>&nbsp;</td><td>zone of boxes positions </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3a5d189805a56b425ce85dac3ecf569e"></a><!-- doxytag: member="Node::Node" ref="3a5d189805a56b425ce85dac3ecf569e" args="(const Node *otherNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::Node           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNode.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>otherNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for a node that's copy of another node <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otherNode</em>&nbsp;</td><td>other node we want to copy </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a0840c3cb5c7159be6d992adecd2097c"></a><!-- doxytag: member="Node::~Node" ref="a0840c3cb5c7159be6d992adecd2097c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node::~Node           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="efc2b775577b323c9b727f4f1f05a991"></a><!-- doxytag: member="Node::getSolver" ref="efc2b775577b323c9b727f4f1f05a991" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Solver* Node::getSolver           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigned solver 
</div>
</div><p>
<a class="anchor" name="6e8ba21ef67fbe0012318900b7f210aa"></a><!-- doxytag: member="Node::getPusherZone" ref="6e8ba21ef67fbe0012318900b7f210aa" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classZone.html">Zone</a>* Node::getPusherZone           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classZone.html" title="Binary representation of positions in a level.">Zone</a> of possible pusher move 
</div>
</div><p>
<a class="anchor" name="a2984742e4312653e1403324f6be153c"></a><!-- doxytag: member="Node::getBoxesZone" ref="a2984742e4312653e1403324f6be153c" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classZone.html">Zone</a>* Node::getBoxesZone           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classZone.html" title="Binary representation of positions in a level.">Zone</a> of boxes 
</div>
</div><p>
<a class="anchor" name="46510e71c4cbda1300948d375e188312"></a><!-- doxytag: member="Node::setPusherZone" ref="46510e71c4cbda1300948d375e188312" args="(Zone *pusherZone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setPusherZone           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>pusherZone</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign pusher zone 
</div>
</div><p>
<a class="anchor" name="0f5a7e37dd3cd17f91e8aa73962a769d"></a><!-- doxytag: member="Node::setBoxesZone" ref="0f5a7e37dd3cd17f91e8aa73962a769d" args="(Zone *boxesZone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setBoxesZone           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>boxesZone</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign boxes zone 
</div>
</div><p>
<a class="anchor" name="6d3e8d8b4fba3b2405e69bccfb7e82ea"></a><!-- doxytag: member="Node::isEgal" ref="6d3e8d8b4fba3b2405e69bccfb7e82ea" args="(Node *otherNode) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isEgal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>otherNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if this node is egal to another node <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otherNode</em>&nbsp;</td><td>Other node we want to compare to this <a class="el" href="classNode.html" title="Lowest representation of a node. Only contain pusher zone and boxes zone.">Node</a> object WARNING : 2 nodes must provide from the same level ! </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if node is the same, false if not </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb1173c78f7b3b71b45c8281d341234a"></a><!-- doxytag: member="Node::isSolution" ref="cb1173c78f7b3b71b45c8281d341234a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isSolution           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if a node is a solution node for the associed level <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if this node is solution, false if not </dd></dl>

</div>
</div><p>
<a class="anchor" name="79458fe90f375dc6c23f316bf6f4c72f"></a><!-- doxytag: member="Node::findChildren" ref="79458fe90f375dc6c23f316bf6f4c72f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a> ** Node::findChildren           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use this node to find all successor nodes. A successor node exists if it can be reached from the original node just by pushing a box. <dl class="return" compact><dt><b>Returns:</b></dt><dd>list of all successor nodes. Terminated by a NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2bc13b438c902d39444d12c7f9670e0e"></a><!-- doxytag: member="Node::findMacroChildren" ref="2bc13b438c902d39444d12c7f9670e0e" args="(Node **nodeList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Child ** Node::findMacroChildren           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> **&nbsp;</td>
          <td class="paramname"> <em>nodeList</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use this node to find all macro successor nodes. A macro successor node exists if we can push a box on a goal directly, even if you have to do many pushes of the same box to make it. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodeList</em>&nbsp;</td><td>list of direct successor previously found with findChildren. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>modified nodeList added with all macro pushes. Terminated by a NULL. <p>
tab of number of pushes for all macro-pushes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a730f2ec83d1d3d5224cb97cb127e1e7"></a><!-- doxytag: member="Node::listMovesFromAToB" ref="a730f2ec83d1d3d5224cb97cb127e1e7" args="(const int posA, const int posB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * Node::listMovesFromAToB           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>posA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>posB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function use this node (box positions) to make the shortest way between position A and position B in the level and return list of moves used to do it. Be carreful, no box can be pushed on the way from A to B <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>posA</em>&nbsp;</td><td>starting position (level representation) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>posB</em>&nbsp;</td><td>ending position (level representation) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>list of moves to go from posA to posB terminated by '' </dd></dl>

</div>
</div><p>
<a class="anchor" name="969627276733f88fc8740b0a54d82478"></a><!-- doxytag: member="Node::countMovesFromAToB" ref="969627276733f88fc8740b0a54d82478" args="(const int posA, const int posB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Node::countMovesFromAToB           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>posA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>posB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function use this node (box positions) to make the shortest way between position A and position B in the level and return number of moves used to do it. Be carreful, no box can be pushed on the way from A to B <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>posA</em>&nbsp;</td><td>starting position (level representation) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>posB</em>&nbsp;</td><td>ending position (level representation) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of moves to go from posA to posB. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ff239408f3d6f9e7d9e2b2f378b5150"></a><!-- doxytag: member="Node::print" ref="1ff239408f3d6f9e7d9e2b2f378b5150" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::print           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print node (level) state in the console 
</div>
</div><p>
<a class="anchor" name="a4a48cf4b4d6698d255169b3ab8aae84"></a><!-- doxytag: member="Node::dijkstraRec" ref="a4a48cf4b4d6698d255169b3ab8aae84" args="(int *levelTab, const int startPos, const int colsNumber) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::dijkstraRec           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>levelTab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>colsNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursive function based on Dijkstra algorithm. It fill a tab in with every informations about min distance between a cell and start pos. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>levelTab</em>&nbsp;</td><td>tab of values (init with -1 for walls and big numbers for every other cells) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startPos</em>&nbsp;</td><td>start position to compute (level representation) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colsNumber</em>&nbsp;</td><td>number of cols in this level </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>levelTab filled with every informations about min distances between a cell and start pos </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2cdfdaa1da7b794bee11ac004575c28"></a><!-- doxytag: member="Node::computeCostOfGoals" ref="b2cdfdaa1da7b794bee11ac004575c28" args="(Node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * Node::computeCostOfGoals           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get cost of every goals for this node. A cost of a goal is the number of boxes or walls just next this goal. cost go from 0 to 4. 4 is a top priority goal <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>node to be tested </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>tab of cost of each goal </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="68847a1ead037b788c4c8d4495ea5f7b"></a><!-- doxytag: member="Node::solver" ref="68847a1ead037b788c4c8d4495ea5f7b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Solver* <a class="el" href="classNode.html#68847a1ead037b788c4c8d4495ea5f7b">Node::solver</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigned solver 
</div>
</div><p>
<a class="anchor" name="c790ea0a62d0afd78353bb42ab213d93"></a><!-- doxytag: member="Node::pusherZone" ref="c790ea0a62d0afd78353bb42ab213d93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classZone.html">Zone</a>* <a class="el" href="classNode.html#c790ea0a62d0afd78353bb42ab213d93">Node::pusherZone</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move zone of the pusher 
</div>
</div><p>
<a class="anchor" name="db218c8805a8f69e1b20e7fc07999d42"></a><!-- doxytag: member="Node::boxesZone" ref="db218c8805a8f69e1b20e7fc07999d42" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classZone.html">Zone</a>* <a class="el" href="classNode.html#db218c8805a8f69e1b20e7fc07999d42">Node::boxesZone</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Position of boxes 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>include/Solver/<a class="el" href="Node_8h-source.html">Node.h</a><li>src/Solver/Node.cpp</ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jun 1 18:02:06 2008 for ISokoban by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
