<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ISokoban: Zone Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>Zone Class Reference</h1><!-- doxytag: class="Zone" -->Binary representation of positions in a level.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="Zone_8h-source.html">Zone.h</a>&gt;</code>
<p>

<p>
<a href="classZone-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#595bc54882b6d94f0a1184bf848b7174">Zone</a> (const <a class="el" href="classZone.html">Zone</a> *<a class="el" href="classZone.html#bdd6e8deebb81352f9c7c6bb4674bfe4">zone</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#600ce64469f1cbf58d620f5f7dd773cc">Zone</a> (FILE *file, int numberOfPositions)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#e9bb45c3f260c213b013b72871113291">Zone</a> (int numberOfPositions)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#d35bffbeee3126416d7fbbdb5619388f">Zone</a> (const <a class="el" href="classZone.html">Zone</a> *zone1, const <a class="el" href="classZone.html">Zone</a> *zone2, int operation)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#9a4680b877cc4a286be9a334fe43db0b">Zone</a> (const <a class="el" href="classLevel.html">Level</a> *level, const int *levelToZonePos, const int *zoneToLevelPos, const int <a class="el" href="classZone.html#ee37b1a515e2ddd892f8611e0cb023f0">length</a>, const int operation)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#20b850b82ac29274369b2a614f92252d">Zone</a> (const <a class="el" href="classZone.html">Zone</a> *boxes, const int startPos, const int *levelToZonePos, int colsNumber)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#562607cb5c4120a9316c5e967a5c610b">~Zone</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#2b0535a445f055b07182053a03cb138e">getLength</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const unsigned int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#3597b21ed9b3e28d5a21125424b5ba8a">getZoneTab</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#bc147f33c3c106fab7d5667e33c3ba50">getNumberCell</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#5948d6ad11329da7f6c6d48fbe9cb167">print</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#0908e4e69df5d99cfd369e3ce5f31d60">print</a> (const <a class="el" href="classLevel.html">Level</a> *level, const int *levelToZonePos) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#117f797fa5b56658f581dca46eb3d21a">readPos</a> (const int pos) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#3079c66162f087db9f10cb3c0a97df2b">write1ToPos</a> (const int pos) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#b469d85326ac9096a5501a0d30f36c5c">write0ToPos</a> (const int pos) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#e46007fdce2e005a70f1e3870c8ff69e">isEgal</a> (const <a class="el" href="classZone.html">Zone</a> *otherZone) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#714a59595d312aaa57231f2ec2aa89cf">isFullOf0</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#671a3b79c2b97088ec6e1a65f5016243">isFullOf1</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#1397ccb01645be99161cff98e84fbbe9">isIncludedIn</a> (const <a class="el" href="classZone.html">Zone</a> *anotherZone) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#1ce708721d3ee07141bbac29f9fe4fb2">getNumberOf1</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#3530e38a0a99204d4a7c56936974c7cc">applyOrWith</a> (<a class="el" href="classZone.html">Zone</a> *otherZone)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#7ac8ed17918caf44163a0bc10ff0b51c">applyAndWith</a> (<a class="el" href="classZone.html">Zone</a> *otherZone)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#0cc9a0b7231c6d44724415b8ed2b841f">applyXorWith</a> (<a class="el" href="classZone.html">Zone</a> *otherZone)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#687b4ecfa7991810cce547b47c35cc27">applyNot</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#3ca3269a31ce68ec94062c6ca19ac7f1">applyMinusWith</a> (<a class="el" href="classZone.html">Zone</a> *otherZone)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#2b4a1a4ff0653ae2af7cf1180d78b014">saveInFile</a> (FILE *file)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#5fb388d64ff0d460cbbc582d1c084d75">makeBoxesZone</a> (const <a class="el" href="classLevel.html">Level</a> *level, const int *zoneToLevelPos)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#23384b0021ff0df9b35a418741f6c81e">makePusherZone</a> (const <a class="el" href="classLevel.html">Level</a> *level, const int *levelToZonePos, const int *zoneToLevelPos)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#7a3c83e3ed7422ea767fc93e9d1ee4e4">recursiveMakePusherZone</a> (const <a class="el" href="classZone.html">Zone</a> *boxes, const int startPos, const int *levelToZonePos, const int colsNumber)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#4e9fdbc9daab3bbda6d8c9b75a2fd04d">makeDeadlockZone</a> (const <a class="el" href="classLevel.html">Level</a> *level, const int *levelToZonePos, const int *zoneToLevelPos)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#0a3508a2f32543d96a1e3f134ab8a292">makeCornerDeadlockZone</a> (const <a class="el" href="classLevel.html">Level</a> *level, const int *zoneToLevelPos)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#dd0a47a68ad20ef2d04c149275c00a36">makeLineDeadlockZone</a> (const <a class="el" href="classLevel.html">Level</a> *level, const int *levelToZonePos, const int *zoneToLevelPos)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#391e4c1403bc1fceb4c1a95babe00c94">makeGoalZone</a> (const <a class="el" href="classLevel.html">Level</a> *level, const int *zoneToLevelPos)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#48bfbd3e0c36b1bb368f847371990c54">makeORZone</a> (const <a class="el" href="classZone.html">Zone</a> *zone1, const <a class="el" href="classZone.html">Zone</a> *zone2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#8038d1df3cbedcba1a876ace75f98d93">makeANDZone</a> (const <a class="el" href="classZone.html">Zone</a> *zone1, const <a class="el" href="classZone.html">Zone</a> *zone2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#122eefc299c4a3dcf2946ad7a45e6141">makeXORZone</a> (const <a class="el" href="classZone.html">Zone</a> *zone1, const <a class="el" href="classZone.html">Zone</a> *zone2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#f2833e539189382deaec4b17f04c9127">makeNOTZone</a> (const <a class="el" href="classZone.html">Zone</a> *zone1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#01ede35498a56be07a4de1fe216a41fe">copyZone</a> (const <a class="el" href="classZone.html">Zone</a> *source)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#9fd32f0f497111930ed662def90986f5">isInCorner</a> (const <a class="el" href="classLevel.html">Level</a> *level, const int pos) const </td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#bdd6e8deebb81352f9c7c6bb4674bfe4">zone</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZone.html#ee37b1a515e2ddd892f8611e0cb023f0">length</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Binary representation of positions in a level. 
<p>
Can be used to represent boxes zone, pusher move zone, deadlocks zone or goals zone.<p>
<a class="el" href="classZone.html" title="Binary representation of positions in a level.">Zone</a> is stocked in a unsigned integer tab (unsigned int = 2 or 4 bits depending of the CPU). Each "usefull" cell of the level (see zoneToLevelPos from solver) corresponds to 1 bit. If this bit is "1" then there is a "box/possible move/deadlock/goal" on this position depending of the wanted action.<p>
Boxes zone representation : 1 if there is a box in this zone position, 0 if not Goals zone representation : 1 if there is a goal in this zone position, 0 if not Deadlock zone representation : 1 if there is a deadlock when a box is in this zone position, 0 if not Pusher move zone representation : 1 if pusher can move on this position OR if this is a box position just next a place where pusher can move, 0 if not <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="595bc54882b6d94f0a1184bf848b7174"></a><!-- doxytag: member="Zone::Zone" ref="595bc54882b6d94f0a1184bf848b7174" args="(const Zone *zone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Zone::Zone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>zone</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for a zone copied from an existing zone <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>zone</em>&nbsp;</td><td>zone we want to copy </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="600ce64469f1cbf58d620f5f7dd773cc"></a><!-- doxytag: member="Zone::Zone" ref="600ce64469f1cbf58d620f5f7dd773cc" args="(FILE *file, int numberOfPositions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Zone::Zone           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numberOfPositions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor to create a zone from a opened file <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>handle to opened file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numberOfPositions</em>&nbsp;</td><td>number of needed positions to store this zone </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e9bb45c3f260c213b013b72871113291"></a><!-- doxytag: member="Zone::Zone" ref="e9bb45c3f260c213b013b72871113291" args="(int numberOfPositions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Zone::Zone           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numberOfPositions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor to create a zone with a certain number of free positions <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numberOfPositions</em>&nbsp;</td><td>number of needed positions to store this zone </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d35bffbeee3126416d7fbbdb5619388f"></a><!-- doxytag: member="Zone::Zone" ref="d35bffbeee3126416d7fbbdb5619388f" args="(const Zone *zone1, const Zone *zone2, int operation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Zone::Zone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>zone1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>zone2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>operation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for a zone based on a binary operation on others zones <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>zone1</em>&nbsp;</td><td>first zone in binary operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zone2</em>&nbsp;</td><td>second zone in binary operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>Kind of binary operation you want to make : Zone::USE_OR new zone will be the result of an OR operation between zone1 and zone2 Zone::USE_AND new zone will be the result of an AND operation between zone1 and zone2 Zone::USE_XOR new zone will be the result of an XOR operation between zone1 and zone2 Zone::USE NOT new zone will be the result of an NOT operation apply on zone1. zone2 is not used in this case and can be NULL. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9a4680b877cc4a286be9a334fe43db0b"></a><!-- doxytag: member="Zone::Zone" ref="9a4680b877cc4a286be9a334fe43db0b" args="(const Level *level, const int *levelToZonePos, const int *zoneToLevelPos, const int length, const int operation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Zone::Zone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLevel.html">Level</a> *&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>levelToZonePos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>zoneToLevelPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>operation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for a zone based on a level state <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>original level we want to make zones from it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>levelToZonePos</em>&nbsp;</td><td>link between real positions and zone positions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zoneToLevelPos</em>&nbsp;</td><td>link between zone positions and real positions in the level </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Number of cells in zoneToLevelPos (number of bits needed) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>Kind of zone we want to make : Zone::PROCESS_BOXES if we want to save positions of boxes in the zone Zone::PROCESS_PUSHER if we want to save possibilities of move of the pusher Zone::PROCESS_DEADLOCK if we want to save every places where a deadlock appears if a box is on it. Zone::PROCESS_GOAL if we want to save every goal places </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="20b850b82ac29274369b2a614f92252d"></a><!-- doxytag: member="Zone::Zone" ref="20b850b82ac29274369b2a614f92252d" args="(const Zone *boxes, const int startPos, const int *levelToZonePos, int colsNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Zone::Zone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>levelToZonePos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>colsNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for pusher zone based on a boxes zone and a starting position <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Boxes zone of the level we want to make pusher zone </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startPos</em>&nbsp;</td><td>Starting position of the pusher (level representation) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>levelToZonePos</em>&nbsp;</td><td>Link between real positions and zone positions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colsNumber</em>&nbsp;</td><td>Number of cols in level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="562607cb5c4120a9316c5e967a5c610b"></a><!-- doxytag: member="Zone::~Zone" ref="562607cb5c4120a9316c5e967a5c610b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Zone::~Zone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2b0535a445f055b07182053a03cb138e"></a><!-- doxytag: member="Zone::getLength" ref="2b0535a445f055b07182053a03cb138e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Zone::getLength           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of positions in the zone 
</div>
</div><p>
<a class="anchor" name="3597b21ed9b3e28d5a21125424b5ba8a"></a><!-- doxytag: member="Zone::getZoneTab" ref="3597b21ed9b3e28d5a21125424b5ba8a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int* Zone::getZoneTab           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Binary representation of the zone 
</div>
</div><p>
<a class="anchor" name="bc147f33c3c106fab7d5667e33c3ba50"></a><!-- doxytag: member="Zone::getNumberCell" ref="bc147f33c3c106fab7d5667e33c3ba50" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Zone::getNumberCell           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate number of cells usefull to represent this zone 
</div>
</div><p>
<a class="anchor" name="5948d6ad11329da7f6c6d48fbe9cb167"></a><!-- doxytag: member="Zone::print" ref="5948d6ad11329da7f6c6d48fbe9cb167" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::print           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a zone in integer and binary mode 
</div>
</div><p>
<a class="anchor" name="0908e4e69df5d99cfd369e3ce5f31d60"></a><!-- doxytag: member="Zone::print" ref="0908e4e69df5d99cfd369e3ce5f31d60" args="(const Level *level, const int *levelToZonePos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::print           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLevel.html">Level</a> *&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>levelToZonePos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print a zone in its level form <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>original level corresponding to the zone </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>levelToZonePos</em>&nbsp;</td><td>Translation table between level and zone </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="117f797fa5b56658f581dca46eb3d21a"></a><!-- doxytag: member="Zone::readPos" ref="117f797fa5b56658f581dca46eb3d21a" args="(const int pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Zone::readPos           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read position "pos" of the zone and return 1 or 0 depending of the bit state at this position <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position we want to read 0 &lt;= pos &lt; NumberCell()*sizeof(unsigned int) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>bit value or -1 if invalid pos </dd></dl>

</div>
</div><p>
<a class="anchor" name="3079c66162f087db9f10cb3c0a97df2b"></a><!-- doxytag: member="Zone::write1ToPos" ref="3079c66162f087db9f10cb3c0a97df2b" args="(const int pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::write1ToPos           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set binary number '1' in the position "pos" of the zone <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position where we want to set 1 0 &lt;= pos &lt; NumberCell()*sizeof(unsigned int) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b469d85326ac9096a5501a0d30f36c5c"></a><!-- doxytag: member="Zone::write0ToPos" ref="b469d85326ac9096a5501a0d30f36c5c" args="(const int pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::write0ToPos           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set binary number '0' in the position "pos" of the zone <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position where we want to set 1 0 &lt;= pos &lt; NumberCell()*sizeof(unsigned int) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e46007fdce2e005a70f1e3870c8ff69e"></a><!-- doxytag: member="Zone::isEgal" ref="e46007fdce2e005a70f1e3870c8ff69e" args="(const Zone *otherZone) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Zone::isEgal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>otherZone</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if this zone is egal to another zone <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otherZone</em>&nbsp;</td><td>Other zone we want to compare to this <a class="el" href="classZone.html" title="Binary representation of positions in a level.">Zone</a> object WARNING : 2 zones must have same lengths ! </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if zone is the same, false if not </dd></dl>

</div>
</div><p>
<a class="anchor" name="714a59595d312aaa57231f2ec2aa89cf"></a><!-- doxytag: member="Zone::isFullOf0" ref="714a59595d312aaa57231f2ec2aa89cf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Zone::isFullOf0           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if a zone is full of 0 : every bits (and so cells) are egal to 0 <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if zone is full of 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="671a3b79c2b97088ec6e1a65f5016243"></a><!-- doxytag: member="Zone::isFullOf1" ref="671a3b79c2b97088ec6e1a65f5016243" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Zone::isFullOf1           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if a zone is full of 1 : every bits are egal to 1 <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if zone is full of 1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1397ccb01645be99161cff98e84fbbe9"></a><!-- doxytag: member="Zone::isIncludedIn" ref="1397ccb01645be99161cff98e84fbbe9" args="(const Zone *anotherZone) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Zone::isIncludedIn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>anotherZone</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if a zone is included in another zone <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>anotherZone</em>&nbsp;</td><td>zone where this zone is included or not </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if it's included, false if not </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ce708721d3ee07141bbac29f9fe4fb2"></a><!-- doxytag: member="Zone::getNumberOf1" ref="1ce708721d3ee07141bbac29f9fe4fb2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Zone::getNumberOf1           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return number of 1 in this zone <dl class="return" compact><dt><b>Returns:</b></dt><dd>number of 1 in this zone </dd></dl>

</div>
</div><p>
<a class="anchor" name="3530e38a0a99204d4a7c56936974c7cc"></a><!-- doxytag: member="Zone::applyOrWith" ref="3530e38a0a99204d4a7c56936974c7cc" args="(Zone *otherZone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classZone.html">Zone</a> * Zone::applyOrWith           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>otherZone</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation resulting of a binary operation OR between this zone and the other zone <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otherZone</em>&nbsp;</td><td><a class="el" href="classZone.html" title="Binary representation of positions in a level.">Zone</a> to make binary operation with </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>resulting zone (this zone that's actually modified) </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ac8ed17918caf44163a0bc10ff0b51c"></a><!-- doxytag: member="Zone::applyAndWith" ref="7ac8ed17918caf44163a0bc10ff0b51c" args="(Zone *otherZone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classZone.html">Zone</a> * Zone::applyAndWith           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>otherZone</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation resulting of a binary operation AND between this zone and the other zone <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otherZone</em>&nbsp;</td><td><a class="el" href="classZone.html" title="Binary representation of positions in a level.">Zone</a> to make binary operation with </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>resulting zone (this zone that's actually modified) </dd></dl>

</div>
</div><p>
<a class="anchor" name="0cc9a0b7231c6d44724415b8ed2b841f"></a><!-- doxytag: member="Zone::applyXorWith" ref="0cc9a0b7231c6d44724415b8ed2b841f" args="(Zone *otherZone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classZone.html">Zone</a> * Zone::applyXorWith           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>otherZone</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation resulting of a binary operation XOR between this zone and the other zone <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otherZone</em>&nbsp;</td><td><a class="el" href="classZone.html" title="Binary representation of positions in a level.">Zone</a> to make binary operation with </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>resulting zone (this zone that's actually modified) </dd></dl>

</div>
</div><p>
<a class="anchor" name="687b4ecfa7991810cce547b47c35cc27"></a><!-- doxytag: member="Zone::applyNot" ref="687b4ecfa7991810cce547b47c35cc27" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classZone.html">Zone</a> * Zone::applyNot           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation resulting of a binary operation XOR between this zone and the other zone <dl class="return" compact><dt><b>Returns:</b></dt><dd>resulting zone (this zone that's actually modified) </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ca3269a31ce68ec94062c6ca19ac7f1"></a><!-- doxytag: member="Zone::applyMinusWith" ref="3ca3269a31ce68ec94062c6ca19ac7f1" args="(Zone *otherZone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classZone.html">Zone</a> * Zone::applyMinusWith           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>otherZone</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation resulting of a MINUS binary operation between this zone and the other zone <dl class="return" compact><dt><b>Returns:</b></dt><dd>resulting zone (this zone that's actually modified) </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b4a1a4ff0653ae2af7cf1180d78b014"></a><!-- doxytag: member="Zone::saveInFile" ref="2b4a1a4ff0653ae2af7cf1180d78b014" args="(FILE *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::saveInFile           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>file</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save this zone directly into a file 
</div>
</div><p>
<a class="anchor" name="5fb388d64ff0d460cbbc582d1c084d75"></a><!-- doxytag: member="Zone::makeBoxesZone" ref="5fb388d64ff0d460cbbc582d1c084d75" args="(const Level *level, const int *zoneToLevelPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::makeBoxesZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLevel.html">Level</a> *&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>zoneToLevelPos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation of boxes positions in a level <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classLevel.html" title="Class containing a level and every functions about it.">Level</a> we want to make zone </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zoneToLevelPos</em>&nbsp;</td><td>Link between zone positions and real positions in the level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="23384b0021ff0df9b35a418741f6c81e"></a><!-- doxytag: member="Zone::makePusherZone" ref="23384b0021ff0df9b35a418741f6c81e" args="(const Level *level, const int *levelToZonePos, const int *zoneToLevelPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::makePusherZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLevel.html">Level</a> *&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>levelToZonePos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>zoneToLevelPos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation of pusher possible moves in a level <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classLevel.html" title="Class containing a level and every functions about it.">Level</a> we want to make zone </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>levelToZonePos</em>&nbsp;</td><td>Link between level positions and zone positions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zoneToLevelPos</em>&nbsp;</td><td>Link between zone positions and real positions in the level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7a3c83e3ed7422ea767fc93e9d1ee4e4"></a><!-- doxytag: member="Zone::recursiveMakePusherZone" ref="7a3c83e3ed7422ea767fc93e9d1ee4e4" args="(const Zone *boxes, const int startPos, const int *levelToZonePos, const int colsNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::recursiveMakePusherZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>levelToZonePos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>colsNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively make a zone representation of pusher possible moves in a level <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td><a class="el" href="classZone.html" title="Binary representation of positions in a level.">Zone</a> representation of boxes in this level </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startPos</em>&nbsp;</td><td>Starting position (level representation) of the pusher </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>levelToZonePos</em>&nbsp;</td><td>Link between level positions and zone positions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colsNumber</em>&nbsp;</td><td>Number of cols in level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4e9fdbc9daab3bbda6d8c9b75a2fd04d"></a><!-- doxytag: member="Zone::makeDeadlockZone" ref="4e9fdbc9daab3bbda6d8c9b75a2fd04d" args="(const Level *level, const int *levelToZonePos, const int *zoneToLevelPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::makeDeadlockZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLevel.html">Level</a> *&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>levelToZonePos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>zoneToLevelPos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation of places where deadlocks appear if a box is on it <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classLevel.html" title="Class containing a level and every functions about it.">Level</a> we want to make zone </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>levelToZonePos</em>&nbsp;</td><td>Link between level positions and zone positions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zoneToLevelPos</em>&nbsp;</td><td>Link between zone positions and real positions in the level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0a3508a2f32543d96a1e3f134ab8a292"></a><!-- doxytag: member="Zone::makeCornerDeadlockZone" ref="0a3508a2f32543d96a1e3f134ab8a292" args="(const Level *level, const int *zoneToLevelPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::makeCornerDeadlockZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLevel.html">Level</a> *&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>zoneToLevelPos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function add corner deadlocks to deadlock zone. This happened when there is a box in a corner made by walls <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classLevel.html" title="Class containing a level and every functions about it.">Level</a> we want to make zone </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zoneToLevelPos</em>&nbsp;</td><td>Link between zone positions and real positions in the level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dd0a47a68ad20ef2d04c149275c00a36"></a><!-- doxytag: member="Zone::makeLineDeadlockZone" ref="dd0a47a68ad20ef2d04c149275c00a36" args="(const Level *level, const int *levelToZonePos, const int *zoneToLevelPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::makeLineDeadlockZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLevel.html">Level</a> *&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>levelToZonePos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>zoneToLevelPos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function add line deadlocks to deadlock zone. This happened when there is a box next a wall and no way to remove it (escape move) You must apply this function AFTER the use of function makeCornerDeadlockZone because we need corner positions. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classLevel.html" title="Class containing a level and every functions about it.">Level</a> we want to make zone </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>levelToZonePos</em>&nbsp;</td><td>Link between level positions and zone positions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zoneToLevelPos</em>&nbsp;</td><td>Link between zone positions and real positions in the level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="391e4c1403bc1fceb4c1a95babe00c94"></a><!-- doxytag: member="Zone::makeGoalZone" ref="391e4c1403bc1fceb4c1a95babe00c94" args="(const Level *level, const int *zoneToLevelPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::makeGoalZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLevel.html">Level</a> *&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>zoneToLevelPos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation of goal places <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classLevel.html" title="Class containing a level and every functions about it.">Level</a> we want to make zone </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zoneToLevelPos</em>&nbsp;</td><td>Link between zone positions and real positions in the level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="48bfbd3e0c36b1bb368f847371990c54"></a><!-- doxytag: member="Zone::makeORZone" ref="48bfbd3e0c36b1bb368f847371990c54" args="(const Zone *zone1, const Zone *zone2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::makeORZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>zone1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>zone2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation resulting of a binary operation OR <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>zone1</em>&nbsp;</td><td>first zone in binary operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zone2</em>&nbsp;</td><td>second zone in binary operation </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8038d1df3cbedcba1a876ace75f98d93"></a><!-- doxytag: member="Zone::makeANDZone" ref="8038d1df3cbedcba1a876ace75f98d93" args="(const Zone *zone1, const Zone *zone2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::makeANDZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>zone1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>zone2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation resulting of a binary operation AND <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>zone1</em>&nbsp;</td><td>first zone in binary operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zone2</em>&nbsp;</td><td>second zone in binary operation </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="122eefc299c4a3dcf2946ad7a45e6141"></a><!-- doxytag: member="Zone::makeXORZone" ref="122eefc299c4a3dcf2946ad7a45e6141" args="(const Zone *zone1, const Zone *zone2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::makeXORZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>zone1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>zone2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation resulting of a binary operation XOR <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>zone1</em>&nbsp;</td><td>first zone in binary operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zone2</em>&nbsp;</td><td>second zone in binary operation </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f2833e539189382deaec4b17f04c9127"></a><!-- doxytag: member="Zone::makeNOTZone" ref="f2833e539189382deaec4b17f04c9127" args="(const Zone *zone1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::makeNOTZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>zone1</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a zone representation resulting of a binary operation NOT <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>zone1</em>&nbsp;</td><td>first zone in binary operation </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="01ede35498a56be07a4de1fe216a41fe"></a><!-- doxytag: member="Zone::copyZone" ref="01ede35498a56be07a4de1fe216a41fe" args="(const Zone *source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Zone::copyZone           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone.html">Zone</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy other zone in this object. Used by constructor. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>zone to be copied in this object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9fd32f0f497111930ed662def90986f5"></a><!-- doxytag: member="Zone::isInCorner" ref="9fd32f0f497111930ed662def90986f5" args="(const Level *level, const int pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Zone::isInCorner           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLevel.html">Level</a> *&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return true if position is in a corner of level (corner with 2 walls) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td><a class="el" href="classLevel.html" title="Class containing a level and every functions about it.">Level</a> we want to test </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position we want to test in the level </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if pos is in a corner of level, return false if not </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="bdd6e8deebb81352f9c7c6bb4674bfe4"></a><!-- doxytag: member="Zone::zone" ref="bdd6e8deebb81352f9c7c6bb4674bfe4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int* <a class="el" href="classZone.html#bdd6e8deebb81352f9c7c6bb4674bfe4">Zone::zone</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
binary representation of the zone 
</div>
</div><p>
<a class="anchor" name="ee37b1a515e2ddd892f8611e0cb023f0"></a><!-- doxytag: member="Zone::length" ref="ee37b1a515e2ddd892f8611e0cb023f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classZone.html#ee37b1a515e2ddd892f8611e0cb023f0">Zone::length</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of positions in the zone 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>include/Solver/<a class="el" href="Zone_8h-source.html">Zone.h</a><li>src/Solver/Zone.cpp</ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jun 1 18:02:06 2008 for ISokoban by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
