<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ISokoban: Class List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li class="current"><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>ISokoban Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="classBotA.html">BotA</a></td><td class="indexvalue">A implementation of A* algorithm without specific function f(x) = g(x) + h(x) (this class must be derived) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotA__ChainedList.html">BotA_ChainedList</a></td><td class="indexvalue">A specific version of <a class="el" href="classChainedList.html" title="Main Double Chained List of ListNodes class.">ChainedList</a> to use specific listNodes with heapStackCell values (only used with closeNodeList) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotA__HashTable.html">BotA_HashTable</a></td><td class="indexvalue">A version of <a class="el" href="classHashTable.html" title="Hash Table Class to store all level states.">HashTable</a> specific to closeNodeList in heap stack With it, we can get or change heapStackCell value of a specific node in the hashtable </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotA__HeapStack.html">BotA_HeapStack</a></td><td class="indexvalue">A Heap Stack of TreeNodes. It can work like a chainedList to sort TreeNodes in order of cost. Smallest is always root treeNode of stack </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotA__ListNode.html">BotA_ListNode</a></td><td class="indexvalue">A version of <a class="el" href="classListNode.html" title="Node representation for chained lists.">ListNode</a> with "f" and "g" getters where f(x)=g(x)+h(x). It's used to make the A* solver </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotA__ListNode2.html">BotA_ListNode2</a></td><td class="indexvalue">A version of <a class="el" href="classListNode.html" title="Node representation for chained lists.">ListNode</a> with "f" and "g" getters where f(x)=g(x)+h(x). It's used to make the A* solver WARNING : this second version of <a class="el" href="classListNode.html" title="Node representation for chained lists.">ListNode</a> is dedicated to close hashtable and use one more variable : "heapStackCell". heapStackCell is the number of cell treeNode of this Listnode is currently in </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotBestMovesS.html">BotBestMovesS</a></td><td class="indexvalue">A* algorithm based on moves number of the pusher. Nodes with less moves are explored first. WARNING : this algorithm doesn't return best moves solution of this level but only a good solution. This is because a state representation of the level doesn't keep exact pusher position but only a pusher zone. This solver will work efficiently (but with a lot of extra work) only if we make level representation with boxes position (zone) and exact pusher position (integer) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotBestPushesS__Penalties.html">BotBestPushesS_Penalties</a></td><td class="indexvalue">Management of cost penalties. Try to detect every sub-states that causes a penalty to the initial cost </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotBFS.html">BotBFS</a></td><td class="indexvalue">Breadth-first search implementation of solver </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotDFS.html">BotDFS</a></td><td class="indexvalue">Depth-first search implementation of solver </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotGoodPushesS.html">BotGoodPushesS</a></td><td class="indexvalue">A* search algorithm based on estimated remaining pushes number of the pusher. (f(x) = h(x)) Nodes with less pushes are explored first. this algorithm DOESN'T return best pushes solution of this level but only a good solution </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBotIDA.html">BotIDA</a></td><td class="indexvalue">IDA* algorithm based on best pushes number </td></tr>
  <tr><td class="indexkey"><a class="el" href="classCellList.html">CellList</a></td><td class="indexvalue">Dijkstra algorithm used to see what goals a box can reach and with how many pushes it could </td></tr>
  <tr><td class="indexkey"><a class="el" href="classChainedList.html">ChainedList</a></td><td class="indexvalue">Main Double Chained List of ListNodes class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classData.html">Data</a></td><td class="indexvalue">Datas relative to game context </td></tr>
  <tr><td class="indexkey"><a class="el" href="classHashTable.html">HashTable</a></td><td class="indexvalue">Hash Table Class to store all level states </td></tr>
  <tr><td class="indexkey"><a class="el" href="classLevel.html">Level</a></td><td class="indexvalue">Class containing a level and every functions about it </td></tr>
  <tr><td class="indexkey"><a class="el" href="classListNode.html">ListNode</a></td><td class="indexvalue"><a class="el" href="classNode.html" title="Lowest representation of a node. Only contain pusher zone and boxes zone.">Node</a> representation for chained lists </td></tr>
  <tr><td class="indexkey"><a class="el" href="classNode.html">Node</a></td><td class="indexvalue">Lowest representation of a node. Only contain pusher zone and boxes zone </td></tr>
  <tr><td class="indexkey"><a class="el" href="classNode_1_1Macro.html">Node::Macro</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classPack.html">Pack</a></td><td class="indexvalue">Class used to store a (xml) pack of levels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classPath.html">Path</a></td><td class="indexvalue">Class usefull to represent a way to move in a level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classStringList.html">StringList</a></td><td class="indexvalue">Management of Lists made of strings </td></tr>
  <tr><td class="indexkey"><a class="el" href="classTreeNode.html">TreeNode</a></td><td class="indexvalue">Improved node representation for trees </td></tr>
  <tr><td class="indexkey"><a class="el" href="classUtil.html">Util</a></td><td class="indexvalue">Utility class only with static method </td></tr>
  <tr><td class="indexkey"><a class="el" href="classZone.html">Zone</a></td><td class="indexvalue">Binary representation of positions in a level </td></tr>
</table>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jun 1 18:02:05 2008 for ISokoban by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
